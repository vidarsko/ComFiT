--- Start of file: comfit\__init__.py ---
from .core import BaseSystem

from .quantum_mechanics import QuantumMechanics

from .phase_field_crystal import \
    PhaseFieldCrystal1DPeriodic, \
    PhaseFieldCrystal2DTriangular, PhaseFieldCrystal2DSquare, \
    PhaseFieldCrystal3DBodyCenteredCubic, PhaseFieldCrystal3DFaceCenteredCubic, \
    PhaseFieldCrystal3DSimpleCubic
    
from .nematic_liquid_crystal import \
    NematicLiquidCrystal

from .bose_einstein_condensate import BoseEinsteinCondensate

from .plot import plot_field_plotly, plot_field_matplotlib, \
    plot_complex_field_matplotlib, plot_complex_field_plotly, \
    plot_angle_field_matplotlib, plot_angle_field_plotly, \
    plot_surface_matplotlib, \
    plot_vector_field_matplotlib, plot_vector_field_plotly, \
    plot_field_in_plane_plotly, plot_field_in_plane_matplotlib, \
    plot_complex_field_in_plane_plotly, plot_complex_field_in_plane_matplotlib, \
    plot_nodes_matplotlib, plot_nodes_plotly

from .tool import tool_colormap, \
    tool_make_animation_movie, tool_make_animation_gif, \
    tool_zoom_plot_matplotlib, tool_multinom, \
    tool_set_plot_axis_properties_matplotlib, tool_set_plot_axis_properties_plotly, \
    tool_complete_field, tool_add_spacing_2D, tool_add_spacing_3D, \
    tool_print_in_color, \
    tool_plotly_find_next_xN, tool_plotly_define_2D_plot_ax, \
    tool_plotly_find_next_sceneN, tool_plotly_define_3D_plot_ax, \
    tool_extract_node_arrays
        



--- End of file: comfit\__init__.py ---

--- Start of file: comfit\core\base_system.py ---
from comfit.core.base_system_init import BaseSystemInit
from comfit.core.base_system_conf import BaseSystemConf
from comfit.core.base_system_evolve import BaseSystemEvolve
from comfit.core.base_system_calc import BaseSystemCalc
from comfit.core.base_system_plot import BaseSystemPlot
from comfit.core.base_system_get import BaseSystemGet

import scipy as sp

class BaseSystem(BaseSystemInit, BaseSystemConf, BaseSystemEvolve, BaseSystemCalc, BaseSystemPlot, BaseSystemGet):
    """
    The BaseSystem class is the base class for all systems in ComFiT.
    """
    
    def fft(self, field):
        """
        Perform a fast Fourier transform on a field.

        Parameters
        ----------
        field : np.ndarray
            The field to transform
            
        Returns
        -------
        np.ndarray
            The transformed field

        Note
        ----
        The field is assumed to represent a field in the dimensions of the system.
        Thus, if the system is 2D and the field is 3D, it is assumed that 
        the provided field is a collection of 2D fields which will be transformed
        individually.
        """
        
        return sp.fft.fftn(field, axes=range(-self.dim, 0))

    def ifft(self, field):
        """Perform an inverse fast Fourier transform on a field.

        Parameters
        ----------
        field : np.ndarray
            The field to transform
            
        Returns
        -------
        np.ndarray
            The transformed field

        Note
        ----
        The field is assumed to represent a field in the dimensions of the system.
        Thus, if the system is 2D and the field is 3D, it is assumed that 
        the provided field is a collection of 2D fields which will be transformed
        individually.
        """
        
        return sp.fft.ifftn(field, axes=range(-self.dim, 0))
--- End of file: comfit\core\base_system.py ---

--- Start of file: comfit\core\base_system_calc.py ---
from typing import Literal, Optional, Union

import numpy as np
import scipy as sp

from comfit.tool.tool_math_functions import tool_multinom

class BaseSystemCalc:
    """Calculation method for the base system class"""
    # CALCULATION FUNCTIONS

    # Calculation of angle fields for vortices of different types
    def calc_angle_field_single_vortex(
        self,
        position: Optional[list] = None,
        charge: int = 1
    ) -> np.ndarray:
        """Calculate the angle field due to a single vortex.
        
        Parameters
        ----------
        position : list, optional
            The position of the vortex. Defaults to None.
        charge : int, optional
            The charge of the vortex. Defaults to 1.
        
        Returns
        -------
        numpy.ndarray
            The angle field calculated for the vortex.
            
        Raises
        ------
        Exception
            If the dimension of the system is not 2.
        """
        if self.dim != 2:
            raise Exception("The dimension of the system must be 2 for a single point vortex.")

        if position is None:
            position = [self.xmid, self.ymid]
        
        theta = charge * np.arctan2(self.y - position[1], self.x - position[0])

        return np.mod(theta + np.pi, 2 * np.pi) - np.pi

    def calc_angle_field_vortex_dipole(
        self,
        dipole_vector: Optional[Union[list[float], tuple[float]]] = None,
        dipole_position: Optional[list[float]] = None
    ) -> np.ndarray:
        """Calculates the angle field for a double vortex system.

        Parameters
        ----------
        dipole_vector : list or tuple, optional
            The dipole vector. If None, defaults to [size_x/3, 0].
        dipole_position : list, optional
            The position of the center of mass of the dipole. If None, defaults to the middle of the grid.
            
        Returns
        -------
        numpy.ndarray
            The calculated angle field for the double vortex system.

        Raises
        ------
        Exception
            If the dimension of the system is not 2.
        """

        if self.dim != 2:
            raise Exception("The dimension of the system must be 2 for a single point vortex.")

        if dipole_vector is None:
            dipole_vector = [self.size_x / 3, 0]

        if dipole_position is None:
            dipole_position = self.rmid
        
        theta = np.zeros(self.dims)
        theta += self.calc_angle_field_single_vortex(dipole_position - np.array(dipole_vector) / 2,
                                                            charge=-1)
        theta += self.calc_angle_field_single_vortex(dipole_position + np.array(dipole_vector) / 2, 
                                                            charge=1)

        # Convert the field to a complex field to make it fit the periodic boundary conditions
        amp = np.exp(1j * theta)

        # Filter the angle field
        width = 0.2 * np.min([self.size_x, self.size_y])
        radius = 0.4 * np.min([self.size_x, self.size_y])

        r2 = self.calc_distance_squared_to_point(self.rmid)
        filter = (1 + np.tanh((radius ** 2 - r2) / width ** 2)) / 2
        amp = amp * filter + (1 - filter)

        theta = np.angle(amp)

        # Roll the field so that the dipole center is at the desired position.
        Rx = round((self.rmid[0] - dipole_position[0]) / self.dx)
        theta = np.roll(theta, -Rx, axis=0)
        Ry = round((self.rmid[1] - dipole_position[1]) / self.dy)
        theta = np.roll(theta, -Ry, axis=1)

        return np.mod(theta + np.pi, 2 * np.pi) - np.pi

    def calc_angle_field_vortex_ring(
            self,
            position: Optional[list[float]] = None,
            radius: Optional[float] = None,
            normal_vector: np.ndarray = [0, 0, 1]
            ) -> np.ndarray:
        """Calculate the angle field for a vortex ring.
        
        Parameters
        ----------
        position : list, optional
            The position of the vortex ring. If None, defaults to the middle of the grid.
        radius : float, optional
            The radius of the vortex ring. If None, defaults to 1/3 of the minimum system size.
        normal_vector : numpy.ndarray, optional
            The normal vector of the vortex ring. Defaults to [0, 0, 1].
            
        Returns
        -------
        numpy.ndarray
            The calculated angle field for the vortex ring.
        """
        if position is None:
            position = self.rmid

        if radius is None:
            radius = np.min([self.size_x, self.size_y, self.size_z]) / 3

        if radius > np.min([self.size_x, self.size_y, self.size_z]) / 3:
            print("Warning: The radius of the suggested vortex ring is large."
                  "This can cause unwanted boundary effects.")

        n = normal_vector / np.linalg.norm(np.array(normal_vector))
        [X, Y, Z] = np.meshgrid(self.x, self.y, self.z, indexing='ij')

        # Add the vortices to the theta-field
        theta = 0
        position = np.array(position)


        m2 = n[0] * (X - position[0]) \
             + n[1] * (Y - position[1]) \
             + n[2] * (Z - position[2])

        m1 = np.sqrt(
            (X - position[0] - m2 * n[0]) ** 2
            + (Y - position[1] - m2 * n[1]) ** 2
            + (Z - position[2] - m2 * n[2]) ** 2
        )

        theta = theta + np.arctan2(m2, m1 + radius)
        theta = theta + np.arctan2(m2, m1 - radius)

        # Convert the field to a complex field to make it fit the periodic boundary conditions
        amp = np.exp(1j * theta)

        # Filter the angle field
        width = 0.2 * np.min([self.size_x, self.size_y, self.size_z])
        radius = 0.4 * np.min([self.size_x, self.size_y, self.size_z])
        # TODO: This radius shares name with the one defining the ring. May cause trouble down the line (Vidar 01.12.23)

        r2 = (self.x.reshape((self.xRes, 1, 1)) - self.xmid) ** 2 \
             + (self.y.reshape((1, self.yRes, 1)) - self.ymid) ** 2 \
             + (self.z.reshape((1, 1, self.zRes)) - self.zmid) ** 2

        filter = (1 + np.tanh((radius ** 2 - r2) / width ** 2)) / 2  # Goes from 1 to 0 continuously
        amp = amp * filter + (1 - filter)

        theta = np.angle(amp)

        # Roll the field so that the ring center is at the desired position.
        Rx = round((self.rmid[0] - position[0]) / self.dx)
        theta = np.roll(theta, -Rx, axis=0)
        Ry = round((self.rmid[1] - position[1]) / self.dy)
        theta = np.roll(theta, -Ry, axis=1)
        Rz = round((self.rmid[2] - position[2]) / self.dz)
        theta = np.roll(theta, -Rz, axis=2)

        return np.mod(theta + np.pi, 2 * np.pi) - np.pi

    def calc_wavenums(
            self, 
            x: np.ndarray
            ) -> np.ndarray:
        """Calculates the wavenumbers corresponding to the input position vectors given by x.

        Parameters
        ----------
        x : numpy.ndarray
            1D array of x-positions.

        Returns
        -------
        numpy.ndarray
            1D array of wavenumbers with all the modes for the given x-array,
            assuming periodicity from x[0] to x[0] over n intervals.

        Examples
        --------
        >>> x = np.array([-10, -5, 0, 5, 10])
        >>> k = instance_of_BaseSystem.calc_wavenums(self, x)
        >>> print(k)
        [ 0.          0.25132741  0.50265482 -0.50265482 -0.25132741]
        """
        n = len(x)

        high = (n - 1) // 2
        low = - (n // 2)

        l = n * (x[1] - x[0])

        k = np.concatenate((np.arange(0, high + 1), np.arange(low, 0))) * 2 * np.pi / l

        return k

    def calc_k2(self):
        """Calculates the squared wavenumber.
        
        Parameters
        ----------
        None
            
        Returns
        -------
        numpy.ndarray
            The squared wavenumber.
        """
        return sum([self.k[i] ** 2 for i in range(len(self.k))])

    def calc_Gaussian_filter_f(self, a0=None):
        """Calculate Gaussian filter in Fourier space.

        This method computes a Gaussian filter in Fourier space using the formula:
        exp(-1/2 * a0^2 * k^2) where k^2 is the squared wavenumber.

        Parameters
        ----------
        a0 : float, optional
            Filter width parameter. If None, uses the instance's a0 attribute.

        Returns
        -------
        numpy.ndarray
            The Gaussian filter in Fourier space.

        Notes
        -----
        The filter is calculated using the squared wavenumber obtained from 
        the calc_k2() method.
        """

        if a0 is None:
            a0 = self.a0

        return np.exp(-1 / 2 * a0 ** 2 * self.calc_k2())

    def calc_determinant_field(self, psi: list[np.ndarray, np.ndarray]) -> np.ndarray:
        """Calculate the determinant transformation of a given field.

        The D-field used in the calculation of the topologicel defect density fields. 
        See the ComFiT documentation for more information:
        https://comfitlib.com/TopologicalDefects/
        
        Parameters
        ----------
        psi : list of numpy.ndarray
            A list of two psi fields.
        
        Returns
        -------
        numpy.ndarray
            The determinant field.
        """
        
        if self.dim == 2:
            if len(psi) == 2:
                psi_f = [sp.fft.fftn(psi[0]), sp.fft.fftn(psi[1])]

                return np.real(
                    sp.fft.ifftn(self.dif[0] * psi_f[0]) * sp.fft.ifftn(self.dif[1] * psi_f[1]) -
                    sp.fft.ifftn(self.dif[1] * psi_f[0]) * sp.fft.ifftn(self.dif[0] * psi_f[1]))
            
        elif self.dim == 3:
            if len(psi) == 2:
                psi_f = [sp.fft.fftn(psi[0]), sp.fft.fftn(psi[1])]

                result = np.array([
                    sp.fft.ifftn(self.dif[1] * psi_f[0]) * sp.fft.ifftn(self.dif[2] * psi_f[1]) -
                    sp.fft.ifftn(self.dif[2] * psi_f[0]) * sp.fft.ifftn(self.dif[1] * psi_f[1]),
                    -sp.fft.ifftn(self.dif[0] * psi_f[0]) * sp.fft.ifftn(self.dif[2] * psi_f[1]) +
                    sp.fft.ifftn(self.dif[2] * psi_f[0]) * sp.fft.ifftn(self.dif[0] * psi_f[1]),
                    sp.fft.ifftn(self.dif[0] * psi_f[0]) * sp.fft.ifftn(self.dif[1] * psi_f[1]) -
                    sp.fft.ifftn(self.dif[1] * psi_f[0]) * sp.fft.ifftn(self.dif[0] * psi_f[1])
                ], dtype='float64')
                #TODO: verify that this is correct to specify as float64. (vidar 26.12.23)

                return np.array(result)

    def calc_defect_density(self, psi: list[np.ndarray, np.ndarray], psi0=1) -> np.ndarray:
        """Calculate the defect density of a given psi field.
        
        Parameters
        ----------
        psi : list of numpy.ndarray
            A list of two psi fields.
        psi0 : float, optional
            The value of psi_0. Default is 1.
            
        Returns
        -------
        numpy.ndarray
            The defect density of the psi field.
        """

        return 1 / (np.pi * psi0 ** 2) * self.calc_determinant_field(psi)

    def calc_defect_density_singular(self, psi: np.ndarray, psi0=1) -> np.ndarray:
        """Calculate the singular defect density for a given psi field.

        Parameters
        ----------
        psi : numpy.ndarray
            The field psi.
        psi0 : float, optional
            The reference value of psi. Default is 1.

        Returns
        -------
        numpy.ndarray
            The defect density for the given psi value.
        """
        return self.calc_defect_density(psi, 1) * self.calc_delta_function(psi, psi0)

    def calc_defect_velocity_field(
        self,
        psi: list[np.ndarray, np.ndarray],
        dt_psi: list[np.ndarray, np.ndarray]
    ) -> list[np.ndarray, np.ndarray]:
        """Calculate the velocity field of the defects in the psi field.

        Parameters
        ----------
        psi : list of numpy.ndarray
            The psi field.
        dt_psi : list of numpy.ndarray
            The time derivative of the psi field.

        Returns
        -------
        list of numpy.ndarray
            The velocity field of the defects.
        """
        if self.dim == 2:
            if len(psi) == 2:
                # Input to exclude region
                threshold = 0.4

                psi_f = [sp.fft.fftn(psi[0]), sp.fft.fftn(psi[1])]

                dx_psi0 = sp.fft.ifftn(self.dif[0] * psi_f[0])
                dy_psi1 = sp.fft.ifftn(self.dif[1] * psi_f[1])
                dx_psi1 = sp.fft.ifftn(self.dif[0] * psi_f[1])
                dy_psi0 = sp.fft.ifftn(self.dif[1] * psi_f[0])

                denominator = np.real(dx_psi0 * dy_psi1 - dx_psi1 * dy_psi0)

                denominator_max = np.max(abs(denominator))
                region_to_ignore = abs(denominator) < threshold * denominator_max

                Vx = -2 * np.real(dt_psi[0] * dy_psi1 - dt_psi[1] * dy_psi0) / denominator
                Vy = -2 * np.real(-dt_psi[0] * dx_psi1 + dt_psi[1] * dx_psi0) / denominator

                #TODO: check if this factor of 2 is actually supposed to be there (Vidar 05.12.23)

                # print(region_to_ignore.shape)
                # print(Vx.shape)
                # print(Vy.shape)

                Vx[region_to_ignore] = 0
                Vy[region_to_ignore] = 0

                return [Vx, Vy]

        elif self.dim == 3:
            if len(psi) == 2:
                # Input to exclude region
                threshold = 0.4

                psi_f = [sp.fft.fftn(psi[0]), sp.fft.fftn(psi[1])]

                dx_psi0 = sp.fft.ifftn(self.dif[0] * psi_f[0])
                dy_psi0 = sp.fft.ifftn(self.dif[1] * psi_f[0])
                dz_psi0 = sp.fft.ifftn(self.dif[2] * psi_f[0])

                dx_psi1 = sp.fft.ifftn(self.dif[0] * psi_f[1])
                dy_psi1 = sp.fft.ifftn(self.dif[1] * psi_f[1])
                dz_psi1 = sp.fft.ifftn(self.dif[2] * psi_f[1])


                denominator = 2 * (dx_psi1 ** 2 * (dy_psi0 ** 2 + dz_psi0 ** 2) + (
                            dy_psi1 * dz_psi0 - dy_psi0 * dz_psi1) ** 2 -
                                   2 * dx_psi0 * dx_psi1 * (dy_psi0 * dy_psi1 + dz_psi0 * dz_psi1) +
                                   dx_psi0 ** 2 * (dy_psi1 ** 2 + dz_psi1 ** 2))

                Vx = -2 * np.real((
                          (-dx_psi1 * (dy_psi0 * dy_psi1 + dz_psi0 * dz_psi1) +
                           dx_psi0 * (dy_psi1 ** 2 + dz_psi1 ** 2)) * dt_psi[0] +
                          (dx_psi1 * (dy_psi0 ** 2 + dz_psi0 ** 2) -
                           dx_psi0 * (dy_psi0 * dy_psi1 + dz_psi0 * dz_psi1)) * dt_psi[1]
                                  )/denominator)
                Vy = -2 * np.real((
                          (dx_psi1 ** 2 * dy_psi0 - dx_psi0 * dx_psi1 * dy_psi1 +
                           dz_psi1 * (-dy_psi1 * dz_psi0 + dy_psi0 * dz_psi1)) * dt_psi[0] +
                          (-dx_psi0 * dx_psi1 * dy_psi0 + dx_psi0 ** 2 * dy_psi1 +
                           dz_psi0 * (dy_psi1 * dz_psi0 - dy_psi0 * dz_psi1)) * dt_psi[1]
                                  ) / denominator)

                Vz = -2 * np.real((
                          ((dx_psi1 ** 2 + dy_psi1 ** 2) * dz_psi0 - (
                                      dx_psi0 * dx_psi1 + dy_psi0 * dy_psi1) * dz_psi1) * dt_psi[0] +
                          (-(dx_psi0 * dx_psi1 + dy_psi0 * dy_psi1) * dz_psi0 + (
                                      dx_psi0 ** 2 + dy_psi0 ** 2) * dz_psi1) * dt_psi[1]
                                ) / denominator)

                denominator_max = np.max(abs(denominator))
                region_to_ignore = abs(denominator) < threshold * denominator_max

                Vx[region_to_ignore] = 0
                Vy[region_to_ignore] = 0
                Vz[region_to_ignore] = 0

                return [Vx, Vy, Vz]

    def calc_defect_current_density(self, psi, dt_psi, psi_0=0):
        """Calculates the conserved current of the superfluid density.
        
        Parameters
        ----------
        psi : numpy.ndarray
            The vector field that we find the density of.
        dt_psi : numpy.ndarray
            The time derivative of psi.
        psi_0 : float or numpy.ndarray, optional
            The equilibrium state. Default is 0.
        
        Returns
        -------
        list of numpy.ndarray
            Components of the conserved current.
        """
        if self.dim == 2:
            if len(psi) == 2:
                psi_f = [sp.fft.fftn(psi[0]), sp.fft.fftn(psi[1])]

                dx_psi0 = sp.fft.ifftn(self.dif[0] * psi_f[0])
                dy_psi1 = sp.fft.ifftn(self.dif[1] * psi_f[1])
                dx_psi1 = sp.fft.ifftn(self.dif[0] * psi_f[1])
                dy_psi0 = sp.fft.ifftn(self.dif[1] * psi_f[0])

                Jx = -  np.real(dt_psi[0] * dy_psi1 - dt_psi[1] * dy_psi0) / (psi_0 * np.pi)
                Jy = - np.real(-dt_psi[0] * dx_psi1 + dt_psi[1] * dx_psi0) / (psi_0 * np.pi)

                return [Jx, Jy]

    def calc_delta_function(self, psi: list[np.ndarray, np.ndarray], psi0=1):
        """Calculate the delta function for a given wavefunction.

        Parameters
        ----------
        psi : list of numpy.ndarray
            The wavefunction.
        psi0 : float, optional
            The width of the wavefunction. Default is 1.

        Returns
        -------
        numpy.ndarray
            The value of the delta function.
        """
        width = psi0 / 2
        n = len(psi)
        if self.dim == 2:
            if n == 2:
                psi2 = psi[0] ** 2 + psi[1] ** 2
                return 1 / (2 * np.pi * width ** 2) * np.exp(-psi2 / (2 * width ** 2))

    def calc_region_interval(self, a: float, b: float) -> np.ndarray:
        """Calculate a boolean array indicating whether a point is within an interval.
        
        Parameters
        ----------
        a : float
            The lower bound of the interval.
        b : float
            The upper bound of the interval.
        
        Returns
        -------
        numpy.ndarray
            A boolean array indicating whether a point is within the interval.
            
        Raises
        ------
        Exception
            If the lower bound is greater than the upper bound or if the dimension of the system is not 1.
        """
        if not (a <= b):
            raise Exception("The lower bound must be less than or equal to the upper bound.")
        
        if not (self.dim == 1):
            raise Exception("This function is only valid for 1D systems.")
        
        return (a <= self.x) & (self.x <= b)
        

    def calc_region_disk(self, position: list[float], radius: float) -> np.ndarray:
        """Calculates a boolean array indicating whether a point is within a disk of a given radius.
        
        Parameters
        ----------
        position : list[float]
            The position of the disk
        radius : float
            The radius of the disk
        
        Returns
        -------
        numpy.ndarray
            A boolean array indicating whether a point is within the disk.
            
        Raises
        ------
        Exception
            If the dimension of the system is not 2.
        """
        if self.dim == 2:
            return self.calc_distance_squared_to_point(position) <= radius ** 2

        else:
            raise Exception("Not valid for other dimensions.")

    def calc_region_ball(self, 
            position: list[float], 
            radius: float) -> np.ndarray:
        """Calculate a boolean array indicating whether a point is within a ball of a given radius.
        
        Parameters
        ----------
        position : list[float]
            The position of the ball
        radius : float
            The radius of the ball
        
        Returns
        -------
        numpy.ndarray
            A boolean array indicating whether a point is within the ball.
            
        Raises
        ------
        Exception
            If the dimension of the system is not 3.
        """
        if self.dim == 3:
            return self.calc_distance_squared_to_point(position) <= radius ** 2

        else:
            raise Exception("Not valid for other dimensions.")

    def calc_Gaussian(self, 
            position=None, 
            width=None, 
            top=None,
            value=None):
        """Calculate the Gaussian function.
        
        Parameters
        ----------
        position : list or array, optional
            The center position of the Gaussian. If None, uses the middle of the grid.
        width : float, optional
            The width of the Gaussian. If None, uses the system's a0 parameter.
        top : float, optional
            The maximum value of the Gaussian function.
        value : float, optional
            The integrated value of the Gaussian function.
            If neither top nor value is provided, the function will be normalized to 1.
        
        Returns
        -------
        numpy.ndarray
            The Gaussian function evaluated on the grid.
        
        Notes
        -----
        If top is provided, it scales the height of the Gaussian.
        If value is provided, it scales the integral of the Gaussian.
        """

        if position is None:
            position = self.rmid
        if width is None:
            width = self.a0

        r2 = self.calc_distance_squared_to_point(position)

        if top is not None:
            return top * np.exp(-r2 / (2 * width ** 2))

        if value is None:
            value =1

        return value*(2*np.pi*width**2)**(-self.dim/2)*np.exp(-r2/(2*width**2))

    def calc_distance_squared_to_point(self, position: Union[float, list[float]]) -> np.ndarray:
        """Calculate the squared distance from each point in the grid to a specified position.

        Parameters
        ----------
        position : Union[float, list[float]]
            The target position. Should be a single float for 1D systems or a list of floats for higher dimensions.

        Returns
        -------
        np.ndarray
            An array of the same dimensionality as the system containing the squared distance 
            from each grid point to the specified position. The shape matches the grid resolution.

        Notes
        -----
        This method accounts for periodic boundary conditions by calculating distances in each
        dimension considering the original position, and positions shifted by +/- the system size.
        It then takes the minimum of these distances to find the shortest path under periodicity.
        """

        if self.dim == 1:
            position = [position]
        
        rx2m = (self.x - position[0] - self.size_x) ** 2
        rx2 = (self.x - position[0]) ** 2
        rx2p = (self.x - position[0] + self.size_x) ** 2

        r2 = np.min(np.stack((rx2m, rx2, rx2p)), axis=0).reshape((self.xRes))

        if self.dim > 1:
            r2 = r2.reshape((self.xRes, 1))

            ry2m = (self.y - position[1] - self.size_y) ** 2
            ry2 = (self.y - position[1]) ** 2
            ry2p = (self.y - position[1] + self.size_y) ** 2
            ry2 = np.min(np.stack((ry2m, ry2, ry2p)), axis=0).reshape((1, self.yRes))

            r2 = r2 + ry2
        
        if self.dim > 2:
            r2 = r2.reshape((self.xRes, self.yRes, 1))
            
            rz2m = (self.z - position[2] - self.size_z) ** 2
            rz2 = (self.z - position[2]) ** 2
            rz2p = (self.z - position[2] + self.size_z) ** 2
            rz2 = np.min(np.stack((rz2m, rz2, rz2p)), axis=0).reshape((1, 1, self.zRes))

            r2 = r2 + rz2

        return r2

    def calc_region_cylinder(
        self,
        position: list[float],
        radius: float,
        normal_vector: np.ndarray,
        height: float
    ) -> np.ndarray:
        """Calculates a boolean array indicating whether a point is within a cylinder of a given radius and height.
        
        Parameters
        ----------
        position : list[float]
            The position of the cylinder
        radius : float
            The radius of the cylinder
        normal_vector : np.ndarray
            The normal vector of the cylinder
        height : float
            The height of the cylinder
        
        Returns
        -------
        np.ndarray
            A boolean array indicating whether a point is within the cylinder.
            
        Raises
        ------
        Exception
            If the dimension of the system is not 3.
        """

        if self.dim == 3:
            t = normal_vector / np.linalg.norm(np.array(normal_vector))

            rx = (self.x - position[0])
            # Points that are further away than half the size of the box are moved to the other side
            rx[rx > self.size_x / 2] = rx[rx > self.size_x / 2] - self.size_x
            rx[rx < -self.size_x / 2] = rx[rx < -self.size_x / 2] + self.size_x

            ry = (self.y - position[1])
            ry[ry > self.size_y / 2] = ry[ry > self.size_y / 2] - self.size_y
            ry[ry < -self.size_y / 2] = ry[ry < -self.size_y / 2] + self.size_y

            rz = (self.z - position[2])
            rz[rz > self.size_z / 2] = rz[rz > self.size_z / 2] - self.size_z
            rz[rz < -self.size_z / 2] = rz[rz < -self.size_z / 2] + self.size_z

            zt = rx * t[0] + ry * t[1] + rz * t[2]

            # Project to perpendicular plane vector
            Rt2 = (rx - zt * t[0]) ** 2 + (ry - zt * t[1]) ** 2 + (rz - zt * t[2]) ** 2

            return (zt ** 2 <= height ** 2) & (Rt2 <= radius ** 2)

        else:
            raise Exception("Not valid for other dimensions.")

    def calc_integrate_field(self, field: np.ndarray, region: Optional[int] = None) -> float:
        """Calculates the integrated field value within a specified region.
        
        Parameters
        ----------
        field : numpy.ndarray
            The field array to integrate.
        region : Optional[int], default=None
            If provided, specifies the region to integrate over.
            If None, integrates over the entire field.
        
        Returns
        -------
        float
            The integrated field value within the region.
            
        Raises
        ------
        Exception
            If the dimension of the field is not compatible.
        """

        if region is None:
            return np.sum(field) * self.dV
        else:
            return np.sum(field[region]) * self.dV

    def calc_integrating_factors_f_and_solver(self, omega_f, method: Literal["ETD2RK", "ETD4RK"]) -> tuple:
        """Calculates the integrating factors and the solver for the evolution equation.
        
        Parameters
        ----------
        omega_f : numpy.ndarray
            The value of omega_f in Fourier space.
        method : {'ETD2RK', 'ETD4RK'}
            The method used for evolution.
        
        Returns
        -------
        tuple
            A tuple containing: integrating_factors_f : list (The integrating 
            factors for the selected method), solver : function (The 
            corresponding solver function for the evolution equation).
                
        Raises
        ------
        Exception
            If the specified method is not implemented.
        """
        if method == 'ETD2RK':
            integrating_factors_f = self.calc_evolution_integrating_factors_ETD2RK(omega_f)
            solver = self.evolve_ETD2RK_loop

        elif method == 'ETD4RK':
            integrating_factors_f = self.calc_evolution_integrating_factors_ETD4RK(omega_f)
            solver = self.evolve_ETD4RK_loop
        else:
            raise Exception("This method is not implemented.")

        return integrating_factors_f, solver

    def calc_advect_field(
        self,
        field: np.ndarray,
        u: np.ndarray,
        field_f: Optional[np.ndarray] = None,
        order: int = 3
    ) -> np.ndarray:
        """Advects field according to the provided displacement field u.
        
        Uses a Taylor expansion up to specified order to compute the advection.
        
        Parameters
        ----------
        field : np.ndarray
            The field to be advected.
        u : np.ndarray
            Displacement field.
        field_f : np.ndarray, optional
            Fourier transform of the field. If None, it will be calculated.
        order : int, default=3
            Order of the Taylor expansion. Must be less than or equal to 3.
            
        Returns
        -------
        np.ndarray
            The field after advection by u.
            
        Raises
        ------
        ValueError
            If the order of the Taylor expansion is greater than 3.
        """

        if order > 3:
            raise ValueError("The order of the taylor expansion must be less than or equal to 3.")

        if field_f is None:
            field_f = sp.fft.fftn(field)

        if order > 0:
            for i in range(self.dim):
                # Calculate the derivative
                difield = sp.fft.ifftn(self.dif[i]*field_f)
                # Advect the PFC
                field = field - u[i]*difield

        if order > 1:
            for i in range(self.dim):
                for j in range(i, self.dim):
                    # Calculate the derivative
                    dijfield = sp.fft.ifftn(self.dif[i]*self.dif[j]*field_f)
                    # Advect the PFC
                    field = field + tool_multinom(i,j)*u[i]*u[j]*dijfield
        
        if order > 2:
            for i in range(self.dim):
                for j in range(i, self.dim):
                    for k in range(j, self.dim):
                        # Calculate the derivative
                        dijkfield = sp.fft.ifftn(self.dif[i]*self.dif[j]*self.dif[k]*field_f)
                        # Advect the PFC
                        field = field - tool_multinom(i,j,k)*u[i]*u[j]*u[k]*dijkfield

        return field

    # def calc_advect_field_alot(
    #     self,
    #     field: np.ndarray,
    #     u: np.ndarray,
    #     field_f: Optional[np.ndarray] = None,
    #     order: int = 3
    # ) -> np.ndarray:

    # if self.dim == 2:
        
    #     Ux = u[0]/self.dx
    #     Uy = u[1]/self.dy



    def calc_evolution_integrating_factors_ETD2RK(self, omega_f: np.ndarray, tol: float = 10 ** (-5)) -> list:
        """Calculates integrating factors for ETD2RK.
        
        Parameters
        ----------
        omega_f : numpy.ndarray
            The value of omega_f in Fourier space.
        tol : float, optional
            Tolerance for when to expand the integrating factors that divide by omega.
            Default is 10^-5.
        
        Returns
        -------
        list
            The list of integrating factors for the ETD2RK method.
        """
        integrating_factors_f = [0, 0, 0]

        integrating_factors_f[0] = np.exp(omega_f * self.dt)
        If1 = integrating_factors_f[0]

        integrating_factors_f[1] = np.divide(If1 - 1, omega_f, 
                                    out=np.full_like(omega_f, self.dt), #Small omega_f * self.dt values are set to low value limit
                                    where=np.abs(omega_f) * self.dt >= tol)

        integrating_factors_f[2] = np.divide(If1 - 1 - omega_f * self.dt, self.dt * omega_f ** 2,
                                    out=np.full_like(omega_f, self.dt / 2), #Small omega_f * self.dt values are set to low value limit
                                    where=np.abs(omega_f) * self.dt >= tol)

        return integrating_factors_f

    def calc_evolution_integrating_factors_ETD4RK(self, omega_f: np.ndarray, tol: float = 10 ** (-5)) -> list:
        """Calculate the evolution integrating factors using the ETDRK4 method.
            
        Parameters
        ----------
        omega_f : numpy.ndarray
            The value of omega_f in Fourier space.
        tol : float, optional
            Tolerance for when to expand the integrating factors that divide by omega.
            Default is 10^-5.
             
        Returns
        -------
        list
            The list of integrating factors for the ETD4RK method.
        """
        integrating_factors_f = [0, 0, 0, 0, 0, 0]

        integrating_factors_f[0] = np.exp(omega_f * self.dt / 2)
        If1 = integrating_factors_f[0]

        integrating_factors_f[1] = np.divide(If1 - 1, omega_f,
                        out=np.full_like(omega_f, self.dt / 2), #Small omega_f * self.dt values are set to low value limit
                        where=np.abs(omega_f) * self.dt >= tol)

        integrating_factors_f[2] = np.exp(omega_f * self.dt)
        If2 = integrating_factors_f[2]

        integrating_factors_f[3] = np.divide(
            -4 - omega_f * self.dt + If2 * (4 - 3 * omega_f * self.dt + omega_f ** 2 * self.dt ** 2),
            omega_f ** 3 * self.dt ** 2,
            out=np.full_like(omega_f, self.dt / 6), #Small omega_f * self.dt values are set to low value limit
            where=np.abs(omega_f) * self.dt >= tol)

        integrating_factors_f[4] = np.divide(
            2 * (2 + omega_f * self.dt + If2 * (-2 + omega_f * self.dt)),
            omega_f ** 3 * self.dt ** 2,
            out=np.full_like(omega_f, self.dt / 3), #Small omega_f * self.dt values are set to low value limit
            where=np.abs(omega_f) * self.dt >= tol)

        integrating_factors_f[5] = np.divide(
            -4 - 3 * omega_f * self.dt - omega_f ** 2 * self.dt ** 2 + If2 * (4 - omega_f * self.dt),
            omega_f ** 3 * self.dt ** 2,
            out=np.full_like(omega_f, self.dt / 6), #Small omega_f * self.dt values are set to low value limit
            where=np.abs(omega_f) * self.dt >= tol)
        
        return integrating_factors_f

    def calc_defect_nodes(
        self,
        defect_density: np.ndarray,
        charge_tolerance: Optional[float] = None,
        integration_radius: Optional[float] = None
    ):
        """Calculate the positions and charges of defect nodes based on the defect density.
        
        Parameters
        ----------
        defect_density : numpy.ndarray
            The defect density field. A positive scalar field to be integrated.
        charge_tolerance : float, optional
            The minimum charge value to consider as a defect. If None, uses default values based on dimension.
        integration_radius : float, optional
            The radius to use for integrating around potential defects. If None, uses default values based on dimension.
        
        Returns
        -------
        list
            A list of dictionaries representing the defect nodes. Each dictionary contains:
            - 'position_index': The position index of the defect node in the defect density array.
            - 'position': The physical position of the defect node.
            
        Raises
        ------
        Exception
            If the defect density is not a positive scalar field.
        """

        if not (defect_density>=0).all():
            raise Exception("Defect density must be a positive real scalar field.")

        defect_nodes = []

        if self.dim == 2:
            if charge_tolerance is None:
                charge_tolerance = 0.2
            if integration_radius is None:
                integration_radius = self.a0
            
            #Auxiliary functions
            def calc_region(position_index,radius):
                return self.calc_region_disk(position=[
                    self.x.flatten()[position_index[0]],
                    self.y.flatten()[position_index[1]]], 
                    radius=radius)

            def calc_position_from_region(defect_density,region_to_integrate,position_index):
                # Calculate the field to integrate
                field_to_integrate = region_to_integrate * defect_density
                # Normalize the field to integrate
                field_to_integrate = field_to_integrate / np.sum(field_to_integrate)

                # Roll the field so that the defect node is at the center
                Rx = round((self.x.flatten()[position_index[0]] - self.xmid) / self.dx)
                field_to_integrate = np.roll(field_to_integrate, -Rx, axis=0)
                Ry = round((self.y.flatten()[position_index[1]] - self.ymid) / self.dy)
                field_to_integrate = np.roll(field_to_integrate, -Ry, axis=1)
                
                x = np.sum(field_to_integrate * self.x) 
                y = np.sum(field_to_integrate * self.y) 

                x = x + Rx*self.dx
                y = y + Ry*self.dy

                return [x,y]

        elif self.dim == 3:
            if charge_tolerance is None:
                charge_tolerance = 0.5*self.a0**2
                # print("charge tolerance",charge_tolerance)
            if integration_radius is None:
                integration_radius = 2*self.a0

            #Auxiliary functions
            def calc_region(position_index,radius):
                return self.calc_region_ball(position=[
                        self.x.flatten()[position_index[0]],
                        self.y.flatten()[position_index[1]],
                        self.z.flatten()[position_index[2]]], 
                        radius=radius)
            
            def calc_position_from_region(defect_density,region_to_integrate,position_index):
                # Calculate the field to integrate
                field_to_integrate = region_to_integrate * defect_density
                # Normalize the field to integrate
                field_to_integrate = field_to_integrate / np.sum(field_to_integrate)

                # Roll the field so that the defect node is at the center
                Rx = round((self.x.flatten()[position_index[0]] - self.xmid) / self.dx)
                field_to_integrate = np.roll(field_to_integrate, -Rx, axis=0)
                Ry = round((self.y.flatten()[position_index[1]] - self.ymid) / self.dy)
                field_to_integrate = np.roll(field_to_integrate, -Ry, axis=1)
                Rz = round((self.z.flatten()[position_index[2]] - self.zmid) / self.dz)
                field_to_integrate = np.roll(field_to_integrate, -Rz, axis=2)

                x = np.sum(field_to_integrate * self.x)
                y = np.sum(field_to_integrate * self.y)
                z = np.sum(field_to_integrate * self.z)

                x = x + Rx*self.dx
                y = y + Ry*self.dy
                z = z + Rz*self.dz

                return [x,y,z]

        #Region to search for defect nodes
        region_to_search = np.ones(self.dims)

        # Calculate the point where defect density is largest
        position_index = np.unravel_index(np.argmax(defect_density*region_to_search), defect_density.shape)

        # Integrate the defect density around this point (i.e. in a disk/ball around)
        region_to_integrate = calc_region(position_index,
                                        radius=integration_radius)

        charge = self.calc_integrate_field(defect_density, region_to_integrate)

        # print("Charge: ", charge)
        # print("Charge tolerance: ", charge_tolerance)

        while charge > charge_tolerance:
            defect_node = {}
            defect_node['position_index'] = position_index

            defect_node['position'] = calc_position_from_region(defect_density,region_to_integrate,position_index)

            # print("Defect node position: ", defect_node['position'])
            defect_nodes.append(defect_node)

            region_to_exclude_from_search = calc_region(position_index,
                                        radius=2*integration_radius)
        
            region_to_search[region_to_exclude_from_search] = 0

            position_index = np.unravel_index(np.argmax(defect_density*region_to_search), defect_density.shape)

            region_to_integrate = calc_region(position_index,
                                        radius=integration_radius)
            
            charge = self.calc_integrate_field(defect_density, region_to_integrate)

        return defect_nodes
--- End of file: comfit\core\base_system_calc.py ---

--- Start of file: comfit\core\base_system_conf.py ---
import numpy as np
import scipy as sp

class BaseSystemConf:
    """ Configuration methods for the base system class"""
    pass
--- End of file: comfit\core\base_system_conf.py ---

--- Start of file: comfit\core\base_system_evolve.py ---
from typing import Callable

import numpy as np
import scipy as sp

class BaseSystemEvolve:
    """ Evolution methods for the base system class"""
    ## Time evolution function
    def evolve_ETD2RK_loop(
        self, 
        integrating_factors_f: list[np.ndarray], 
        nonlinear_evolution_function_f: Callable[[np.ndarray, float], np.ndarray], 
        field: np.ndarray, 
        field_f: np.ndarray
    ) -> tuple[np.ndarray, np.ndarray]:
        """Evolves the given field using the ETD2RK scheme with a loop.

        Parameters
        ----------
        integrating_factors_f : list
            A list of three integrating factors.
        nonlinear_evolution_function_f : callable
            A function that calculates the non-linear evolution of the field
            and returns the fourier transform.
        field : ndarray
            The initial field to be evolved.
        field_f : ndarray
            The Fourier transform of the initial field.

        Returns
        -------
        tuple
            A tuple containing the evolved field and the predicted field in Fourier space.
        """

        N0_f = nonlinear_evolution_function_f(field, self.time)

        a_f = integrating_factors_f[0] * field_f + integrating_factors_f[1] * N0_f
        a = self.ifft(a_f)

        N_a_f = nonlinear_evolution_function_f(a, self.time+self.dt)
        field_f = a_f + integrating_factors_f[2] * (N_a_f - N0_f)
        field = self.ifft(field_f)

        self.time += self.dt

        return field, field_f

    def evolve_ETD4RK_loop(
        self, 
        integrating_factors_f: list[np.ndarray], 
        nonlinear_evolution_function_f: Callable[[np.ndarray, float], np.ndarray], 
        field: np.ndarray, 
        field_f: np.ndarray
    ) -> tuple[np.ndarray, np.ndarray]:
        """Evolves the given field using the ETD4RK scheme with a loop.

        Parameters
        ----------
        integrating_factors_f : list
            A list of five integrating factors.
        nonlinear_evolution_function_f : callable
            A function that calculates the non-linear evolution of the field.
        field : ndarray
            The initial field to be evolved.
        field_f : ndarray
            The Fourier transform of the initial field.

        Returns
        -------
        tuple
            A tuple containing the evolved field and the predicted field in Fourier space.
        """
         
        N_0f = nonlinear_evolution_function_f(field, self.time)

        a_f = field_f * integrating_factors_f[0] + N_0f * integrating_factors_f[1]
        a = self.ifft(a_f)
        N_a = nonlinear_evolution_function_f(a, self.time + self.dt / 2)

        b_f = field_f * integrating_factors_f[0] + N_a * integrating_factors_f[1]
        b = self.ifft(b_f)
        N_b = nonlinear_evolution_function_f(b, self.time + self.dt / 2)

        c_f = a_f * integrating_factors_f[0] + (2 * N_b - N_0f) * integrating_factors_f[1]
        c = self.ifft(c_f)
        N_c = nonlinear_evolution_function_f(c, self.time + self.dt)

        field_f = field_f * integrating_factors_f[2] + N_0f * integrating_factors_f[3] \
                  + (N_a + N_b) * integrating_factors_f[4] + N_c * integrating_factors_f[5]

        field = self.ifft(field_f)

        self.time += self.dt

        return field, field_f
--- End of file: comfit\core\base_system_evolve.py ---

--- Start of file: comfit\core\base_system_get.py ---
import numpy as np
import scipy as sp

class BaseSystemGet:
    """ Get methods for the base system class"""
    def get_sym(self, tensor: np.ndarray, i: int, j: int) -> np.ndarray:
        """Gets the i,j component of a symmetric tensor saved in an array structure.
        
        Parameters
        ----------
        tensor : numpy.ndarray
            The symmetric tensor.
        i : int
            The row index.
        j : int
            The column index.
        
        Returns
        -------
        numpy.ndarray
            The i,j component of the tensor.
        """

        if self.dim == 2:
            if i == 0:
                return tensor[0] if j == 0 else tensor[1]
            elif i == 1:
                return tensor[1] if j == 0 else tensor[2]

        elif self.dim == 3:
            if i == 0:
                return tensor[0] if j == 0 else tensor[1] if j == 1 else tensor[2]
            elif i == 1:
                return tensor[1] if j == 0 else tensor[3] if j == 1 else tensor[4]
            elif i == 2:
                return tensor[2] if j == 0 else tensor[4] if j == 1 else tensor[5]

    def get_sym_tl(self, tensor: np.ndarray, i: int, j: int) -> np.ndarray:
        """Gets the i,j component of a symmetric traceless tensor saved in an array structure.

        Parameters
        ----------
        tensor : numpy.ndarray
            The symmetric traceless tensor.
        i : int
            The row index.
        j : int
            The column index.
        
        Returns
        -------
        numpy.ndarray
            The i,j component of the tensor.
        """
        if self.dim == 2:
            if i == 0:
                return tensor[0] if j == 0 else tensor[1]
            elif i == 1:
                return tensor[1] if j == 0 else -tensor[0]
            
        elif self.dim == 3:
            if i == 0:
                return tensor[0] if j == 0 else tensor[1] if j == 1 else tensor[2]
            elif i == 1:
                return tensor[1] if j == 0 else tensor[3] if j == 1 else tensor[4]
            elif i == 2:
                return tensor[2] if j == 0 else tensor[4] if j == 1 else -(tensor[0] + tensor[3])

    def get_anti_sym(self, omega: np.ndarray, i: int, j: int) -> np.ndarray:
        """Gets the i,j component of an anti-symmetric tensor saved in an array structure.

        Parameters
        ----------
        omega : numpy.ndarray
            The anti-symmetric tensor.
        i : int
            The row index.
        j : int
            The column index.
        
        Returns
        -------
        numpy.ndarray
            The i,j component of the tensor.
        """
        # TODO: I don't like that the input vector is a scalar field in 2 dimensions. (Vidar 11.03.24)
        if self.dim == 2:
            if i==j:
                return 0
            return (-1)**i *omega
        elif self.dim ==3:
            if i ==j:
                return 0
            else:
                return np.sign(j-i)*omega[i+j-1]

--- End of file: comfit\core\base_system_get.py ---

--- Start of file: comfit\core\base_system_init.py ---
import numpy as np
import scipy as sp
from comfit.tool.tool_print_in_color import tool_print_in_color
from comfit.tool.tool_configure_axis import tool_configure_axis

class BaseSystemInit:
    """ Initialization methods for the base system class."""
    def __init__(self, dim: int, **kwargs):
        """Initialize the class with the given parameters.

        Parameters
        ----------
        dim : int
            The dimension of the system. Must be 1, 2, or 3.
        kwargs : dict
            Additional keyword arguments, see 
            https://comfitlib.com/ClassBaseSystem/

        Returns
        -------
            None
        """

        if dim not in [1, 2, 3]:
            raise ValueError('Dimension must be 1, 2, or 3.')

        self.dim = dim

        # Checking what x-values were provided
        self.xlim = kwargs.get('xlim', None)
        self.xmin = kwargs.get('xmin', None)
        self.xmax = kwargs.get('xmax', None)
        self.xRes = kwargs.get('xRes', None)
        self.dx = kwargs.get('dx', None)

        self.xlim, self.xmin, self.xmax, self.xRes, self.dx = tool_configure_axis(self.dim, 'x',self.xlim, self.xmin, self.xmax, self.xRes, self.dx)

        # Checking what y-values were provided
        self.ylim = kwargs.get('ylim', None)
        self.ymin = kwargs.get('ymin', None)
        self.ymax = kwargs.get('ymax', None)
        self.yRes = kwargs.get('yRes', None)
        self.dy = kwargs.get('dy', None)

        self.ylim, self.ymin, self.ymax, self.yRes, self.dy = tool_configure_axis(self.dim, 'y',self.ylim, self.ymin, self.ymax, self.yRes, self.dy)

        # Checking what z-values were provided
        self.zlim = kwargs.get('zlim', None)
        self.zmin = kwargs.get('zmin', None)
        self.zmax = kwargs.get('zmax', None)
        self.zRes = kwargs.get('zRes', None)
        self.dz = kwargs.get('dz', None)

        self.zlim, self.zmin, self.zmax, self.zRes, self.dz = tool_configure_axis(self.dim, 'z',self.zlim, self.zmin, self.zmax, self.zRes, self.dz)

        # Minimum and maximum sizes of the domain
        self.size_x = self.xmax - self.xmin
        self.size_y = self.ymax - self.ymin if self.dim > 1 else 1
        self.size_z = self.zmax - self.zmin if self.dim > 2 else 1

        self.volume = self.size_x * self.size_y * self.size_z

        if self.dim == 1:
            self.size_min = self.size_x
            self.size_max = self.size_x
        elif self.dim == 2:
            self.size_min = np.min([self.size_x, self.size_y])
            self.size_max = np.max([self.size_x, self.size_y])
        elif self.dim == 3:
            self.size_min = np.min([self.size_x, self.size_y, self.size_z])
            self.size_max = np.max([self.size_x, self.size_y, self.size_z])
        

        #  Setting default value of time
        self.time = kwargs.get('time', 0)
        self.dt = kwargs.get('dt', 0.1)

        # Construct parameters
        self.x = np.linspace(self.xmin, self.xmax-self.dx, self.xRes)
        self.y = np.linspace(self.ymin, self.ymax-self.dy, self.yRes)
        self.z = np.linspace(self.zmin, self.zmax-self.dz, self.zRes)

        self.Res = self.xRes * self.yRes * self.zRes
        if self.dim == 1:
            self.dims = [self.xRes]
        elif self.dim == 2:
            self.dims = [self.xRes, self.yRes]
        elif self.dim == 3:
            self.dims = [self.xRes, self.yRes, self.zRes]

        self.a0 = 1  # System length scale

        # Helpful midpoints and their indices
        self.xmidi = (self.xRes) // 2 
        self.xmid = self.x[self.xmidi]

        self.ymidi = (self.yRes) // 2 
        self.ymid = self.y[self.ymidi]

        self.zmidi = (self.zRes) // 2 
        self.zmid = self.z[self.zmidi]

        self.midi = self.xRes * self.yRes * (self.zmidi - 1) + self.yRes * (self.xmidi - 1) + self.ymidi
        if self.dim == 1:
            self.rmid = self.xmid
            self.zero_index = 0 
        elif self.dim == 2:
            self.rmid = [self.xmid, self.ymid]
            self.zero_index = (0,0)
        elif self.dim == 3:
            self.rmid = [self.xmid, self.ymid, self.zmid]
            self.zero_index = (0,0,0)

        # Fourier modes
        self.k = [self.calc_wavenums(self.x)]
        if self.dim == 2:
            self.k[0] = self.k[0].reshape(self.xRes, 1)
            self.k.append(self.calc_wavenums(self.y).reshape(1, self.yRes))
        elif self.dim == 3:
            self.k[0] = self.k[0].reshape(self.xRes, 1, 1)
            self.k.append(self.calc_wavenums(self.y).reshape(1, self.yRes, 1))
            self.k.append(self.calc_wavenums(self.z).reshape(1, 1, self.zRes))

        # Reshape the position vectors
        if self.dim == 2:
            self.x = self.x.reshape((self.xRes, 1))
            self.y = self.y.reshape((1, self.yRes))
        elif self.dim == 3:
            self.x = self.x.reshape((self.xRes, 1, 1))
            self.y = self.y.reshape((1, self.yRes, 1))
            self.z = self.z.reshape((1, 1, self.zRes))


        # Derivatives
        self.dif = [1j * ki for ki in self.k]

        self.dV = self.dx
        if self.dim > 1:
            self.dV *= self.dy
        if self.dim > 2:
            self.dV *= self.dz

        self.rmin = [self.xmin, self.ymin, self.zmin]
        self.rmax = [self.xmax, self.ymax, self.zmax]


        # Plot lib
        self.plot_lib = kwargs.get('plot_lib', 'plotly')

        def __str__(self) -> str:
            """Return a string representation of the class.

            Returns
            -------
            str
                A string representation of the class including system dimensions 
                and axis properties.
            """
            description = f"BaseSystem instance\n"
            # Start with the dimension of the system
            description = f"System Dimension: {self.dim}\n"

            # Add x-axis properties
            description += f"X-Axis Limits: [{self.xmin}, {self.xmax}], Resolution: {self.xRes}, Delta: {self.dx}\n"

            # Add y-axis properties if dim > 1
            if self.dim > 1:
                description += f"Y-Axis Limits: [{self.ymin}, {self.ymax}], Resolution: {self.yRes}, Delta: {self.dy}\n"

            # Add z-axis properties if dim > 2
            if self.dim > 2:
                description += f"Z-Axis Limits: [{self.zmin}, {self.zmax}], Resolution: {self.zRes}, Delta: {self.dz}\n"

            # Add time properties
            description += f"Current Time: {self.time}, Time Step: {self.dt}"

            return description


--- End of file: comfit\core\base_system_init.py ---

--- Start of file: comfit\core\base_system_plot.py ---
from typing import Union, Optional, Literal, Tuple, Dict, List, Any, TYPE_CHECKING


import numpy as np
import scipy as sp

from comfit.tool import tool_colormap
from comfit.tool import tool_create_orthonormal_triad
from comfit.tool import tool_set_plot_axis_properties_matplotlib
from comfit.tool import tool_complete_field
from comfit.tool import tool_print_in_color
from comfit.tool import tool_matplotlib_define_3D_plot_ax
from comfit.tool import tool_plotly_define_3D_plot_ax

from comfit.plot import plot_surface_matplotlib
from comfit.plot import plot_field_matplotlib
from comfit.plot import plot_field_plotly
from comfit.plot import plot_complex_field_matplotlib
from comfit.plot import plot_complex_field_plotly
from comfit.plot import plot_angle_field_matplotlib
from comfit.plot import plot_angle_field_plotly
from comfit.plot import plot_vector_field_matplotlib
from comfit.plot import plot_vector_field_plotly
from comfit.plot import plot_field_in_plane_matplotlib
from comfit.plot import plot_field_in_plane_plotly
from comfit.plot import plot_complex_field_in_plane_matplotlib
from comfit.plot import plot_complex_field_in_plane_plotly
from comfit.plot import plot_nodes_matplotlib
from comfit.plot import plot_nodes_plotly
from comfit.plot import plot_vector_field_in_plane_both_plot_libs

from comfit.plot import plot_subplots_matplotlib
from comfit.plot import plot_subplots_plotly

import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
import matplotlib.tri as mtri
import matplotlib.cm as cm
import matplotlib.axes
import matplotlib.figure

import mpl_toolkits

import plotly.graph_objects as go
import plotly.figure_factory as ff
import plotly.colors as pc

from skimage.measure import marching_cubes

import time

class BaseSystemPlot:
    """Plotting methods for the base system class"""

    def plot_prepare(
        self: 'BaseSystemPlot', 
        field: np.ndarray, 
        field_type: Literal['real', 'complex', 'angle', 'vector'], 
        **kwargs: any
        ) -> Tuple[np.ndarray, Union[go.Figure, plt.Figure], Any, Dict]:
        """Prepare axis and figure for plotting.

        Parameters
        ----------
        field : np.ndarray
            Field to be plotted.
        field_type : str
            Type of the field to be plotted.

        Returns
        -------
        Tuple[np.ndarray, Union[go.Figure, plt.Figure], Any, Dict]
            Tuple containing the field, figure (plotly or matplotlib), 
            axis (plotly or matplotlib) and keyword arguments for plotting.
        """

        plot_lib = kwargs.get('plot_lib', self.plot_lib)
        
        ## Define figure
        if plot_lib == "plotly":
            fig = kwargs.get('fig', go.Figure())
            ax = kwargs.get('ax', {'row': 1, 'col': 1, 'nrows': 1, 'ncols': 1, 'colorbar': False})

        elif plot_lib == "matplotlib":
            fig = kwargs['fig'] if 'fig' in kwargs else plt.figure()
            ax = kwargs.get('ax', None)

        # Extend field if not a complete array is given
        if field_type in ['real', 'complex', 'angle']:
            field = tool_complete_field(self, field)
        elif field_type == 'vector':
            field_copy = []
            for n in range(len(field)):
                field_copy.append(tool_complete_field(self, field[n]))
            field = np.array(field_copy)

        ## Checks on field
        # Check if the provided field is bool
        if field.dtype == bool:
            field = field.astype(float)

        # Check if the field is nan
        kwargs['field_is_nan'] = False
        if np.all(np.isnan(field)):
            kwargs['field_is_nan'] = True

        # Check if the field is an order parameter containing several components
        if field_type in ['real', 'complex', 'angle']:
            if field.ndim == self.dim+1:
                tool_print_in_color('Warning: The provided field seems to be an order parameter containing several fields. Only the zeroth component will be plotted.')
                field = field[0]

        # Check if the field is complex when it should be real
        if field_type in ['real', 'vector', 'angle']:
            if np.iscomplexobj(field):
                tool_print_in_color("Warning: the provided field was complex. This might be due to residual imaginary parts from the Fourier transform. The imaginary parts will be removed.")
                print('Max imaginary part: ', np.max(np.imag(field)))
                field = np.real(field)

        ## Define default kwarg values
        kwargs['colormap'] = kwargs.get('colormap', 'viridis')
        kwargs['colormap_object'] = tool_colormap(kwargs['colormap'], plot_lib=plot_lib)

        colorbar_default = False
        if field_type == 'complex':
            colorbar_default = True
        if field_type in ['real','angle'] and self.dim>1:
            colorbar_default = True
        if field_type == 'vector' and plot_lib == 'plotly':
            colorbar_default = True
        kwargs['colorbar'] = kwargs.get('colorbar',  colorbar_default)

        kwargs['vlim_symmetric'] = kwargs.get('vlim_symmetric', False)

        grid_default = False
        if field_type == 'real' and self.dim in [1,3]:
            grid_default = True
        if field_type == 'complex':
            grid_default = True
        kwargs['grid'] = kwargs.get('grid', grid_default)

        axis_equal_default = False
        if self.dim in [2,3]:
            axis_equal_default = True
        kwargs['axis_equal'] = kwargs.get('axis_equal', axis_equal_default)

        kwargs['plot_is_3D'] = True if self.dim == 3 else False

        if field_type == 'real':
            # Field limits
            field_min = np.min(field)
            field_max = np.max(field)

            if 'vlim' in kwargs:
                vlim = kwargs['vlim']
                vmin = vlim[0]
                vmax = vlim[1]
            else:
                vmin = field_min
                vmax = field_max
                if 'vlim_symmetric' in kwargs:
                    if kwargs['vlim_symmetric']:
                        vmax = max(abs(vmin), abs(vmax))
                        vmin = -vmax
            
            if plot_lib == 'plotly':
                ax['vmin'] = min(vmin, ax.get('vmin', vmin)) 
                ax['vmax'] = max(vmax, ax.get('vmax', vmax))

            else:
                kwargs['vmin'] = vmin
                kwargs['vmax'] = vmax

        return field, fig, ax, kwargs
    
    def _check_if_fourier_and_adjust(self, field, **kwargs):
        """Check if the field is in Fourier space and adjust it if necessary.

        Parameters
        ----------
        field : np.ndarray
            Field to be checked
            kwargs : Any
        
        Returns
        -------
        Tuple[np.ndarray, Dict]
            Tuple containing the field and the keyword arguments.
        """

        kwargs["fourier"] = kwargs.get("fourier", False)
        if kwargs["fourier"]:
            
            dkx = self.k[0][1]-self.k[0][0]
            phase_shift = 1/(self.xRes*dkx)*np.exp(1j*self.k[0]*self.xmin)
            if self.dim > 1:
                dky = self.k[1][0,1]-self.k[1][0,0]
                phase_shift = phase_shift*1/(self.yRes*dky)*np.exp(1j*self.k[1]*self.ymin)
            if self.dim > 2:
                dkz = self.k[2][0,0,1]-self.k[2][0,0,0]
                phase_shift = phase_shift*1/(self.zRes*dkz)*np.exp(1j*self.k[2]*self.zmin)

            field = np.fft.fftshift(phase_shift*field, axes=range(-self.dim, 0))

            kwargs["x"] = np.fft.fftshift(self.k[0])/(1/self.a0)
            kwargs['xlabel'] = 'kx/(a₀⁻¹)'
            kwargs['xlim'] = kwargs.get('xlim', [np.min(kwargs["x"]), np.max(kwargs["x"])])

            if self.dim > 1:
                kwargs["y"] = np.fft.fftshift(self.k[1])/(1/self.a0)
                kwargs['ylabel'] = 'ky/(a₀⁻¹)'
                kwargs['ylim'] = kwargs.get('ylim', [np.min(kwargs["y"]), np.max(kwargs["y"])])

            if self.dim > 2:
                kwargs["z"] = np.fft.fftshift(self.k[2])/(1/self.a0)
                kwargs['zlabel'] = 'kz/(a₀⁻¹)'
                kwargs['zlim'] = kwargs.get('zlim', [np.min(kwargs["z"]), np.max(kwargs["z"])])

            


        else:

            kwargs['x'] = self.x/self.a0
            kwargs['xlabel'] = kwargs.get('xlabel','x/a₀')
            
            if self.dim > 1:
                kwargs['y'] = self.y/self.a0
                kwargs['ylabel'] = kwargs.get('ylabel','y/a₀')
            if self.dim > 2:
                kwargs['z'] = self.z/self.a0
                kwargs['zlabel'] = kwargs.get('zlabel','z/a₀')

        return field, kwargs

    def plot_field(
            self: 'BaseSystemPlot', 
            field: np.ndarray, 
            **kwargs: Any
            ) -> Tuple[Union[go.Figure, plt.Figure], Any]:
        """Plot a field.

        Parameters
        ----------
        field : np.ndarray
            Field to be plotted.
        kwargs : Any
            Keyword arguments for the plot. See https://comfitlib.com/ClassBaseSystem/ 
            for a full list of keyword arguments.

        Returns
        -------
        Tuple[Union[go.Figure, plt.Figure], Any]
            Tuple containing the figure (plotly or matplotlib) and the axes 
            dictionary (plotly or matplotlib).

        Note
        ----
        plot_lib is a possible keyword argument. If not provided, the default 
        plotting library (plotly or matplotlib) will be used.
        See the corresponding plot_field_plotly or plot_field_matplotlib function
        in the Auxiliary Plot Functions documentation for further details.
        """

        plot_lib = kwargs.get('plot_lib', self.plot_lib)

        field, kwargs = self._check_if_fourier_and_adjust(field, **kwargs)  

        if plot_lib == "plotly":
            return plot_field_plotly(self, field, **kwargs)
        elif plot_lib == "matplotlib":
            return plot_field_matplotlib(self, field, **kwargs)

    def plot_complex_field(
            self: 'BaseSystemPlot', 
            complex_field: np.ndarray, 
            **kwargs: Any
            ) -> Tuple[Union[go.Figure, plt.Figure], Any]:
        """Plot a complex field.

        Parameters
        ----------
        complex_field : np.ndarray
            Complex field to be plotted.
        kwargs : Any
            Keyword arguments for the plot. See https://comfitlib.com/ClassBaseSystem/
            for a full list of keyword arguments.
        
        Returns
        -------
        Tuple[Union[go.Figure, plt.Figure], Any]
            Tuple containing the figure (plotly or matplotlib) and the axes
            dictionary (plotly or matplotlib).
        
        Note
        ----
        plot_lib is a possible keyword argument. If not provided, the default
        plotting library (plotly or matplotlib) will be used.
        See the corresponding plot_complex_field_plotly or plot_complex_field_matplotlib function
        in the Auxiliary Plot Functions documentation for further details.
        """

        plot_lib = kwargs.get('plot_lib', self.plot_lib)

        complex_field, kwargs = self._check_if_fourier_and_adjust(complex_field, **kwargs)  

        if plot_lib == "plotly":
            return plot_complex_field_plotly(self, complex_field, **kwargs)
        elif plot_lib == "matplotlib":
            return plot_complex_field_matplotlib(self, complex_field, **kwargs)


    def plot_angle_field(
            self: 'BaseSystemPlot', 
            angle_field: np.ndarray, 
            **kwargs: Any
            ) -> Tuple[Union[go.Figure, plt.Figure], Any]:
        """Plot an angle field.

        Parameters
        ----------
        angle_field : np.ndarray
            Angle field to be plotted.
        kwargs : Any
            Keyword arguments for the plot. See https://comfitlib.com/ClassBaseSystem/
            for a full list of keyword arguments.
        
        Returns
        -------
        Tuple[Union[go.Figure, plt.Figure], Any]
            Tuple containing the figure (plotly or matplotlib) and the axes
            dictionary (plotly or matplotlib).

        Note
        ----
        plot_lib is a possible keyword argument. If not provided, the default
        plotting library (plotly or matplotlib) will be used.
        See the corresponding plot_angle_field_plotly or plot_angle_field_matplotlib function
        in the Auxiliary Plot Functions documentation for further details.
        """

        plot_lib = kwargs.get('plot_lib', self.plot_lib)

        angle_field, kwargs = self._check_if_fourier_and_adjust(angle_field, **kwargs)
        if kwargs['fourier']:
            raise NotImplementedError("Fourier space angle field plotting not implemented.")

        if plot_lib == "plotly":
            return plot_angle_field_plotly(self, angle_field, **kwargs)
        elif plot_lib == "matplotlib":
            return plot_angle_field_matplotlib(self, angle_field, **kwargs)


    def plot_vector_field(
            self: 'BaseSystemPlot', 
            vector_field: np.ndarray, 
            **kwargs: Any
            ) -> Tuple[Union[go.Figure, plt.Figure], Any]:
        """Plot a vector field.

        Parameters
        ----------
        vector_field : np.ndarray
            Vector field to be plotted.
        kwargs : Any
            Keyword arguments for the plot. See https://comfitlib.com/ClassBaseSystem/
            for a full list of keyword arguments.
        
        Returns
        -------
        Tuple[Union[go.Figure, plt.Figure], Any]
            Tuple containing the figure (plotly or matplotlib) and the axes
            dictionary (plotly or matplotlib).

        Note
        ----
        plot_lib is a possible keyword argument. If not provided, the default
        plotting library (plotly or matplotlib) will be used.
        See the corresponding plot_vector_field_plotly or plot_vector_field_matplotlib function
        in the Auxiliary Plot Functions documentation for further details.
        """

        plot_lib = kwargs.get('plot_lib', self.plot_lib)

        vector_field, kwargs = self._check_if_fourier_and_adjust(vector_field, **kwargs)
        if kwargs['fourier']:
            raise NotImplementedError("Fourier space vector field plotting not implemented.")

        if plot_lib == "plotly":
            return plot_vector_field_plotly(self, vector_field, **kwargs)
        elif plot_lib == "matplotlib":
            return plot_vector_field_matplotlib(self, vector_field, **kwargs)

    def plot_field_in_plane(
        self: 'BaseSystemPlot',
        field: np.ndarray,
        normal_vector: Optional[np.ndarray] = None,
        position: Optional[np.ndarray] = None,
        **kwargs: Any
        ) -> Tuple[Union[go.Figure, plt.Figure], Any]:
        """Plot the field in a plane.

        Parameters
        ----------
        field : np.ndarray
            Field to be plotted.
        normal_vector : np.ndarray, optional
            Normal vector of the plane. If None, the normal vector will be calculated.
        position : np.ndarray, optional
            Position of the plane. If None, the position will be calculated.
        kwargs : Any
            Keyword arguments for the plot. See https://comfitlib.com/ClassBaseSystem/
            for a full list of keyword arguments.
        
        Returns
        -------
        Tuple[Union[go.Figure, plt.Figure], Any]
            Tuple containing the figure (plotly or matplotlib) and the axes
            dictionary (plotly or matplotlib).

        Note
        ----
        plot_lib is a possible keyword argument. If not provided, the default
        plotting library (plotly or matplotlib) will be used.
        See the corresponding plot_field_in_plane_plotly or plot_field_in_plane_matplotlib function
        in the Auxiliary Plot Functions documentation for further details.
        """

        plot_lib = kwargs.get('plot_lib', self.plot_lib)

        field, kwargs = self._check_if_fourier_and_adjust(field, **kwargs)
        if kwargs['fourier']:
            raise NotImplementedError("Fourier space plot in plane not implemented.")

        if plot_lib == "plotly":
            return plot_field_in_plane_plotly(
                self, field, normal_vector, position, **kwargs
            )
        elif plot_lib == "matplotlib":
            return plot_field_in_plane_matplotlib(
                self, field, normal_vector, position, **kwargs
            )

    def plot_complex_field_in_plane(
        self: 'BaseSystemPlot',
        complex_field: np.ndarray,
        normal_vector: Optional[np.ndarray] = None,
        position: Optional[np.ndarray] = None,
        **kwargs: Any
        ) -> Tuple[Union[go.Figure, plt.Figure], Any]:
        """Plot the complex field in a plane.

        Parameters
        ----------
        complex_field : np.ndarray
            Complex field to be plotted.
        normal_vector : np.ndarray, optional
            Normal vector of the plane. If None, the normal vector will be calculated.
        position : np.ndarray, optional
            Position of the plane. If None, the position will be calculated.
        kwargs : Any
            Keyword arguments for the plot. See https://comfitlib.com/ClassBaseSystem/
            for a full list of keyword arguments.

        Returns
        -------
        Tuple[Union[go.Figure, plt.Figure], Any]
            Tuple containing the figure (plotly or matplotlib) and the axes
            dictionary (plotly or matplotlib).

        Note
        ----
        plot_lib is a possible keyword argument. If not provided, the default
        plotting library (plotly or matplotlib) will be used.
        See the corresponding plot_complex_field_in_plane_plotly or plot_complex_field_in_plane_matplotlib function
        in the Auxiliary Plot Functions documentation for further details.
        """

        plot_lib = kwargs.get('plot_lib', self.plot_lib)

        complex_field, kwargs = self._check_if_fourier_and_adjust(complex_field, **kwargs)
        if kwargs['fourier']:
            raise NotImplementedError("Fourier space complex field plot in plane not implemented.")


        if plot_lib == "plotly":
            return plot_complex_field_in_plane_plotly(
                self, complex_field, normal_vector, position, **kwargs
            )
        elif plot_lib == "matplotlib":
            return plot_complex_field_in_plane_matplotlib(
                self, complex_field, normal_vector, position, **kwargs
            )

    def plot_angle_field_in_plane(
        self: 'BaseSystemPlot',
        angle_field: np.ndarray,
        normal_vector: Optional[np.ndarray] = None,
        position: Optional[np.ndarray] = None,
        **kwargs: Any
        ) -> Tuple[Union[go.Figure, plt.Figure], Any]:
        """Plot the angle field in a plane.

        Parameters
        ----------
        angle_field : np.ndarray
            Angle field to be plotted.
        normal_vector : np.ndarray, optional
            Normal vector of the plane. If None, the normal vector will be calculated.
        position : np.ndarray, optional
            Position of the plane. If None, the position will be calculated.
        kwargs : Any
            Keyword arguments for the plot. See https://comfitlib.com/ClassBaseSystem/
            for a full list of keyword arguments.
        
        Returns
        -------
        Tuple[Union[go.Figure, plt.Figure], Any]
            Tuple containing the figure (plotly or matplotlib) and the axes
            dictionary (plotly or matplotlib).

        Note
        ----
        plot_lib is a possible keyword argument. If not provided, the default
        plotting library (plotly or matplotlib) will be used.
        See the corresponding plot_angle_field_plotly or plot_angle_field_matplotlib function
        in the Auxiliary Plot Functions documentation for further details.
        """

        plot_lib = kwargs.get('plot_lib', self.plot_lib)

        angle_field, kwargs = self._check_if_fourier_and_adjust(angle_field, **kwargs)
        if kwargs['fourier']:
            raise NotImplementedError("Fourier space angle field plot in plane not implemented.")


        complex_field = np.exp(1j * angle_field)
        return self.plot_complex_field_in_plane(complex_field, normal_vector=normal_vector, position=position, **kwargs)

    def plot_vector_field_in_plane(
        self: 'BaseSystemPlot',
        vector_field: np.ndarray,
        normal_vector: Optional[np.ndarray] = None,
        position: Optional[np.ndarray] = None,
        spacing = None,
        **kwargs: Any
        ) -> Tuple[Union[go.Figure, plt.Figure], Any]:
        """Plot the vector field in a plane.

        Parameters
        ----------
        vector_field : np.ndarray
            Vector field to be plotted.
        normal_vector : np.ndarray, optional
            Normal vector of the plane. If None, the normal vector will be calculated.
        position : np.ndarray, optional
            Position of the plane. If None, the position will be calculated.
        spacing : float, optional
            Spacing between the vectors.
        kwargs : Any
            Keyword arguments for the plot. See https://comfitlib.com/ClassBaseSystem/
            for a full list of keyword arguments.
        
        Returns
        -------
        Tuple[Union[go.Figure, plt.Figure], Any]
            Tuple containing the figure (plotly or matplotlib) and the axes
            dictionary (plotly or matplotlib).

        Note
        ----
        plot_lib is a possible keyword argument. If not provided, the default
        plotting library (plotly or matplotlib) will be used.
        See the plot_vector_field_both_plot_libs function
        in the Auxiliary Plot Functions documentation for further details.
        """

        plot_lib = kwargs.get('plot_lib', self.plot_lib)

        vector_field, kwargs = self._check_if_fourier_and_adjust(vector_field, **kwargs)
        if kwargs['fourier']:
            raise NotImplementedError("Fourier space vector field plot in plane not implemented.")


        return plot_vector_field_in_plane_both_plot_libs(self, vector_field, normal_vector, position, spacing, **kwargs)

    def plot_nodes(
            self: 'BaseSystemPlot', 
            nodes: Dict[str, Any], 
            **kwargs: Any
            ) ->  Tuple[Union[go.Figure, plt.Figure], Any]:
        """Plot nodes.

        Parameters
        ----------
        nodes : np.ndarray
            Nodes to be plotted.
        kwargs : Any
            Keyword arguments for the plot. See https://comfitlib.com/ClassBaseSystem/
            for a full list of keyword arguments.
        
        Returns
        -------
        Tuple[Union[go.Figure, plt.Figure], Any]
            Tuple containing the figure (plotly or matplotlib) and the axes
            dictionary (plotly or matplotlib).
        
        Note
        ----
        plot_lib is a possible keyword argument. If not provided, the default
        plotting library (plotly or matplotlib) will be used.
        See the corresponding plot_nodes_plotly or plot_nodes_matplotlib function
        in the Auxiliary Plot Functions documentation for further details.
        """

        plot_lib = kwargs.get('plot_lib', self.plot_lib)

        if kwargs.get('fourier', False):
            raise NotImplementedError("Fourier space node does not make sense.")

        if plot_lib == 'plotly':
            return plot_nodes_plotly(self, nodes, **kwargs)
        elif plot_lib == 'matplotlib':
            return plot_nodes_matplotlib(self, nodes, **kwargs)


    # Figure handling methods
    def plot_subplots(
            self: 'BaseSystemPlot', 
            number_of_rows: int, 
            number_of_columns: int, 
            **kwargs: Any
            ) -> Tuple[Union[go.Figure, plt.Figure], Any]:
        """Plot subplots.

        Parameters
        ----------
        number_of_rows : int
            Number of rows in the subplot.
        number_of_columns : int
            Number of columns in the subplot.
        
        Returns
        -------
        Tuple[Union[go.Figure, plt.Figure], Any]
            Tuple containing the figure (plotly or matplotlib) and the axes
            dictionary (plotly or matplotlib).
        """

        plot_lib = kwargs.get('plot_lib', self.plot_lib)

        if plot_lib == "plotly":
            return plot_subplots_plotly(number_of_rows, number_of_columns)
        elif plot_lib == "matplotlib":
            return plot_subplots_matplotlib(number_of_rows, number_of_columns, **kwargs)

    def plot_save(
        self: 'BaseSystemPlot', 
        fig: Union[plt.Figure, go.Figure], 
        counter: Optional[int] = None, 
        **kwargs: Any
        ) -> None:
        """Save a figure.

        Parameters
        ----------
        fig : Union[plt.Figure, go.Figure]
            Figure to be saved.
        counter : int, optional
            Counter for the figure. If None, the figure will be saved as 'plot.png'.
        kwargs : Any
            Optional arguments: ID, (matplotlib:) image_size_inches, dpi. 
            (plotly:) width, height.
        
        Returns
        -------
        None
            Save the figure. 
        """

        # Check if the figure is the first argument (deprecated)
        if isinstance(fig, int):
            tool_print_in_color("Warning: The plot_save method has been called with the figure as the second argument. This is deprecated. Please call the method with the figure as the first argument, then counter.")
            counter_tmp = fig
            fig = counter
            counter = counter_tmp
        
        # Get ID
        ID=kwargs.get('ID', None)

        # Keyword arguments
        image_size_inches=kwargs.get('image_size_inches', (6,5))
        dpi=kwargs.get('dpi', 100)

        # Set filename
        if counter is None:
            if ID is None:
                filename = 'plot.png'
            else:
                filename = f'plot_{ID}.png'
        else:
            if ID is None:
                filename = f'plot_{counter}.png'
            else:
                filename = f'plot_{counter}_{ID}.png'


        # Save the figure
        # Determine the plotting library based on figure type
        if isinstance(fig, plt.Figure):
            plot_lib = "matplotlib"
        elif isinstance(fig, go.Figure):
            plot_lib = "plotly"
        else:
            plot_lib = self.plot_lib

        if plot_lib == "plotly":
            width=kwargs.get('width', 800)
            height=kwargs.get('height', 600)
            fig.write_image(filename, width=width, height=height)

        elif plot_lib == "matplotlib":
            fig.set_size_inches(image_size_inches)
            fig.savefig(filename, dpi=dpi)
            plt.close(fig)


    def show(
            self: 'BaseSystemPlot', 
            fig: Union[plt.Figure, go.Figure]
            ) -> None:
        """Show a figure.

        Parameters
        ----------
        fig : Union[plt.Figure, go.Figure]
            Figure to be shown.
        
        Returns
        -------
        None
            Show the figure.
        """

        plot_lib = "plotly" if isinstance(fig, go.Figure) else "matplotlib"

        if plot_lib == "matplotlib":
            plt.show()
        elif plot_lib == "plotly":
            fig.show()
--- End of file: comfit\core\base_system_plot.py ---

--- Start of file: comfit\core\__init__.py ---
from .base_system import BaseSystem

--- End of file: comfit\core\__init__.py ---

--- Start of file: comfit\plot\plot_angle_field_matplotlib.py ---
# Typing imports
from typing import TYPE_CHECKING, Any, Tuple
if TYPE_CHECKING:
    from comfit.core.base_system import BaseSystem

# General packages
import numpy as np
import matplotlib
import matplotlib.pyplot as plt

# Comfit packages
from comfit.plot import plot_field_matplotlib, plot_complex_field_matplotlib
from comfit.tool import tool_complete_field

def plot_angle_field_matplotlib(
        self: 'BaseSystem',
        angle_field: np.ndarray,
        **kwargs: Any
        ) -> Tuple[matplotlib.figure.Figure, matplotlib.axes.Axes]:
    """Plot an angle field using matplotlib.

    Parameters
    ----------
    self : BaseSystem
        A BaseSystem (or derived) instance.
    angle_field : np.ndarray
        The angle field values in radians.
    kwargs : Any
        Keyword arguments for the plot, see https://comfitlib.com/Plotting/.

    Returns
    -------
    tuple[matplotlib.figure.Figure, matplotlib.axes.Axes]
        The figure and axes objects containing the plot.
    """

    # Normalize around 0
    angle_field = np.mod(angle_field + np.pi, 2 * np.pi) - np.pi        

    if self.dim == 1:
        if 'vlim' in kwargs:
            vlim = kwargs['vlim']
        else:
            kwargs['vlim'] = [-np.pi, np.pi]
            kwargs['yticks'] = [-np.pi, -2 * np.pi / 3, -np.pi / 3, 0, np.pi / 3, 2 * np.pi / 3, np.pi]
            kwargs['yticklabels'] = [r'$-\pi$', r'$-2\pi/3$', r'$-\pi/3$', r'$0$', r'$\pi/3$', r'$2\pi/3$', r'$\pi$']

        
        return plot_field_matplotlib(self, angle_field, **kwargs)
    
    elif self.dim > 1:
        complex_field = np.exp(1j * angle_field)

        kwargs['plot_method'] = 'phase_angle'

        return plot_complex_field_matplotlib(self, complex_field, **kwargs)
--- End of file: comfit\plot\plot_angle_field_matplotlib.py ---

--- Start of file: comfit\plot\plot_angle_field_plotly.py ---
# Typing imports
from typing import TYPE_CHECKING, Any, Tuple, Dict
if TYPE_CHECKING:
    from comfit.core.base_system import BaseSystem

# General packages
import numpy as np
import plotly.graph_objects as go

# Comfit packages
from comfit.tool import tool_complete_field
from comfit.plot import plot_field_plotly, plot_complex_field_plotly

def plot_angle_field_plotly(
        self: 'BaseSystem',
        angle_field: np.ndarray,
        **kwargs: Any
        ) -> Tuple[go.Figure, dict]:
    """Plot the angle field using plotly.

    Parameters
    ----------
    self : BaseSystem
        A BaseSystem (or derived) instance.
    angle_field : np.ndarray
        The angle field values to plot.
    kwargs : Any
        Keyword arguments for the plot, see https://comfitlib.com/Plotting/.

    Returns
    -------
    Any
        The plotly figure object.
    """

    # Normalize around 0
    angle_field = np.mod(angle_field + np.pi, 2 * np.pi) - np.pi        

    if self.dim == 1:
        if 'vlim' in kwargs:
            vlim = kwargs['vlim']
        else:
            kwargs['vlim'] = [-np.pi, np.pi]
            kwargs['yticks'] = [-np.pi, -2 * np.pi / 3, -np.pi / 3, 0, np.pi / 3, 2 * np.pi / 3, np.pi]
            kwargs['yticklabels'] = [r'$-\pi$', r'$-2\pi/3$', r'$-\pi/3$', r'$0$', r'$\pi/3$', r'$2\pi/3$', r'$\pi$']

        
        return plot_field_plotly(self, angle_field, **kwargs)
    
    elif self.dim > 1:
        complex_field = np.exp(1j * angle_field)

        kwargs['plot_method'] = 'phase_angle'

        return plot_complex_field_plotly(self, complex_field, **kwargs)
--- End of file: comfit\plot\plot_angle_field_plotly.py ---

--- Start of file: comfit\plot\plot_complex_field_in_plane_matplotlib.py ---
# Typing imports
from typing import TYPE_CHECKING, Optional, Any, Tuple
if TYPE_CHECKING:
    from comfit.core.base_system import BaseSystem

# General packages
import numpy as np
import matplotlib.pyplot as plt
import scipy as sp
from matplotlib.figure import Figure
from matplotlib.axes import Axes
from skimage.measure import marching_cubes

# Comfit packages
from comfit.tool import tool_complete_field, \
                        tool_set_plot_axis_properties_matplotlib, \
                        tool_colormap, \
                        tool_matplotlib_define_2D_plot_ax, \
                        tool_matplotlib_define_3D_plot_ax

def plot_complex_field_in_plane_matplotlib(
        self: 'BaseSystem',
        complex_field: np.ndarray,
        normal_vector: Optional[np.ndarray] = None,
        position: Optional[np.ndarray] = None,
        **kwargs: Any
        ) -> Tuple[Figure, Axes]:
    """Plot the complex field in a plane perpendicular to the given normal vector.

    Parameters
    ----------
    self : BaseSystem
        A BaseSystem (or derived) instance.
    complex_field : np.ndarray
        The complex field to be plotted.
    normal_vector : np.ndarray, optional
        The normal vector of the plane. Defaults to [0,1,0].
    position : np.ndarray, optional
        The position of the plane. Defaults to the middle of the system.
    kwargs : Any
        Keyword arguments for the plot, see https://comfitlib.com/Plotting/.

    Returns
    -------
    tuple[Figure, Axes]
        The figure and axes containing the plot.

    Raises
    ------
    Exception
        If the field dimension is not 3D.
    """


    if self.dim != 3:
        raise Exception("The plot in plane function is only defined for 3D fields.")

    complex_field, fig, ax, kwargs = self.plot_prepare(complex_field, field_type = 'complex', **kwargs)

    ax = tool_matplotlib_define_3D_plot_ax(fig, ax)

    kwargs['plot_is_3D'] = True

    # Default values of position and normal vector
    if position is None:
        position = self.rmid

    if normal_vector is None:
        normal_vector = [0,1,0]

    # Calculate the magnitude and phase of the complex field
    rho = np.abs(complex_field)
    theta = np.angle(complex_field)

    normal_vector = np.array(normal_vector)/np.linalg.norm(normal_vector)
    height_above_plane = (self.x-position[0])*normal_vector[0] + (self.y-position[1])*normal_vector[1] + (self.z-position[2])*normal_vector[2]

    verts, faces, _, _ = marching_cubes(height_above_plane, 0)

    # Calculate the centroids of each triangle
    centroids = np.mean(verts[faces], axis=1)

    # Assuming field is defined on the same grid as height_above_plane
    x, y, z = np.mgrid[0:height_above_plane.shape[0], 0:height_above_plane.shape[1], 0:height_above_plane.shape[2]]

    # Flatten the grid for interpolation
    points = np.c_[x.ravel(), y.ravel(), z.ravel()]
    theta_values = theta.ravel()

    # Interpolate field at the vertices positions
    theta_verts = sp.interpolate.griddata(points, theta_values, centroids, method='nearest')
    rho_verts = sp.interpolate.griddata(points, rho.ravel(), centroids, method='nearest')

    # Normalize field values for color mapping
    theta_normalized = (theta_verts+np.pi) / (2*np.pi)

    # Map normalized field values to colors
    colormap = kwargs['colormap_object']
    colors = colormap(theta_normalized)

    # Blend the colors with white according to rho (normalized)
    colors[:,3] = (rho_verts/np.max(rho_verts)).ravel()

    # Extract coordinates
    x = kwargs.get('x', self.x/self.a0).flatten()
    dx = x[1] - x[0]

    y = kwargs.get('y', self.y/self.a0).flatten()
    dy = y[1] - y[0]

    z = kwargs.get('z', self.z/self.a0).flatten()
    dz = z[1] - z[0]

    ax.plot_trisurf((x[0]+verts[:, 0]*dx),
                    (y[0]+verts[:, 1]*dy),
                    faces,
                    (z[0]+verts[:, 2]*dz),
                    facecolor=colors, antialiased=True)


    # Create a colorbar
    if kwargs['colorbar']:
        padding=0.2
        mappable = plt.cm.ScalarMappable(cmap=kwargs['colormap_object'])
        mappable.set_array([])
        mappable.set_clim(-np.pi, np.pi)
        cbar = plt.colorbar(mappable, ax=ax, pad=padding)

        cticks = kwargs.get('cticks', [-np.pi, -2*np.pi/3, -np.pi/3, 0, np.pi/3, 2*np.pi/3, np.pi])
        cbar.set_ticks(cticks)

        cticklabelse = kwargs.get('cticklabels', [r'$-\pi$', r'$-2\pi/3$', r'$-\pi/3$', r'$0$', r'$\pi/3$', r'$2\pi/3$', r'$\pi$'])
        cbar.set_ticklabels(cticklabelse)

    kwargs['grid'] = kwargs.get('grid', True)
    kwargs['ax'] = ax
    tool_set_plot_axis_properties_matplotlib(self, **kwargs)

    return fig, ax
--- End of file: comfit\plot\plot_complex_field_in_plane_matplotlib.py ---

--- Start of file: comfit\plot\plot_complex_field_in_plane_plotly.py ---
# Typing imports
from typing import TYPE_CHECKING, Optional, Any
if TYPE_CHECKING:
    from comfit.core.base_system import BaseSystem

# General packages
import numpy as np
import scipy as sp
import matplotlib.pyplot as plt
import plotly.graph_objects as go
from skimage.measure import marching_cubes

# Local application imports
from comfit.tool import tool_complete_field,\
                        tool_colormap, \
                        tool_set_plot_axis_properties_plotly, \
                        tool_plotly_define_3D_plot_ax, \
                        tool_plotly_colorbar

def plot_complex_field_in_plane_plotly(
        self: 'BaseSystem',
        complex_field: np.ndarray,
        normal_vector: Optional[np.ndarray] = None,
        position: Optional[np.ndarray] = None,
        **kwargs: Any
        ) -> tuple[go.Figure, dict]:
    """Plot the complex field in a plane perpendicular to the given normal vector.

    Parameters
    ----------
    self : BaseSystem
        A BaseSystem (or derived) instance.
    complex_field : np.ndarray
        The complex field to be plotted.
    normal_vector : np.ndarray, optional
        The normal vector of the plane. Defaults to [0,1,0].
    position : np.ndarray, optional
        The position of the plane. Defaults to the middle of the system.
    kwargs : Any
        Keyword arguments for the plot, see https://comfitlib.com/Plotting/.

    Returns
    -------
    tuple[go.Figure, dict]
        The figure and axes dictionary containing the plot of the complex field.

    Raises
    ------
    Exception
        If the dimension of the system is not 3.
    """

    if self.dim != 3:
        raise Exception("The plot in plane function is only defined for 3D fields.")

    kwargs['colormap'] = kwargs.get('colormap', 'angle') # Override the default colormap with 'angle'
    complex_field, fig, ax, kwargs = self.plot_prepare(complex_field, field_type = 'complex', **kwargs)

    ax = tool_plotly_define_3D_plot_ax(fig, ax) #Defines sceneN, plot_dimension

    # Default values of position and normal vector
    if position is None:
        position = self.rmid

    if normal_vector is None:
        normal_vector = [0,1,0]

    # Calculate the magnitude and phase of the complex field
    rho = np.abs(complex_field)
    theta = np.angle(complex_field)

    reals = np.real(complex_field)
    imags = np.imag(complex_field)

    # Kewyord arguments
    normal_vector = np.array(normal_vector)/np.linalg.norm(normal_vector)
    height_above_plane = (self.x-position[0])*normal_vector[0] + (self.y-position[1])*normal_vector[1] + (self.z-position[2])*normal_vector[2]

    verts, faces, _, _ = marching_cubes(height_above_plane, 0)

    # Calculate the centroids of each triangle
    centroids = np.mean(verts[faces], axis=1)

    # Assuming field is defined on the same grid as height_above_plane
    x, y, z = np.mgrid[0:height_above_plane.shape[0], 0:height_above_plane.shape[1], 0:height_above_plane.shape[2]]

    # Flatten the grid for interpolation
    points = np.c_[x.ravel(), y.ravel(), z.ravel()]
    theta_values = theta.ravel()
    rho_values = rho.ravel()

    # Interpolate field at the vertices positions
    # theta_verts = sp.interpolate.griddata(points, theta_values, centroids, method='nearest')
    # rho_verts = sp.interpolate.griddata(points, rho_values, centroids, method='nearest')

    interpolation_method = kwargs.get('interpolation_method', 'nearest') #TODO: This line is inconsistent in naming with
    print("Interpolating points with method: ' ", interpolation_method, "'.")
    print("If this process is slow, consider passing 'interpolation_method='nearest' with the plot_complex_field_in_plane function.") #TODO: this line. (interpolation vs interpolation_method)
    print("That will speed up the process, but the plot may look less smooth.")
    reals_verts = sp.interpolate.griddata(points, reals.ravel(), centroids, method=interpolation_method)
    imags_verts = sp.interpolate.griddata(points, imags.ravel(), centroids, method=interpolation_method)
    print("Interpolation done.")

    theta_verts = np.arctan2(imags_verts, reals_verts)
    rho_verts = np.abs(reals_verts + 1j*imags_verts)

    # Normalize field values for color mapping
    theta_normalized = (theta_verts+np.pi) / (2*np.pi)

    # Map normalized field values to colors
    plt_colormap_object = tool_colormap(kwargs['colormap'], plot_lib='matplotlib')
    colors = plt_colormap_object(theta_normalized)

    # Blend the colors with white according to rho (normalized)
    colors[:,3] = (rho_verts/np.max(rho_verts)).ravel()

    # Extract coordinates
    x = kwargs.get('x', self.x/self.a0).flatten()
    dx = x[1] - x[0]

    y = kwargs.get('y', self.y/self.a0).flatten()
    dy = y[1] - y[0]

    z = kwargs.get('z', self.z/self.a0).flatten()
    dz = z[1] - z[0]

    # Create the mesh object
    x_new = (verts[:, 0] * dx + x[0]) 
    y_new = (verts[:, 1] * dy + y[0]) 
    z_new = (verts[:, 2] * dz + z[0]) 

    mesh = go.Mesh3d(
                x=x_new, 
                y=y_new, 
                z=z_new,
                i=faces[:, 0], 
                j=faces[:, 1], 
                k=faces[:, 2],
                customdata=np.array([theta_verts/np.pi, rho_verts]).T,
                facecolor=colors,  # Set color for each face
                showscale=False,
                hovertemplate=kwargs['xlabel']+': %{x:.2f}<br>'+\
                                kwargs['ylabel']+': %{y:.2f}<br>'+\
                                kwargs['zlabel']+': %{z:.2f}<br>'+\
                                'amplitude: %{customdata[1]:.2e}<br>'+\
                                'phase: %{customdata[0]:.2f} π',
                name = '',
                scene=ax['sceneN']
            )
    fig.add_trace(mesh)

    # Create a colorbar
    # if colorbar:
    #     mappable = plt.cm.ScalarMappable(cmap=tool_colormap_angle())
    #     mappable.set_array([])
    #     mappable.set_clim(-np.pi, np.pi)
    #     cbar = plt.colorbar(mappable, ax=ax, pad=0.2)
    #     cbar.set_ticks(np.array([-np.pi, -2 * np.pi / 3, -np.pi / 3, 0, np.pi / 3, 2 * np.pi / 3, np.pi]))
    #     cbar.set_ticklabels([r'$-\pi$', r'$-2\pi/3$', r'$-\pi/3$', r'$0$', r'$\pi/3$', r'$2\pi/3$', r'$\pi$'])


    if kwargs['colorbar'] and not(ax['colorbar']) and not(kwargs['field_is_nan']):
        ax['colormap_object'] = kwargs['colormap_object']
        fig.add_trace(tool_plotly_colorbar(ax, type='angle'))
        ax['colorbar'] = True

    kwargs['fig'] = fig
    kwargs['ax'] = ax
    tool_set_plot_axis_properties_plotly(self, **kwargs)

    return fig, ax
--- End of file: comfit\plot\plot_complex_field_in_plane_plotly.py ---

--- Start of file: comfit\plot\plot_complex_field_matplotlib.py ---
from typing import TYPE_CHECKING, Any, Tuple

if TYPE_CHECKING:
    from comfit.core.base_system import BaseSystem

# Standard library imports
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
import scipy as sp
from mpl_toolkits.mplot3d import Axes3D
from skimage.measure import marching_cubes

# Local application imports
from comfit.tool import (
    tool_complete_field,
    tool_colormap,
    tool_set_plot_axis_properties_matplotlib,
    tool_matplotlib_define_2D_plot_ax,
    tool_matplotlib_define_3D_plot_ax
)
from .plot_surface_matplotlib import plot_surface_matplotlib

def plot_complex_field_matplotlib(
        self: 'BaseSystem',
        complex_field: np.ndarray,
        **kwargs: Any
        ) -> Tuple[matplotlib.figure.Figure, matplotlib.axes.Axes]:
    """Plot a complex field using matplotlib.

    Creates a visualization of a complex field using different plotting methods
    depending on the dimensionality of the field.

    Parameters
    ----------
    self : BaseSystem
        A BaseSystem (or derived) instance.
    complex_field : np.ndarray
        The complex field to plot
    kwargs : Any
        Keyword arguments for the plot, see https://comfitlib.com/Plotting/

    Returns
    -------
    Tuple[matplotlib.figure.Figure, matplotlib.axes.Axes]
        The figure and axes objects containing the plot

    Examples
    --------
    >>> system.plot_complex_field_matplotlib(field, colorbar=True)
    """

    kwargs['colormap'] = kwargs.get('colormap', 'angle') # Override the default colormap with 'angle'
    complex_field, fig, ax, kwargs = self.plot_prepare(complex_field, field_type = 'complex', **kwargs)

    # Calculate the magnitude and phase of the complex field
    rho = np.abs(complex_field)
    theta = np.angle(complex_field)

    ###############################################################
    ###################### DIMENSION: 1 ###########################
    ###############################################################

    if self.dim == 1:

        ax = tool_matplotlib_define_2D_plot_ax(fig, ax)

        x = kwargs.get('x', self.x).flatten()

        # Padding for the colorbar.
        padding=0.05

        ax.plot(x, rho, color='black')

        # Color in the graph based on the argument of the complex field
        blend_factor=0.3 # The degree to which the color is blended with white
        cmap = kwargs['colormap_object']

        # Extract coordinates
        dx = x[1] - x[0]
        xmax = x[-1]+dx


        ax.fill_between([x[0],(x[0]+dx/2)], [rho[0],(rho[0]+rho[1])/2],
                        color=(1-blend_factor)*np.array(cmap((theta[0] + np.pi) / (2 * np.pi)))+blend_factor*np.array([1,1,1,1]), 
                        alpha=1)

        for i in range(1,self.xRes-1):
            ax.fill_between([(x[i]-dx/2),x[i]], [(rho[i]+rho[i-1])/2,rho[i]],
                            color=(1-blend_factor)*np.array(cmap((theta[i] + np.pi) / (2 * np.pi)))+blend_factor*np.array([1,1,1,1]), 
                            alpha=1)
            ax.fill_between([x[i],(x[i]+dx/2)], [rho[i],(rho[i]+rho[i+1])/2],
                color=(1-blend_factor)*np.array(cmap((theta[i] + np.pi) / (2 * np.pi)))+blend_factor*np.array([1,1,1,1]),  
                alpha=1)

        ax.fill_between([(xmax-1.5*dx),(xmax-dx)], [(rho[-1]+rho[-2])/2,rho[-1]],
                        color=(1-blend_factor)*np.array(cmap((theta[-1] + np.pi) / (2 * np.pi)))+blend_factor*np.array([1,1,1,1]),  
                        alpha=1)
            
    ###############################################################
    ###################### DIMENSION: 2 ###########################
    ###############################################################

    elif self.dim == 2:
        # Keyword arguments particular to the 2D case
        plot_method = kwargs.get('plot_method', 'phase_angle')

        # Extract coordinates
        x = kwargs.get('x', self.x/self.a0).flatten()
        dx = x[1] - x[0]
        xmax = x[-1]+dx

        y = kwargs.get('y', self.y/self.a0).flatten()
        dy = y[1] - y[0]
        ymax = y[-1]+dy

        # Create a meshgrid
        X, Y = np.meshgrid(x, y, indexing='ij')

        if plot_method == '3Dsurface':
        
            # Padding for the colorbar
            padding=0.2

            # Keyword arguments particular to the 3D surface plot
            grid = kwargs.get('grid', True)
            kwargs['axis_equal'] = False
            
            ax = tool_matplotlib_define_3D_plot_ax(fig, ax)
            kwargs['plot_is_3D'] = True
            
            # Get the colors from a colormap (e.g., hsv, but you can choose any other)
            colors = kwargs['colormap_object']((theta + np.pi) / (2 * np.pi))  # Normalizing theta to [0, 1]

            surf = ax.plot_surface(X, Y, rho, facecolors=colors)

        elif plot_method == 'phase_angle':
            

            # Keyword arguments particular to the phase angle plot
            grid = kwargs.get('grid', False)

            rho_normalized = rho / np.max(rho)

            custom_colormap = kwargs['colormap_object']
            
            # Check if an axis object is provided
            ax = tool_matplotlib_define_2D_plot_ax(fig, ax)

            # Padding for the colorbar
            padding=0.05
            
            mesh = ax.pcolormesh(X, Y, theta, shading='auto', cmap=custom_colormap, vmin=-np.pi, vmax=np.pi)
            mesh.set_alpha(rho_normalized)
 

    elif self.dim == 3:

        grid = kwargs.get('grid', True)
        axis_equal = kwargs.get('axis_equal',True)

        plot_method = kwargs.get('plot_method', 'phase_blob')

        rho_normalized = rho / np.max(rho)

        colormap = kwargs['colormap_object']

        ax = tool_matplotlib_define_3D_plot_ax(fig, ax)
        kwargs['plot_is_3D'] = True
    
        if plot_method == 'phase_angle':
            
            # Padding for the colorbar
            padding=0.2

            for angle in [-2 * np.pi / 3, -np.pi / 3, 0, np.pi / 3, 2 * np.pi / 3]:
                field_to_plot = theta.copy()
                field_to_plot[theta < angle - 1] = float('nan')
                field_to_plot[theta > angle + 1] = float('nan')
                field_to_plot[rho_normalized < 0.01] = float('nan')

                if np.nanmin(field_to_plot) < angle < np.nanmax(field_to_plot):
                    #TODO: make alpha a keyword argument (Vidar 11.03.24)
                    plot_surface_matplotlib(self, field=field_to_plot, 
                                        value=angle, 
                                        color=colormap((angle + np.pi) / (2 * np.pi)), 
                                        alpha=0.5,
                                        ax=ax)

            theta = np.mod(theta, 2 * np.pi)

            field_to_plot = theta.copy()
            field_to_plot[theta < np.pi - 1] = float('nan')
            field_to_plot[theta > np.pi + 1] = float('nan')
            field_to_plot[rho_normalized < 0.01] = float('nan')

            if np.nanmin(field_to_plot) < np.pi < np.nanmax(field_to_plot):
                #TODO: make alpha a keyword argument (Vidar 11.03.24)
                plot_surface_matplotlib(self, field=field_to_plot, 
                                        value=np.pi, 
                                        color=colormap(0), 
                                        alpha=0.5,
                                        ax=ax)
        
        elif plot_method == 'phase_blob':
            # TODO: change the function so that it used plot_surface_matplotlib (Vidar 11.03.24)
            # Padding for the colorbar
            padding=0.2
            
            phase_blob_threshold = kwargs.get('phase_blob_threshold', 0.5)

            if np.nanmin(rho_normalized)<phase_blob_threshold<np.nanmax(rho_normalized):
                verts, faces, _, _ = marching_cubes(rho_normalized, phase_blob_threshold)

                # Calculate the centroids of each triangle
                centroids = np.mean(verts[faces], axis=1)

                # Assuming theta is defined on the same grid as rho
                x, y, z = np.mgrid[0:rho_normalized.shape[0], 0:rho_normalized.shape[1], 0:rho_normalized.shape[2]]

                # Flatten the grid for interpolation
                points = np.c_[x.ravel(), y.ravel(), z.ravel()]
                theta_values = theta.ravel()

                # Interpolate theta at the vertices positions
                theta_faces = sp.interpolate.griddata(points, theta_values, centroids, method='nearest')

                # Normalize theta values for color mapping
                theta_faces_normalized = (theta_faces + np.pi) / (2*np.pi)

                # Map normalized theta values to colors
                colors = colormap(theta_faces_normalized)
                
                # Extract coordinates
                x = kwargs.get('x', self.x/self.a0).flatten()
                dx = x[1] - x[0]
                xmax = x[-1]+dx

                y = kwargs.get('y', self.y/self.a0).flatten()
                dy = y[1] - y[0]
                ymax = y[-1]+dy

                z = kwargs.get('z', self.z/self.a0).flatten()
                dz = z[1] - z[0]
                zmax = z[-1]+dz

                # Plot the complex field
                ax.plot_trisurf(x[0]+verts[:, 0]*dx, 
                                y[0]+verts[:, 1]*dy, 
                                faces, 
                                z[0]+verts[:, 2]*dz, 
                                facecolor=colors, antialiased=False)
            
                # Plot the shadows on the edges
                plot_shadows = kwargs.get('plot_shadows', True)
                if plot_shadows:
                    ax.plot_trisurf((x[0]+0*verts[:, 0]*dx), 
                                    (y[0]+verts[:, 1]*dy), 
                                    faces, 
                                    (z[0]+verts[:, 2]*dz), 
                                    facecolor='black', antialiased=True,
                                    alpha=0.1)

                    ax.plot_trisurf((x[0]+verts[:, 0]*dx), 
                                    (ymax+0*verts[:, 1]*dy), 
                                    faces, 
                                    (z[0]+verts[:, 2]*dz), 
                                    facecolor='black', antialiased=True,
                                    alpha=0.1)
                    
                    ax.plot_trisurf((x[0]+verts[:, 0]*dx), 
                                    (y[0]+verts[:, 1]*dy), 
                                    faces, 
                                    (z[0]+0*verts[:, 2]*dz), 
                                    facecolor='black', antialiased=True,
                                    alpha=0.1)



    if kwargs['colorbar']:

        mappable = plt.cm.ScalarMappable(cmap=kwargs['colormap_object'])
        mappable.set_array([])
        mappable.set_clim(-np.pi, np.pi)
        cbar = plt.colorbar(mappable, ax=ax, pad=padding)

        cticks = kwargs.get('cticks', [-np.pi, -2*np.pi/3, -np.pi/3, 0, np.pi/3, 2*np.pi/3, np.pi])
        cbar.set_ticks(cticks)

        cticklabelse = kwargs.get('cticklabels', [r'$-\pi$', r'$-2\pi/3$', r'$-\pi/3$', r'$0$', r'$\pi/3$', r'$2\pi/3$', r'$\pi$'])
        cbar.set_ticklabels(cticklabelse)

    kwargs['fig'] = fig
    kwargs['ax'] = ax
    tool_set_plot_axis_properties_matplotlib(self, **kwargs)

    return fig, ax

--- End of file: comfit\plot\plot_complex_field_matplotlib.py ---

--- Start of file: comfit\plot\plot_complex_field_plotly.py ---
from typing import TYPE_CHECKING, Any, Dict, Tuple

if TYPE_CHECKING:
    from comfit.core.base_system import BaseSystem

# Standard library imports
import numpy as np
import scipy as sp

# Third-party library imports
import plotly.graph_objects as go
import matplotlib.colors as mcolors
import matplotlib.cm as cm
from skimage.measure import marching_cubes

from .plot_surface_plotly import plot_surface_plotly

# Local application imports
from comfit.tool import (
    tool_complete_field,
    tool_colormap, 
    tool_set_plot_axis_properties_plotly,
    tool_plotly_colorbar,
    tool_plotly_define_2D_plot_ax,
    tool_plotly_define_3D_plot_ax
)


def plot_complex_field_plotly(
        self: 'BaseSystem',
        complex_field: np.ndarray,
        **kwargs: Any
        ) -> Tuple[go.Figure, Dict]:
    """Plot a complex field using Plotly.

    Creates a visualization of a complex field using various plotting methods
    depending on the dimensionality of the field.

    Parameters
    ----------
    self : BaseSystem
        A BaseSystem (or derived) instance.
    complex_field : np.ndarray
        The complex field to plot
    kwargs : Any
        Additional keyword arguments to customize the plot

    Returns
    -------
    go.Figure
        The Plotly figure containing the plot
    """

    kwargs['colormap'] = kwargs.get('colormap', 'angle') # Override the default colormap with 'angle'
    complex_field, fig, ax, kwargs = self.plot_prepare(complex_field, field_type = 'complex', **kwargs)

    # Kewyord arguments
    kwargs['colorbar'] = kwargs.get('colorbar', True)

    # Extend the field if not a complete array is given
    complex_field = tool_complete_field(self, complex_field)

    # Calculate the magnitude and phase of the complex field
    rho = np.abs(complex_field)
    theta = np.angle(complex_field)

    plt_colormap_object = tool_colormap(kwargs['colormap'], plot_lib='matplotlib')

    ###############################################################
    ###################### DIMENSION: 1 ###########################
    ###############################################################

    if self.dim == 1:

        ax = tool_plotly_define_2D_plot_ax(fig, ax)

        vlim = kwargs.get('vlim', None)
        if vlim is not None:
            kwargs['ylim'] = vlim

        # Color in the graph based on the argument of the complex field
        blend_factor=0.3 # The degree to which the color is blended with white
        
        color = (1-blend_factor)*np.array(plt_colormap_object((theta[0] + np.pi) / (2 * np.pi)))+blend_factor*np.array([1,1,1,1])
        color_str = ('rgb('+str(int(color[0]*255))+','+str(int(color[1]*255))+','+str(int(color[2]*255))+')')

        # Extract coordinates
        x = kwargs.get('x', self.x/self.a0).flatten()
        dx = x[1] - x[0]
        xmin = x[0]
        xmax = x[-1]+dx

        fig.add_trace(go.Scatter(x=[xmin,(xmin+dx/2)], 
                        y=[rho[0],(rho[0]+rho[1])/2],
                        mode='lines',
                        line=dict(color='rgba(0,0,0,0)'),
                        fill='tozeroy',
                        showlegend=False,
                        hoverinfo='skip',
                        fillcolor=color_str,
                        xaxis=ax['xN'],
                        yaxis=ax['yN']))

        for i in range(1,self.xRes-1):
            color = (1-blend_factor)*np.array(plt_colormap_object((theta[i] + np.pi) / (2 * np.pi)))+blend_factor*np.array([1,1,1,1])
            color_str = ('rgb('+str(int(color[0]*255))+','+str(int(color[1]*255))+','+str(int(color[2]*255))+')')
            fig.add_trace(go.Scatter(x=[(x[i]-dx/2),x[i]], 
                        y=[(rho[i]+rho[i-1])/2,rho[i]],
                        mode='lines',
                        line=dict(color='rgba(0,0,0,0)'),
                        fill='tozeroy',
                        showlegend=False,
                        hoverinfo='skip',
                        fillcolor=color_str, 
                        xaxis=ax['xN'],
                        yaxis=ax['yN']))

            color = (1-blend_factor)*np.array(plt_colormap_object((theta[i] + np.pi) / (2 * np.pi)))+blend_factor*np.array([1,1,1,1])
            color_str = ('rgb('+str(int(color[0]*255))+','+str(int(color[1]*255))+','+str(int(color[2]*255))+')')
            fig.add_trace(go.Scatter(x=[x[i],(x[i]+dx/2)], 
                        y=[rho[i],(rho[i]+rho[i+1])/2],
                        mode='lines',
                        line=dict(color='rgba(0,0,0,0)'),
                        fill='tozeroy',
                        showlegend=False,
                        hoverinfo='skip',
                        fillcolor=color_str,
                        xaxis=ax['xN'],
                        yaxis=ax['yN']))

        color = (1-blend_factor)*np.array(plt_colormap_object((theta[-1] + np.pi) / (2 * np.pi)))+blend_factor*np.array([1,1,1,1])
        color_str = ('rgb('+str(int(color[0]*255))+','+str(int(color[1]*255))+','+str(int(color[2]*255))+')')
        fig.add_trace(go.Scatter(x=[(xmax-1.5*dx),(xmax-dx)], 
                        y=[(rho[-1]+rho[-2])/2,rho[-1]],
                        mode='lines',
                        line=dict(color='rgba(0,0,0,0)'),
                        fill='tozeroy',
                        showlegend=False,
                        hoverinfo='skip',
                        fillcolor=color_str,
                        xaxis=ax['xN'],
                        yaxis=ax['yN']))


        fig.add_trace(go.Scatter(
            x=x,
            y=rho,
            mode='lines',
            showlegend=False,
            customdata=np.stack((theta/np.pi, rho), axis=-1),
            hovertemplate= kwargs['xlabel']+': %{x:.2f} <br>'+\
                                'amplitude: %{customdata[1]:.2e}<br>'+\
                                'phase: %{customdata[0]:.2f} π',
            name='',
            line=dict(color='black'),
            xaxis=ax['xN'],
            yaxis=ax['yN']
        ))

        
    ###############################################################
    ###################### DIMENSION: 2 ###########################
    ###############################################################

    elif self.dim == 2:
        
        # Keyword arguments particular to the 2D case
        plot_method = kwargs.get('plot_method', 'phase_angle')

        # Extract coordinates
        x = kwargs.get('x', self.x/self.a0).flatten()
        dx = x[1] - x[0]
        xmin = x[0]
        xmax = x[-1]+dx
        
        y = kwargs.get('y', self.y/self.a0).flatten()
        dy = y[1] - y[0]
        ymin = y[0]
        ymax = y[-1]+dy

        if plot_method == '3Dsurface':
        
            print("\033[91mWarning: 3D surface plot not yet implemented for Plotly.\033[0m")
            pass

        elif plot_method == 'phase_angle':
            
            ax = tool_plotly_define_2D_plot_ax(fig, ax)

            # Keyword arguments particular to the phase angle plot
            grid = kwargs.get('grid', False)

            rho_normalized = rho / np.max(rho)
            
            norm = mcolors.Normalize(vmin=-np.pi, vmax=np.pi)

            # Create an RGBA image array
            rgba_image = cm.ScalarMappable(norm=norm, cmap=plt_colormap_object).to_rgba(theta)

            # Apply the spatial opacity
            for i in range(rgba_image.shape[0]):
                for j in range(rgba_image.shape[1]):
                    for k in range(3):
                        rgba_image[i, j, k] = 1-(1-rgba_image[i, j, k])*rho_normalized[i, j]  # Set alpha channel

            rgba_image = np.transpose(rgba_image, (1, 0, 2))

            # Convert RGBA image to a format Plotly can understand
            image_data = (rgba_image * 255).astype(np.uint8)


            if fig == None:
                fig = go.Figure()

            trace = go.Image(z=image_data, 
                            dx=dx, 
                            dy=dy, 
                            x0=xmin, 
                            y0=ymin,
                            hovertemplate=kwargs['xlabel']+': %{x:.2f}<br>'+\
                                            kwargs['ylabel']+': %{y:.2f}<br>'+\
                                            'amplitude: %{customdata[1]:.2e}<br>'+\
                                            'phase: %{customdata[0]:.2f} π',
                            customdata=np.stack((np.transpose(theta/np.pi), np.transpose(rho)), axis=-1),
                            name='',
                            xaxis=ax['xN'],
                            yaxis=ax['yN']
                            )

            fig.add_trace(trace)


    ###############################################################
    ###################### DIMENSION: 3 ###########################
    ###############################################################
    elif self.dim == 3:

        ax = tool_plotly_define_3D_plot_ax(fig, ax)
        kwargs['ax'] = ax 

        # Keyword arguments particular to the 3D case
        plot_method = kwargs.get('plot_method', 'phase_blob')
        
        rho_normalized = rho / np.max(rho)

        if plot_method == 'phase_angle':

            # Extract coordinates
            x = kwargs.get('x', self.x/self.a0).flatten()
            dx = x[1] - x[0]
            xmin = x[0]
            xmax = x[-1]+dx

            y = kwargs.get('y', self.y/self.a0).flatten()
            dy = y[1] - y[0]
            ymin = y[0]
            ymax = y[-1]+dy

            z = kwargs.get('z', self.z/self.a0).flatten()
            dz = z[1] - z[0]
            zmin = z[0]
            zmax = z[-1]+dz

            X, Y, Z = np.meshgrid(x, y, z, indexing='ij')
            
            for angle in [-2 * np.pi / 3, -np.pi / 3, 0, np.pi / 3, 2 * np.pi / 3]:
                field_to_plot = theta.copy()
                field_to_plot[theta < angle - 1] = float('nan')
                field_to_plot[theta > angle + 1] = float('nan')
                field_to_plot[rho_normalized < 0.01] = float('nan')

                if np.nanmin(field_to_plot) < angle < np.nanmax(field_to_plot):

                    mesh = plot_surface_plotly(self,
                                            field_to_plot,
                                            value=angle,
                                            alpha=rho,
                                            color=plt_colormap_object((angle + np.pi) / (2 * np.pi)), 
                                            plt_colormap_object=plt_colormap_object,
                                            **kwargs
                                            )

                    fig.add_trace(mesh)

            theta = np.mod(theta, 2 * np.pi)

            field_to_plot = theta.copy()
            field_to_plot[theta < np.pi - 1] = float('nan')
            field_to_plot[theta > np.pi + 1] = float('nan')
            field_to_plot[rho_normalized < 0.01] = float('nan')

            if np.nanmin(field_to_plot) < np.pi < np.nanmax(field_to_plot):
                mesh = plot_surface_plotly(self,
                                            field_to_plot,
                                            value=np.pi,
                                            alpha=rho,
                                            color=plt_colormap_object((np.pi + np.pi) / (2 * np.pi)), 
                                            plt_colormap_object=plt_colormap_object,
                                            **kwargs
                                            )

                fig.add_trace(mesh)
        
        elif plot_method == 'phase_blob':
            
            phase_blob_threshold = kwargs.get('phase_blob_threshold', 0.5)

            if np.nanmin(rho_normalized)<phase_blob_threshold<np.nanmax(rho_normalized):


                mesh = plot_surface_plotly(self, 
                                        field=rho, 
                                        value=phase_blob_threshold*np.max(rho), 
                                        alpha=1,
                                        color=complex_field,
                                        plt_colormap_object=plt_colormap_object,
                                          **kwargs)

                fig.add_trace(mesh)

    # if kwargs['colorbar'] and not(ax['colorbar']) and not(kwargs['field_is_nan']):
    #     ax['colormap_object'] = kwargs['colormap_object']
    #     fig.add_trace(tool_plotly_colorbar(ax, type='angle'))
    #     ax['colorbar'] = True


    if kwargs['colorbar'] and not(kwargs['field_is_nan']):
        ax['colormap_object'] = kwargs['colormap_object']
        fig.add_trace(tool_plotly_colorbar(ax, type='angle'))
        ax['colorbar'] = True

    kwargs['fig'] = fig
    kwargs['ax'] = ax
    tool_set_plot_axis_properties_plotly(self, **kwargs)

    return fig, ax
--- End of file: comfit\plot\plot_complex_field_plotly.py ---

--- Start of file: comfit\plot\plot_field_in_plane_matplotlib.py ---
from typing import TYPE_CHECKING, Optional, Any, Tuple

if TYPE_CHECKING:
    from comfit.core.base_system import BaseSystem

import numpy as np
import matplotlib.pyplot as plt
import scipy as sp
from skimage.measure import marching_cubes
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.figure
import matplotlib.axes

from comfit.tool import (
    tool_complete_field,
    tool_set_plot_axis_properties_matplotlib,
    tool_colormap,
    tool_matplotlib_define_3D_plot_ax
)

def plot_field_in_plane_matplotlib(
        self: 'BaseSystem',
        field: np.ndarray,
        normal_vector: Optional[np.ndarray] = None,
        position: Optional[np.ndarray] = None,
        **kwargs: Any
    ) -> Tuple[matplotlib.figure.Figure, matplotlib.axes.Axes]:
    """Plot the field in a plane perpendicular to the given normal vector.

    Uses scipy.interpolate.griddata and plt.plot_trisurf to visualize the field
    values on a plane defined by its normal vector and a point in space.

    Parameters
    ----------
    self : BaseSystem
        A BaseSystem (or derived) instance.
    field : np.ndarray
        The field to be plotted.
    normal_vector : np.ndarray, optional
        The normal vector of the plane. Defaults to [0,1,0].
    position : np.ndarray, optional
        The position of the plane. Defaults to the middle of the system.
    kwargs : Any
        Keyword arguments for the plot, see https://comfitlib.com/Plotting/.

    Returns
    -------
    Tuple[matplotlib.figure.Figure, matplotlib.axes.Axes]
        The figure and axes containing the plot.

    Raises
    ------
    Exception
        If the field dimension is not 3D.
    """

    # print('\033[93mWarning: The plot_in_plane function is not yet supported with plotly.\033[0m')

    if self.dim != 3:
        raise Exception("The plot in plane function is only defined for 3D fields.")

    field, fig, ax, kwargs = self.plot_prepare(field, field_type = 'real', **kwargs)

    ax = tool_matplotlib_define_3D_plot_ax(fig, ax) 

    # Default values of position and normal vector
    if position is None:
        position = self.rmid

    if normal_vector is None:
        normal_vector=[0,1,0]

    if ax is None:
        ax = fig.add_subplot(111, projection='3d')

    normal_vector = np.array(normal_vector)/np.linalg.norm(normal_vector)
    height_above_plane = (self.x-position[0])*normal_vector[0] + (self.y-position[1])*normal_vector[1] + (self.z-position[2])*normal_vector[2]

    verts, faces, _, _ = marching_cubes(height_above_plane, 0)

    # Calculate the centroids of each triangle
    centroids = np.mean(verts[faces], axis=1)

    # Assuming field is defined on the same grid as height_above_plane
    x, y, z = np.mgrid[0:height_above_plane.shape[0], 0:height_above_plane.shape[1], 0:height_above_plane.shape[2]]

    # Flatten the grid for interpolation
    points = np.c_[x.ravel(), y.ravel(), z.ravel()]
    field_values = field.ravel()

    # Interpolate field at the vertices positions
    field_verts = sp.interpolate.griddata(points, field_values, centroids, method='nearest')

    # Normalize field values for color mapping
    field_normalized = (field_verts - np.min(field_verts)) / (np.max(field_verts) - np.min(field_verts))

    # Map normalized field values to colors
    colors = kwargs['colormap_object'](field_normalized)


    # Extract coordinates
    x = kwargs.get('x', self.x/self.a0).flatten()
    dx = x[1] - x[0]
    xmin = x[0]
    xmax = x[-1]+dx
    
    y = kwargs.get('y', self.y/self.a0).flatten()
    dy = y[1] - y[0]
    ymin = y[0]
    ymax = y[-1]+dy

    z = kwargs.get('z', self.z/self.a0).flatten()
    dz = z[1] - z[0]
    zmin = z[0]
    zmax = z[-1]+dz
    
    ax.plot_trisurf((xmin+verts[:, 0]*dx),
                    (ymin+verts[:, 1]*dy),
                    faces,
                    (zmin+verts[:, 2]*dz),
                    facecolor=colors, antialiased=False)

    if kwargs['colorbar']:
            sm = plt.cm.ScalarMappable(cmap=kwargs['colormap_object'])
            sm.set_clim(kwargs['vmin'], kwargs['vmax'])
            plt.colorbar(sm, ax=ax, pad=0.2)

    kwargs['ax'] = ax
    ax = tool_set_plot_axis_properties_matplotlib(self, **kwargs)
    return fig, ax
--- End of file: comfit\plot\plot_field_in_plane_matplotlib.py ---

--- Start of file: comfit\plot\plot_field_in_plane_plotly.py ---
from typing import TYPE_CHECKING, Optional, Any, Tuple, Dict
if TYPE_CHECKING:
    from comfit.core.base_system import BaseSystem

# Standard library imports
import numpy as np
from scipy.interpolate import griddata
from skimage.measure import marching_cubes

# Third-party library imports
import plotly.graph_objects as go

# Local imports
from comfit.tool.tool_complete_field import tool_complete_field
from comfit.tool.tool_set_plot_axis_properties_plotly import tool_set_plot_axis_properties_plotly
from comfit.tool import tool_plotly_define_3D_plot_ax, tool_plotly_colorbar

def plot_field_in_plane_plotly(
        self: 'BaseSystem',
        field: np.ndarray,
        normal_vector: Optional[np.ndarray] = None,
        position: Optional[np.ndarray] = None,
        **kwargs: Any
        ) -> Tuple[go.Figure, Dict]:
    """Plot the field in a plane perpendicular to the given normal vector.
    
    Uses scipy.interpolate.griddata and plotly's Mesh3d for visualization.

    Parameters
    ----------
    self : BaseSystem
        A BaseSystem (or derived) instance.
    field : np.ndarray
        The field to be plotted
    normal_vector : np.ndarray, optional
        The normal vector of the plane. Defaults to [0,1,0]
    position : np.ndarray, optional
        The position of the plane. Defaults to the middle of the system
    kwargs : Any
        Additional keyword arguments for plot customization. See https://comfitlib.com/Plotting/

    Returns
    -------
    Tuple[go.Figure, dict]
        The figure object and axes dictionary containing the plot

    Raises
    ------
    Exception
        If the field dimension is not 3D
    """

    if self.dim != 3:
        raise Exception("The plot in plane function is only defined for 3D fields.")

    field, fig, ax, kwargs = self.plot_prepare(field, field_type = 'real', **kwargs)

    ax = tool_plotly_define_3D_plot_ax(fig, ax) #Defines sceneN, plot_dimension


    # Default values of position and normal vector
    if position is None:
        position = self.rmid

    if normal_vector is None:
        normal_vector = [0, 1, 0]

    normal_vector = np.array(normal_vector) / np.linalg.norm(normal_vector)
    height_above_plane = (self.x - position[0]) * normal_vector[0] + (self.y - position[1]) * normal_vector[1] + (self.z - position[2]) * normal_vector[2]

    verts, faces, _, _ = marching_cubes(height_above_plane, 0)

    # Calculate the centroids of each triangle
    centroids = np.mean(verts[faces], axis=1)

    # Assuming field is defined on the same grid as height_above_plane
    x, y, z = np.mgrid[0:height_above_plane.shape[0], 0:height_above_plane.shape[1], 0:height_above_plane.shape[2]]

    # Flatten the grid for interpolation
    points = np.c_[x.ravel(), y.ravel(), z.ravel()]
    field_values = field.ravel()

    # Interpolate field at the vertices positions
    field_verts = griddata(points, field_values, centroids, method='nearest')

    ax['vmin'] = kwargs.get('vmin', np.min(field_verts))
    ax['vmax'] = kwargs.get('vmax', np.max(field_verts))

    # Extract coordinates
    x = kwargs.get('x', self.x/self.a0).flatten()
    dx = x[1] - x[0]
    xmin = x[0]
    xmax = x[-1]+dx
    
    y = kwargs.get('y', self.y/self.a0).flatten()
    dy = y[1] - y[0]
    ymin = y[0]
    ymax = y[-1]+dy

    z = kwargs.get('z', self.z/self.a0).flatten()
    dz = z[1] - z[0]
    zmin = z[0]
    zmax = z[-1]+dz

    # Add trace
    fig.add_trace(go.Mesh3d(
        x=(xmin + verts[:, 0] * dx) ,
        y=(ymin + verts[:, 1] * dy) ,
        z=(zmin + verts[:, 2] * dz) ,
        i=faces[:, 0],
        j=faces[:, 1],
        k=faces[:, 2],
        intensity=field_verts,  
        intensitymode='cell',  
        colorscale=kwargs['colormap_object'],
        hovertemplate=kwargs['xlabel']+': %{x:.2f}<br>'+\
                        kwargs['ylabel']+': %{y:.2f}<br>'+\
                        kwargs['zlabel']+': %{z:.2f}<br>'+\
                        'field: %{intensity:.2e}',
        name='',
        showscale=False,
        scene=ax['sceneN']
    ))

    if kwargs['colorbar'] and not(ax['colorbar']) and not(kwargs['field_is_nan']):
        ax['colormap_object'] = kwargs['colormap_object']
        fig.add_trace(tool_plotly_colorbar(ax, type='normal'))
        ax['colorbar'] = True

    kwargs['fig'] = fig
    kwargs['ax'] = ax
    tool_set_plot_axis_properties_plotly(self, **kwargs)
    return fig, ax

--- End of file: comfit\plot\plot_field_in_plane_plotly.py ---

--- Start of file: comfit\plot\plot_field_matplotlib.py ---
from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from comfit.core.base_system import BaseSystem

# Standard library imports
from typing import Union

# Third-party library imports
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
from mpl_toolkits.mplot3d import Axes3D
import plotly.graph_objects as go

# Local application imports
from comfit.tool import (
    tool_complete_field,
    tool_set_plot_axis_properties_matplotlib,
    tool_set_plot_axis_properties_plotly,
    tool_colormap,
    tool_matplotlib_define_2D_plot_ax,
    tool_matplotlib_define_3D_plot_ax
)

from .plot_surface_matplotlib import plot_surface_matplotlib

def plot_field_matplotlib(
        self: 'BaseSystem',
        field: np.ndarray,
        **kwargs: Any
        ) -> tuple[matplotlib.figure.Figure, matplotlib.axes.Axes]:
    """Plot the given (real) field.

    Parameters
    ----------
    self : BaseSystem
        A BaseSystem (or derived) instance.
    field : np.ndarray
        The field to be plotted.
    kwargs : Any
        Keyword arguments for the plot.
        See https://comfitlib.com/ClassBaseSystem/ 
        for a full list of keyword arguments.

    Returns
    -------
    tuple[matplotlib.figure.Figure, matplotlib.axes.Axes]
        - The figure containing the plot
        - The axes containing the plot
    """

    field, fig, ax, kwargs = self.plot_prepare(field, field_type = 'real', **kwargs)

    ###############################################################
    ###################### DIMENSION: 1 ###########################
    ###############################################################

    if self.dim == 1:

        ax = tool_matplotlib_define_2D_plot_ax(fig, ax)

        # Extract coordinates
        x = kwargs.get('x', self.x/self.a0).flatten()

        ax.plot(self.x/self.a0, field)

    ###############################################################
    ###################### DIMENSION: 2 ###########################
    ###############################################################

    if self.dim == 2:
        
        # Keyword arguments particular to the 2D case
        kwargs['grid'] = kwargs.get('grid', False)

        ax = tool_matplotlib_define_2D_plot_ax(fig, ax)
            
        # Set the colormap
        colormap_string = kwargs.get('colormap', 'viridis')
        colormap = tool_colormap(colormap_string, plot_lib='matplotlib')
        
        # Value limits symmetric
        vlim_symmetric = kwargs.get('vlim_symmetric', False)

        # Extract coordinates
        x = kwargs.get('x', self.x/self.a0).flatten()
        dx = x[1] - x[0]
        xmin = x[0]
        xmax = x[-1]+dx

        y = kwargs.get('y', self.y/self.a0).flatten()
        dy = y[1] - y[0]
        ymin = y[0]
        ymax = y[-1]+dy

        X = kwargs.get('X', None)
        Y = kwargs.get('Y', None)

        if X is None or Y is None:
            X, Y = np.meshgrid(x, y, indexing='ij')

        pcm = ax.pcolormesh(X , Y , field, shading='gouraud', cmap=colormap)

        xlim = [xmin, xmax-dx]
        ylim = [ymin, ymax-dy]

        limits_provided = False
        if 'xlim' in kwargs:
            xlim = np.array(kwargs['xlim'])/self.a0
            limits_provided = True
        else:
            if 'xmin' in kwargs:
                xlim[0] = kwargs['xmin']/self.a0
                limits_provided = True
            
            if 'xmax' in kwargs:
                xlim[1] = kwargs['xmax']/self.a0
                limits_provided = True

        if 'ylim' in kwargs:
            ylim = np.array(kwargs['ylim'])/self.a0
            limits_provided = True
        else:
            if 'ymin' in kwargs:
                ylim[0] = kwargs['ymin']/self.a0
                limits_provided = True
                
            if 'ymax' in kwargs:
                ylim[1] = kwargs['ymax']/self.a0
                limits_provided = True

        # If explicit limits are provided, use them to change the vlim ranges
        if limits_provided:
            region_to_plot = np.zeros(self.dims).astype(bool)
            region_to_plot[(xlim[0] <= X)*(X <= xlim[1])*(ylim[0] <= Y)*(Y <= ylim[1])] = True
            vlim = [np.min(field[region_to_plot]), np.max(field[region_to_plot])]

        else:
            vlim = [np.min(field), np.max(field)]
        
        # Set the value limits
        if 'vlim' in kwargs:
            vlim = kwargs['vlim']
        else:
            if 'vmin' in kwargs:
                vlim[0] = kwargs['vmin']
            if 'vmax' in kwargs:
                vlim[1] = kwargs['vmax']

        if vlim[1] - vlim[0] < 1e-10:
            vlim = [vlim[0]-0.05, vlim[1]+0.05]

        pcm.set_clim(vmin=vlim[0], vmax=vlim[1])

        if 'vlim_symmetric' in kwargs:
            vlim_symmetric = kwargs['vlim_symmetric']
            if vlim_symmetric:
                cmax = abs(field).max()
                cmin = -cmax
                pcm.set_clim(vmin=cmin, vmax=cmax)

        colorbar = kwargs.get('colorbar', True)

        if colorbar:
            cbar = plt.colorbar(pcm, ax=ax)

    ###############################################################
    ###################### DIMENSION: 3 ###########################
    ###############################################################

    elif self.dim == 3:

        ax = tool_matplotlib_define_3D_plot_ax(fig, ax)
        kwargs['plot_is_3D'] = True
            
        # Keyword arguments particular to the 3D case
        number_of_layers = kwargs.get('number_of_layers', 1)
        alpha = kwargs.get('alpha', 0.5)

        vmin = kwargs['vmin']
        vmax = kwargs['vmax']

        if 'layer_values' in kwargs:
            layer_values = np.concatenate([[-np.inf], kwargs['layer_values'], [np.inf]])
        else: 
            layer_values = np.linspace(vmin, vmax, number_of_layers + 2)

        field_min = np.min(field)
        field_max = np.max(field)

        if field_min < layer_values[1] < field_max:
            plot_surface_matplotlib(self, field=field, 
                                    value=layer_values[1], 
                                    color=kwargs['colormap_object']((layer_values[1]-vmin) / (vmax-vmin)), 
                                    alpha=alpha,
                                    ax=ax)

        for layer_value in layer_values[2:-1]:
            if field_min < layer_value < field_max:
                plot_surface_matplotlib(self, field=field, 
                                        value=layer_value, 
                                        color=kwargs['colormap_object']((layer_value-vmin) / (vmax-vmin)), 
                                        alpha=alpha,
                                        ax=ax)

        if kwargs['colorbar']:
            sm = plt.cm.ScalarMappable(cmap=kwargs['colormap_object'])
            sm.set_clim(kwargs['vmin'], kwargs['vmax'])
            plt.colorbar(sm, ax=ax, pad=0.2)

    kwargs['ax'] = ax
    ax = tool_set_plot_axis_properties_matplotlib(self, **kwargs)
    return fig, ax

--- End of file: comfit\plot\plot_field_matplotlib.py ---

--- Start of file: comfit\plot\plot_field_plotly.py ---
from typing import Dict, Tuple, TYPE_CHECKING, Any

if TYPE_CHECKING:
    from comfit.core.base_system import BaseSystem

# Standard library imports
import numpy as np
    
# Third-party library imports
import plotly.graph_objects as go

# Local application imports
from comfit.tool import (
    tool_complete_field,
    tool_set_plot_axis_properties_matplotlib,
    tool_set_plot_axis_properties_plotly,
    tool_colormap,
    tool_plotly_find_next_xN,
    tool_plotly_define_2D_plot_ax,
    tool_plotly_define_3D_plot_ax,
    tool_plotly_colorbar
)

def plot_field_plotly(
    self: 'BaseSystem',
    field: np.ndarray,
    **kwargs: Any
) -> Tuple[go.Figure, Dict]:
    """Plot the given (real) field using Plotly

    Parameters
    ----------
    self : BaseSystem
        A BaseSystem (or derived) instance.
    field : np.ndarray
        The field to be plotted.
    kwargs : Any
        Keyword arguments for the plot. See https://comfitlib.com/ClassBaseSystem/ 
        for a full list of keyword arguments.

    Returns
    -------
    Tuple[go.Figure, Dict]
        A tuple containing the Plotly figure and axes dictionary.
    """

    field, fig, ax, kwargs = self.plot_prepare(field, field_type = 'real', **kwargs)

    # Extract coordinates
    x = kwargs.get('x', self.x/self.a0).flatten()
    dx = x[1] - x[0]
    xmin = x[0]
    xmax = x[-1]+dx
    
    if self.dim > 1:
        y = kwargs.get('y', self.y/self.a0).flatten()
        dy = y[1] - y[0]
        ymin = y[0]
        ymax = y[-1]+dy

    if self.dim > 2:
        z = kwargs.get('z', self.z/self.a0).flatten()
        dz = z[1] - z[0]
        zmin = z[0]
        zmax = z[-1]+dz

    ###############################################################
    ###################### DIMENSION: 1 ###########################
    ###############################################################

    if self.dim == 1:

        ax = tool_plotly_define_2D_plot_ax(fig, ax) #Defines xN, yN and plot_dimension

        if not kwargs['field_is_nan']:
            trace = go.Scatter(
                x=x,
                y=field,
                mode='lines',
                name='',
                hovertemplate=kwargs['xlabel']+': %{x:.2f}<br>'+\
                                    'field: %{y:.2e}',
                xaxis=ax['xN'],
                yaxis=ax['yN'],
                showlegend=False
            )
            fig.add_trace(trace)

    ###############################################################
    ###################### DIMENSION: 2 ###########################
    ###############################################################

    if self.dim == 2:
        
        ax = tool_plotly_define_2D_plot_ax(fig, ax) #Defines xN, yN and plot_dimension

        X = kwargs.get('X', None)
        Y = kwargs.get('Y', None)

        if X is None or Y is None:
            X, Y = np.meshgrid(x, y, indexing='ij')
            
        opacity = kwargs.get('opacity', 1)

        if not kwargs['field_is_nan']:
            # Trace
            trace = go.Heatmap(
                x=X.flatten(),
                y=Y.flatten(),
                z=field.flatten(),
                zmin=ax['vmin'],
                zmax=ax['vmax'],
                zsmooth='best',
                hovertemplate=kwargs['xlabel']+': %{x:.2f}<br>'+\
                              kwargs['ylabel']+': %{y:.2f}<br>'+\
                              'field: %{z:.2e}',
                name='',
                opacity=opacity,
                colorscale=kwargs['colormap_object'],
                showscale=False,
                xaxis=ax['xN'],
                yaxis=ax['yN']
            )

            fig.add_trace(trace)
        

    ###############################################################
    ###################### DIMENSION: 3 ###########################
    ###############################################################
    elif self.dim == 3:

        ax = tool_plotly_define_3D_plot_ax(fig, ax) #Defines sceneN, plot_dimension

        # Keyword arguments particular to the 3D case
        number_of_layers = kwargs.get('number_of_layers', 1)
        alpha = kwargs.get('alpha', 0.5)

        if 'layer_values' in kwargs:
            layer_values = np.concatenate([[-np.inf], kwargs['layer_values'], [np.inf]])
        else: 
            layer_values = np.linspace(ax['vmin'], ax['vmax'], number_of_layers + 2)


        #Plotting the layers
        X, Y, Z = np.meshgrid(x, y, z, indexing='ij')

        if not kwargs['field_is_nan']:
            for layer_value in layer_values[1:-1]:
                
                trace = go.Isosurface(
                    x=X.flatten(),
                    y=Y.flatten(),
                    z=Z.flatten(),
                    value = field.flatten(),
                    isomin = layer_value,
                    isomax = layer_value,
                    cmin = ax['vmin'],
                    cmax = ax['vmax'],
                    colorscale = kwargs['colormap_object'],
                    showscale=False,
                    hovertemplate=kwargs['xlabel']+': %{x:.2f}<br>'+\
                                  kwargs['ylabel']+': %{y:.2f}<br>'+\
                                  kwargs['zlabel']+': %{z:.2f}<br>'+\
                                  'field: '+f'{layer_value:.2e}',
                    name='',
                    surface=dict(count=3),  # Ensuring only one surface is shown
                    opacity=alpha,
                    scene=ax['sceneN'],
                )

                fig.add_trace(trace)

    if kwargs['colorbar'] and not(ax['colorbar']) and not(kwargs['field_is_nan']):
        ax['colormap_object'] = kwargs['colormap_object']
        fig.add_trace(tool_plotly_colorbar(ax, type='normal'))
        ax['colorbar'] = True



    kwargs['fig'] = fig
    kwargs['ax'] = ax
    tool_set_plot_axis_properties_plotly(self, **kwargs)

    return fig, ax
--- End of file: comfit\plot\plot_field_plotly.py ---

--- Start of file: comfit\plot\plot_nodes_matplotlib.py ---
from typing import TYPE_CHECKING, Any, Dict, List, Tuple

if TYPE_CHECKING:
    from comfit.core.base_system import BaseSystem

import numpy as np
import matplotlib.pyplot as plt

from comfit.tool import (
    tool_set_plot_axis_properties_matplotlib,
    tool_extract_node_arrays,
tool_matplotlib_define_3D_plot_ax
)

def plot_nodes_matplotlib(
        self: 'BaseSystem',
        nodes: List[Dict],
        **kwargs: Any
        ) -> Tuple[plt.Figure, plt.Axes]:
    """Plot the nodes of the system.

    Create a matplotlib plot of the nodes in the system, including their positions,
    charges, velocities and Burgers vectors if available.

    Parameters
    ----------
    self : BaseSystem
        A BaseSystem (or derived) instance.
    nodes : List[Dict]
        List of node dictionaries containing position and property information
    kwargs : Any
        Keyword arguments for customizing the plot. See 
        https://comfitlib.com/ClassBaseSystem/ for full list.

    Returns
    -------
    Tuple[plt.Figure, plt.Axes]
        The figure and axes objects containing the plot
    """

    # Check if an axis object is provided
    fig = kwargs.get('fig', plt.gcf())
    ax = kwargs.get('ax', None)

    # Check if there are nodes to be plotted, if not return the axes
    if not nodes:
        return fig, ax

    node_arrays = tool_extract_node_arrays(self, nodes)
    
    if self.dim == 2:

        if ax == None:
            fig.clf()
            ax = fig.add_subplot(111)

        x_coords = np.array(node_arrays['x_coordinates'])
        y_coords = np.array(node_arrays['y_coordinates'])

        if node_arrays['charge_given']:
            x_coords_positive = np.array(node_arrays['x_coordinates_positive'])
            y_coords_positive = np.array(node_arrays['y_coordinates_positive'])

            ax.scatter(x_coords_positive/self.a0, y_coords_positive/self.a0, marker='+', color='red')

            x_coords_negative = np.array(node_arrays['x_coordinates_negative'])
            y_coords_negative = np.array(node_arrays['y_coordinates_negative'])

            ax.scatter(x_coords_negative/self.a0, y_coords_negative/self.a0, marker='o', color='blue')
            
        else:
            ax.scatter(x_coords/self.a0, y_coords/self.a0, marker='o', color='black')

        if node_arrays['velocity_given']:
            vx_coords = np.array(node_arrays['velocity_x_coordinates'])
            vy_coords = np.array(node_arrays['velocity_y_coordinates'])
            ax.quiver(x_coords/self.a0, y_coords/self.a0, vx_coords, vy_coords, color='black')

        if node_arrays['Burgers_vector_given']:
            Bx_coords = np.array(node_arrays['Burgers_vector_x_coordinates'])
            By_coords = np.array(node_arrays['Burgers_vector_y_coordinates'])
            ax.quiver(x_coords/self.a0, y_coords/self.a0, Bx_coords, By_coords, color='red')

    elif self.dim == 3:
        # Plotting options

        if ax == None:
            fig.clf()
            ax= tool_matplotlib_define_3D_plot_ax(fig, ax)

        quiver_scale = 2 # The scale of the quiver arrows

        x_coords = node_arrays['x_coordinates']
        y_coords = node_arrays['y_coordinates']
        z_coords = node_arrays['z_coordinates']

        if node_arrays['tangent_vector_given']:
            tx = np.array(node_arrays['tangent_vector_x_coordinates'])
            ty = np.array(node_arrays['tangent_vector_y_coordinates'])
            tz = np.array(node_arrays['tangent_vector_z_coordinates'])

            ax.quiver(x_coords, y_coords, z_coords, quiver_scale * tx, quiver_scale * ty, quiver_scale * tz,
                      color='blue')
        
        if node_arrays['velocity_given']:
            vx = np.array(node_arrays['velocity_x_coordinates'])
            vy = np.array(node_arrays['velocity_y_coordinates'])
            vz = np.array(node_arrays['velocity_z_coordinates'])

            v_norm = np.sqrt(vx**2 +vy**2+vz**2)

            ax.quiver(x_coords, y_coords, z_coords, quiver_scale * vx / v_norm, quiver_scale * vy / v_norm,
                      quiver_scale * vz / v_norm, color='green')

        if node_arrays['Burgers_vector_given']:
            Bx = np.array(node_arrays['Burgers_vector_x_coordinates'])
            By = np.array(node_arrays['Burgers_vector_y_coordinates'])
            Bz = np.array(node_arrays['Burgers_vector_z_coordinates'])

            if not len(Bx) == 0:
                B2 = Bx ** 2 + By ** 2 + Bz ** 2
                B_norm = np.sqrt(max(B2))
            else:
                B_norm = 1

            ax.quiver(x_coords, y_coords, z_coords, quiver_scale * Bx / B_norm, quiver_scale * By / B_norm,
                      quiver_scale * Bz / B_norm, color='red')

        if node_arrays['rotation_vector_given']:
            rx = np.array(node_arrays['rotation_vector_x_coordinates'])
            ry = np.array(node_arrays['rotation_vector_y_coordinates'])
            rz = np.array(node_arrays['rotation_vector_z_coordinates'])

            ax.quiver(x_coords, y_coords, z_coords, quiver_scale * rx, quiver_scale * ry, quiver_scale * rz,
                      color='black')



        ax.scatter(x_coords, y_coords, z_coords, marker='o', color='black')


        



    kwargs['fig'] = fig
    kwargs['ax'] = ax
    tool_set_plot_axis_properties_matplotlib(self, **kwargs)

    return fig, ax
--- End of file: comfit\plot\plot_nodes_matplotlib.py ---

--- Start of file: comfit\plot\plot_nodes_plotly.py ---
from typing import TYPE_CHECKING, Any, List, Dict, Tuple

if TYPE_CHECKING:
    from comfit.core.base_system import BaseSystem

import numpy as np

import plotly.graph_objects as go
import plotly.figure_factory as ff

from comfit.tool import (
    tool_set_plot_axis_properties_plotly,
    tool_plotly_define_2D_plot_ax,
    tool_plotly_define_3D_plot_ax,
    tool_extract_node_arrays
)

def plot_nodes_plotly(
    self: 'BaseSystem',
    nodes: List[Dict],
    **kwargs: Any
) -> Tuple[go.Figure, Dict]:
    """Plot the nodes in the system.

    Parameters
    ----------
    self : BaseSystem
        A BaseSystem (or derived) instance.
    nodes : List[Dict]
        A list of dictionaries representing nodes. Each dictionary must contain:
            - 'position': The position of the node in the defect density array
        Optional keys:
            - 'velocity': The velocity of the node
            - 'charge': The charge of the node
            - 'tangent_vector': The tangent of the node (3D only)
            - 'Burgers_vector': The Burgers vector of the node (for dislocations)
    kwargs : Any
        Keyword arguments for the plot. See https://comfitlib.com/ClassBaseSystem/
        for a full list of keyword arguments.

    Returns
    -------
    Tuple[go.Figure, Dict]
        The figure object and axes dictionary containing the plot configuration.
    """

    # Check if an axis object is provided
    fig = kwargs.get('fig', go.Figure())
    ax = kwargs.get('ax', {'row': 1, 'col': 1, 'nrows': 1, 'ncols': 1})

    # Check if there are nodes to be plotted
    if not nodes:
        return fig, ax

    # Extract node arrays
    node_arrays = tool_extract_node_arrays(self, nodes)

    if self.dim == 2:

        ax = tool_plotly_define_2D_plot_ax(fig, ax)

        if node_arrays['charge_given']:
            if len(node_arrays['x_coordinates_negative']) > 0:
                fig.add_trace(go.Scatter(x=np.array(node_arrays['x_coordinates_negative'])/self.a0, 
                                        y=np.array(node_arrays['y_coordinates_negative'])/self.a0, 
                                        mode='markers', 
                                        marker=dict(symbol='star', color='blue'),
                                        showlegend=False,
                                        xaxis=ax['xN'],
                                        yaxis=ax['yN']))

            if len(node_arrays['x_coordinates_positive']) > 0:
                fig.add_trace(go.Scatter(x=np.array(node_arrays['x_coordinates_positive'])/self.a0, 
                                        y=np.array(node_arrays['y_coordinates_positive'])/self.a0, 
                                        mode='markers', 
                                        marker=dict(symbol='cross', color='red'),
                                        showlegend=False, 
                                        xaxis=ax['xN'],
                                        yaxis=ax['yN']))
        
        else: # If no charge is provided, plot all nodes as positive
            fig.add_trace(go.Scatter(x=np.array(node_arrays['x_coordinates'])/self.a0, 
                                    y=np.array(node_arrays['y_coordinates'])/self.a0, 
                                    mode='markers', 
                                    marker=dict(symbol='circle', color='black'),
                                    showlegend=False,
                                    xaxis=ax['xN'],
                                    yaxis=ax['yN']))
        
        # Velocities
        if node_arrays['velocity_given']:
            
            vx = np.array(node_arrays['velocity_x_coordinates'])
            vy = np.array(node_arrays['velocity_y_coordinates'])

            velocity_scale = 0.1*min(self.size_x, self.size_y)/self.a0

            vnorm = np.sqrt(np.max(vx**2 + vy**2))
                
            vx = velocity_scale*vx/vnorm
            vy = velocity_scale*vy/vnorm

            fig1 = ff.create_quiver(x=np.array(node_arrays['x_coordinates'])/self.a0, 
                                    y=np.array(node_arrays['y_coordinates'])/self.a0, 
                                    u=vx, 
                                    v=vy, 
                                    line=dict(width=1, color='black'),
                                    scale=1,
                                    showlegend=False,
                                    xaxis=ax['xN'],
                                    yaxis=ax['yN'])
                
            fig.add_traces(data=fig1.data)

        # Burgers vectors
        if node_arrays['Burgers_vector_given']:

            bvx = np.array(node_arrays['Burgers_vector_x_coordinates'])
            bvy = np.array(node_arrays['Burgers_vector_y_coordinates'])

            Burgers_vector_scale = 0.1*min(self.size_x, self.size_y)/self.a0

            bnorm = np.sqrt(np.max(bvx**2 + bvy**2))
                
            bvx = Burgers_vector_scale*bvx/bnorm
            bvy = Burgers_vector_scale*bvy/bnorm

            fig1 = ff.create_quiver(x=np.array(node_arrays['x_coordinates'])/self.a0, 
                                    y=np.array(node_arrays['y_coordinates'])/self.a0, 
                                    u=bvx, 
                                    v=bvy, 
                                    line=dict(width=1, color='red'),
                                    scale=1,
                                    showlegend=False,
                                    xaxis=ax['xN'],
                                    yaxis=ax['yN'])
                
            fig.add_traces(data=fig1.data)

    elif self.dim == 3:

        ax = tool_plotly_define_3D_plot_ax(fig, ax)

        x = np.array(node_arrays['x_coordinates'])
        y = np.array(node_arrays['y_coordinates'])
        z = np.array(node_arrays['z_coordinates'])

        # Plotting options
        quiver_scale = 2 # The scale of the quiver arrows
        if node_arrays['tangent_vector_given']:

            tx = np.array(node_arrays['tangent_vector_x_coordinates'])
            ty = np.array(node_arrays['tangent_vector_y_coordinates'])
            tz = np.array(node_arrays['tangent_vector_z_coordinates'])

            fig.add_trace(go.Cone(x=x / self.a0,
                                  y=y / self.a0,
                                  z=z / self.a0,
                                  u=tx,
                                  v=ty,
                                  w=tz,
                                  scene=ax['sceneN'],
                                  colorscale='Blues',
                                  sizemode='scaled',
                                  sizeref=0))

        if node_arrays['velocity_given']:

            vx = np.array(node_arrays['velocity_x_coordinates'])
            vy = np.array(node_arrays['velocity_y_coordinates'])
            vz = np.array(node_arrays['velocity_z_coordinates'])

            v2 =vx**2 + vy**2 + vz**2
            v_norm = np.sqrt(max(v2))

            if v_norm > 0:
                vx /= v_norm
                vy /= v_norm
                vz /= v_norm

            fig.add_trace(go.Cone(x=x / self.a0,
                                  y=y / self.a0,
                                  z=z / self.a0,
                                  u=vx,
                                  v=vy,
                                  w=vz,
                                  scene=ax['sceneN'],
                                  colorscale='Greens',
                                  sizemode='scaled',
                                  sizeref=0))

        if node_arrays['rotation_vector_given']:
            rx = np.array(node_arrays['rotation_vector_x_coordinates'])
            ry = np.array(node_arrays['rotation_vector_y_coordinates'])
            rz = np.array(node_arrays['rotation_vector_z_coordinates'])



            fig.add_trace(go.Cone(x=x / self.a0,
                                  y=y / self.a0,
                                  z=z / self.a0,
                                  u=rx,
                                  v=ry,
                                  w=rz,
                                  scene=ax['sceneN'],
                                  colorscale='Reds',
                                  sizemode='scaled',
                                  sizeref=0))

            #ax.scatter(node_arrays['x_coordinates'], node_arrays['y_coordinates'], z_coords, marker='o', color='black')\
            # fig.add_trace(go.Scatter(x=node_arrays['x_coordinates']/self.a0, 
            #                             y=node_arrays['y_coordinates']/self.a0, 
            #                             mode='markers', 
            #                             marker=dict(symbol='circle', color='black')))   #TODO: Check if this works




        

    kwargs['fig'] = fig
    kwargs['ax'] = ax
    tool_set_plot_axis_properties_plotly(self, **kwargs)

    return fig, ax
--- End of file: comfit\plot\plot_nodes_plotly.py ---

--- Start of file: comfit\plot\plot_subplots_matplotlib.py ---
# Standard library imports
from typing import Tuple, Any

# Third-party library imports
import matplotlib.pyplot as plt
import numpy as np


def plot_subplots_matplotlib(
    number_of_rows: int,
    number_of_columns: int
    ) -> Tuple[plt.Figure, plt.Axes]:
    """Create a figure with a grid of subplots.

    Parameters
    ----------
    number_of_rows : int
        Number of rows in the subplot grid.
    number_of_columns : int
        Number of columns in the subplot grid.

    Returns
    -------
    Tuple[plt.Figure, plt.Axes]
        Figure object and array of Axes objects representing the subplots.
    """
    fig, axs = plt.subplots(number_of_rows, number_of_columns)
    return fig, axs
--- End of file: comfit\plot\plot_subplots_matplotlib.py ---

--- Start of file: comfit\plot\plot_subplots_plotly.py ---
from typing import Dict, List, Optional, Any, Tuple

import numpy as np
import plotly.graph_objects as go


def plot_subplots_plotly(
        number_of_rows: int,
        number_of_columns: int
        ) -> Tuple[go.Figure, Dict[str, Any]]:
    """Create a plotly figure with subplots.

    Parameters
    ----------
    number_of_rows : int
        Number of rows in the subplot grid.
    number_of_columns : int
        Number of columns in the subplot grid.

    Returns
    -------
    Tuple[go.Figure, Dict[str, Any]]
        A tuple containing the Plotly figure and axes dictionary.
    """
    fig = go.Figure()
    if number_of_columns == 1:
        axs = np.array([{'row': i+1, 'nrows': number_of_rows, 'col': 1, 'ncols': number_of_columns, 'colorbar': False} for i in range(number_of_rows)])
    elif number_of_rows == 1:
        axs = np.array([{'row': 1, 'nrows': number_of_rows, 'col': i+1, 'ncols': number_of_columns, 'colorbar': False} for i in range(number_of_columns)])
    else:
        axs = np.array([[{'row': i+1, 'nrows': number_of_rows, 'col': j+1, 'ncols': number_of_columns, 'colorbar': False} for j in range(number_of_columns)] for i in range(number_of_rows)])
    return fig, axs
--- End of file: comfit\plot\plot_subplots_plotly.py ---

--- Start of file: comfit\plot\plot_surface_matplotlib.py ---
from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from comfit.core.base_system import BaseSystem

import matplotlib.pyplot as plt
from matplotlib.axes import Axes
import numpy as np
from skimage.measure import marching_cubes

def plot_surface_matplotlib(
        self: 'BaseSystem',
        **kwargs: Any
        ) -> Axes:
    """Plot the surface of the given field.

    Parameters
    ----------
    self : BaseSystem
        A BaseSystem (or derived) instance.
    kwargs : Any
        field : ndarray
            3D array containing the field values
        value : float
            Isosurface value
        ax : matplotlib.axes.Axes, optional
            Axes to plot on. Defaults to current axes.
        alpha : float, optional
            Transparency value. Defaults to 0.5.
        color : str, optional
            Surface color. Defaults to 'b'.

    Returns
    -------
    matplotlib.axes.Axes
        The axes containing the surface plot.
    """
    field = kwargs['field']
    value = kwargs['value']
    ax = kwargs.get('ax', plt.gca())
    
    alpha = kwargs.get('alpha', 0.5)
    color = kwargs.get('color', 'b')

    verts, faces, _, _ = marching_cubes(field, value)

    # Extract coordinates
    x = kwargs.get('x', self.x/self.a0).flatten()
    dx = x[1] - x[0]
    xmax = x[-1]+dx

    y = kwargs.get('y', self.y/self.a0).flatten()
    dy = y[1] - y[0]
    ymax = y[-1]+dy

    z = kwargs.get('z', self.z/self.a0).flatten()
    dz = z[1] - z[0]
    zmax = z[-1]+dz

    ax.plot_trisurf(x[0]+verts[:, 0]*dx, 
                    y[0]+verts[:, 1]*dy, 
                    faces, 
                    z[0]+verts[:, 2]*dz, alpha=alpha, color=color)

    return ax
--- End of file: comfit\plot\plot_surface_matplotlib.py ---

--- Start of file: comfit\plot\plot_surface_plotly.py ---
from typing import TYPE_CHECKING, Any, Dict

if TYPE_CHECKING:
    from comfit.core.base_system import BaseSystem


# Standard library imports
import numpy as np
from skimage.measure import marching_cubes
import scipy as sp

import plotly.graph_objects as go


def plot_surface_plotly(
        self: 'BaseSystem',
        field: np.ndarray,
        value: float,
        alpha: float = 0.5,
        color: str = 'b',
        plt_colormap_object: Any = None,
        hovertemplate: str = None,
        customdata: np.ndarray = None,
        **kwargs: Any
        ) -> go.Mesh3d:
    """Plot the surface of the given field.

    Parameters
    ----------
    self : BaseSystem
        A BaseSystem (or derived) instance.
    field : ndarray
        3D array containing the field values
    value : float
        Isosurface value
    alpha : float, optional
        Transparency value. Defaults to 0.5.
    color : str, optional
        Surface color. Defaults to 'b'.
    hovertemplate : str
        Template for the hover text.
    kwargs : Any
        Plotting keyword arguments.

    Returns
    -------
    go.Mesh3D
        The plotly mesh object containing the surface plot.
    """

    customdata = None

    verts, faces, _, _ = marching_cubes(field, value)
    
    # Calculate the centroids of each triangle
    centroids = np.mean(verts[faces], axis=1)

    # Color according to the angle
    if np.iscomplexobj(color):
        x, y, z = np.mgrid[0:field.shape[0], 0:field.shape[1], 0:field.shape[2]]
        points = np.c_[x.ravel(), y.ravel(), z.ravel()]

        reals = np.real(color)
        imags = np.imag(color)

        interpolation_method = kwargs.get('interpolation_method', 'linear')
        # print("Interpolating points with method ", interpolation_method, ".")
        # print("If this process is slow, consider passing 'interpolation_method='nearest' with the plot_complex_field function.")
        # print("That will speed up the process, but the plot may look less smooth.")
        reals_faces = sp.interpolate.griddata(points, reals.ravel(), centroids, method='nearest')
        imags_faces = sp.interpolate.griddata(points, imags.ravel(), centroids, method='nearest')
        # print("Interpolation done.")

        theta_faces = np.arctan2(imags_faces, reals_faces)

        # Normalize theta values for color mapping
        theta_faces_normalized = (theta_faces + np.pi) / (2*np.pi)

        # Map normalized theta values to colors
        colors = plt_colormap_object(theta_faces_normalized)

        

        theta_faces = np.arctan2(imags_faces, reals_faces)

        hovertemplate=kwargs['xlabel']+': %{x:.2f}<br>'+\
                        kwargs['ylabel']+': %{y:.2f}<br>'+\
                        kwargs['zlabel']+': %{z:.2f}<br>'+\
                        'amplitude: '+ f'{value:.2e}<br>'+\
                        'phase: %{customdata:.2f} π'

        # hovertemplate = kwargs['xlabel']+': %{x:.2f}<br>'+\
        #                 kwargs['ylabel']+': %{y:.2f}<br>'+\
        #                 kwargs['zlabel']+': %{z:.2f}<br>'+\
        #                 'field: '+ f'{value:.2e}'

        customdata = theta_faces/np.pi
        
        # Convert colors to 'rgba()' format required by Plotly
        colors = ['rgba({},{},{},{})'.format(*c) for c in (255*colors).astype(int)]
        color = None

    elif isinstance(alpha,np.ndarray):

        alpha_max = np.max(alpha)
        alpha_min = np.min(alpha)

        max_opacity = 0.9

        if (alpha_max - alpha_min)<1e-6:
            alpha = max_opacity*np.ones_like(alpha)
        else:
            alpha = max_opacity*(alpha - alpha_min) / (alpha_max - alpha_min)

        x, y, z = np.mgrid[0:field.shape[0], 0:field.shape[1], 0:field.shape[2]]
        points = np.c_[x.ravel(), y.ravel(), z.ravel()]

        interpolation_method = kwargs.get('interpolation_method', 'linear')
        valid_centroids = ~np.isnan(centroids).any(axis=1)
        rho_normalized_faces = np.full(centroids.shape[0], np.nan)
        rho_normalized_faces[valid_centroids] = sp.interpolate.griddata(points, alpha.ravel(), centroids[valid_centroids], method='nearest')

        colors =   ['rgba({},{},{},{})'.format(*(np.array([
                    (255*color[0]).astype(int),
                    (255*color[1]).astype(int),
                    (255*color[2]).astype(int),
                    0 if np.isnan(rho_normalized_faces[i]) else rho_normalized_faces[i]
                    ]))) for i in range(len(faces))]
        
        hovertemplate=kwargs['xlabel']+': %{x:.2f}<br>'+\
                        kwargs['ylabel']+': %{y:.2f}<br>'+\
                        kwargs['zlabel']+': %{z:.2f}<br>'+\
                        'amplitude: %{customdata:.2e}<br>' + \
                        'phase: '+ f'{value/np.pi:.2f} π '
        
        customdata = alpha_min + rho_normalized_faces*(alpha_max-alpha_min)

        color = 'rgba({},{},{},{})'.format(*(255*np.array(color)).astype(int)) 
        # color = None
        alpha = None

    else:

        colors = None
        color = 'rgba({},{},{},{})'.format(*(255*np.array(color)).astype(int)) 


    # Extract coordinates
    x = kwargs.get('x', self.x/self.a0).flatten()
    dx = x[1] - x[0]
    xmin = x[0]
    xmax = x[-1]+dx

    y = kwargs.get('y', self.y/self.a0).flatten()
    dy = y[1] - y[0]
    ymin = y[0]
    ymax = y[-1]+dy

    z = kwargs.get('z', self.z/self.a0).flatten()
    dz = z[1] - z[0]
    zmin = z[0]
    zmax = z[-1]+dz

    # Create the mesh object
    x_new = (verts[:, 0] * dx + xmin) 
    y_new = (verts[:, 1] * dy + ymin) 
    z_new = (verts[:, 2] * dz + zmin) 


    if hovertemplate is None:
        hovertemplate = kwargs['xlabel']+': %{x:.2f}<br>'+\
                        kwargs['ylabel']+': %{y:.2f}<br>'+\
                        kwargs['zlabel']+': %{z:.2f}<br>'+\
                        'field: '+ f'{value:.2e}'


    mesh = go.Mesh3d(
                x=x_new, 
                y=y_new, 
                z=z_new,
                i=faces[:, 0], 
                j=faces[:, 1], 
                k=faces[:, 2],
                facecolor=colors,  # Set color for each face
                color=color,
                showscale=False,
                opacity=alpha,
                hovertemplate=hovertemplate,
                customdata=customdata,
                name='',
                scene=kwargs['ax']['sceneN'],
                hoverlabel=dict(
                    bgcolor=color
                )
            )

    return mesh
--- End of file: comfit\plot\plot_surface_plotly.py ---

--- Start of file: comfit\plot\plot_vector_field_in_plane_both_plot_libs.py ---
# Type checking imports
from typing import TYPE_CHECKING, Optional, Any, Tuple

if TYPE_CHECKING:
    from comfit.core.base_system import BaseSystem

# Standard library imports
import numpy as np
import scipy as sp

# Third-party library imports
from skimage.measure import marching_cubes
import plotly.graph_objects as go

# Local application imports
from comfit.tool import (
    tool_matplotlib_define_3D_plot_ax,
    tool_plotly_define_3D_plot_ax,
    tool_set_plot_axis_properties_matplotlib,
    tool_set_plot_axis_properties_plotly,
    tool_plotly_colorbar
)


def plot_vector_field_in_plane_both_plot_libs(
        self: 'BaseSystem',
        vector_field: np.ndarray,
        position: Optional[np.ndarray] = None,
        normal_vector: Optional[np.ndarray] = None,
        spacing: Optional[int] = None,
        **kwargs: Any
        ) -> Tuple[Any, Any]:
    """Plot a vector field on a plane in 3D space.

    Creates a visualization of a vector field where it intersects with a plane
    defined by a point and a normal vector.

    Parameters
    ----------
    self : BaseSystem
        A BaseSystem (or derived) instance.
    vector_field : np.ndarray
        The vector field to plot. Shape must be (1,xRes,yRes,zRes), 
        (2,xRes,yRes,zRes), or (3,xRes,yRes,zRes).
    position : np.ndarray, optional
        Point through which the plane passes. Defaults to system midpoint.
    normal_vector : np.ndarray, optional
        Normal vector defining the plane orientation. Defaults to [1,1,1].
    spacing : int, optional
        Spacing between vectors in the plot. Defaults to max(xRes//20,1).
    kwargs : Any
        Additional keyword arguments for plot customization. See https://comfitlib.com/Plotting/.

    Returns
    -------
    Tuple[Any, Any]
        Figure and axes objects from the plotting library.

    Raises
    ------
    Exception
        If the system is not 3D or if the vector field has invalid dimensions.
    """

    plot_lib = kwargs.get('plot_lib', self.plot_lib)

    if self.dim != 3:
        raise Exception("The plot_vector_field_in_plane function is only defined for 3D fields.")

    vector_field, fig, ax, kwargs = self.plot_prepare(vector_field, field_type = 'vector', **kwargs)

    # Default values of position and normal vector
    if position is None:
        position = self.rmid
    
    if normal_vector is None:
        normal_vector = [1,1,1]

    if spacing is None:
        spacing = max(self.xRes//20,1)

    normal_vector = np.array(normal_vector)/np.linalg.norm(normal_vector)
    height_above_plane = (self.x-position[0])*normal_vector[0] + (self.y-position[1])*normal_vector[1] + (self.z-position[2])*normal_vector[2]

    verts, faces, _, _ = marching_cubes(height_above_plane, 0)

    # Assuming field is defined on the same grid as height_above_plane
    x, y, z = np.mgrid[0:height_above_plane.shape[0], 0:height_above_plane.shape[1], 0:height_above_plane.shape[2]]

    # Flatten the grid for interpolation
    points = np.c_[x.ravel(), y.ravel(), z.ravel()]

    # Extract the vector field
    if vector_field.shape == (1,self.xRes,self.yRes,self.zRes):
        n = 1
    elif vector_field.shape == (2,self.xRes,self.yRes,self.zRes):
        n = 2
    elif vector_field.shape == (3,self.xRes,self.yRes,self.zRes):
        n = 3
    else:
        raise Exception("You have entered an invalid field to the plot_vector_field function.")

    U = vector_field[0]
    U_values = U.ravel()
    U_verts = sp.interpolate.griddata(points, U_values, verts, method='nearest')

    if n > 1:
        V = vector_field[1]
        V_values = V.ravel()
        V_verts = sp.interpolate.griddata(points, V_values, verts, method='nearest')
    else:
        V_verts = np.zeros(U_verts.shape)
    
    if n > 2:
        W = vector_field[2]
        W_values = W.ravel()
        W_verts = sp.interpolate.griddata(points, W_values, verts, method='nearest')
    else:
        W_verts = np.zeros(U_verts.shape)

    # Normalize the vectors
    max_vector = np.max(np.sqrt(U_verts ** 2 + V_verts ** 2 + W_verts ** 2))
    U_verts = U_verts / max_vector
    V_verts = V_verts / max_vector
    W_verts = W_verts / max_vector

    # Scale factors
    vx_scale = kwargs.get('vx_scale', spacing*self.dx)
    vy_scale = kwargs.get('vy_scale', spacing*self.dy)
    vz_scale = kwargs.get('vz_scale', spacing*self.dz)

    # Scaling
    U_verts = vx_scale*U_verts
    V_verts = vy_scale*V_verts
    W_verts = vz_scale*W_verts

    # Extract coordinates
    x = kwargs.get('x', self.x/self.a0).flatten()
    dx = x[1] - x[0]
    xmin = x[0]
    xmax = x[-1]+dx
    
    y = kwargs.get('y', self.y/self.a0).flatten()
    dy = y[1] - y[0]
    ymin = y[0]
    ymax = y[-1]+dy

    z = kwargs.get('z', self.z/self.a0).flatten()
    dz = z[1] - z[0]
    zmin = z[0]
    zmax = z[-1]+dz

    x = xmin+verts[:, 0]*dx
    y = ymin+verts[:, 1]*dy
    z = zmin+verts[:, 2]*dz

    # Add spacing
    x = x[::spacing]
    y = y[::spacing]
    z = z[::spacing]
    U_verts = U_verts[::spacing]
    V_verts = V_verts[::spacing]
    W_verts = W_verts[::spacing]

    if plot_lib == "plotly":

        ax = tool_plotly_define_3D_plot_ax(fig, ax) #Defines sceneN, plot_dimension

        ax['vmin'] = kwargs.get('vmin', 0)
        ax['vmax'] = kwargs.get('vmax', np.max(max_vector))

        if not kwargs['field_is_nan']:
            fig.add_trace(go.Cone(  x=x.flatten(), 
                                    y=x.flatten(), 
                                    z=y.flatten(), 
                                    u=U_verts.flatten(), 
                                    v=V_verts.flatten(), 
                                    w=W_verts.flatten(), 
                                    colorscale=kwargs['colormap_object'], 
                                    sizemode='scaled', 
                                    sizeref=1, 
                                    showscale=False, 
                                    scene = ax['sceneN'],
                                    hovertemplate='<b>x:</b> %{x:.1f} a₀ <br>' +
                                                '<b>ux:</b> %{u:.1f} <br>' +
                                                '<b>uy:</b> %{v:.1f} <br>' +
                                                '<b>uz:</b> %{w:.1f} <br>' +
                                                '<b>|u|:</b> %{customdata:.1f}<extra></extra>',
                                                customdata=np.sqrt(U_verts**2 + V_verts**2 + W_verts**2).flatten()))

        if kwargs['colorbar'] and not(ax['colorbar']) and not(kwargs['field_is_nan']):
            ax['colormap_object'] = kwargs['colormap_object']
            fig.add_trace(tool_plotly_colorbar(ax, type='normal'))
            ax['colorbar'] = True

        kwargs['fig'] = fig
        kwargs['ax'] = ax
        tool_set_plot_axis_properties_plotly(self, **kwargs)

    elif plot_lib == "matplotlib":
        
        ax = tool_matplotlib_define_3D_plot_ax(fig, ax)
        kwargs['plot_is_3D'] = True

        ax.quiver(x, y, z, U_verts, V_verts, W_verts, color='blue')

        kwargs['fig'] = fig
        kwargs['ax'] = ax
        tool_set_plot_axis_properties_matplotlib(self, **kwargs)
    
    return fig, ax
--- End of file: comfit\plot\plot_vector_field_in_plane_both_plot_libs.py ---

--- Start of file: comfit\plot\plot_vector_field_matplotlib.py ---
from typing import TYPE_CHECKING, Any, Tuple, Union, List

if TYPE_CHECKING:
    from comfit.core.base_system import BaseSystem

# Standard library imports
import numpy as np

# Third-party library imports
import matplotlib.pyplot as plt
import matplotlib

# Local application imports
from comfit.tool import (
    tool_complete_field,
    tool_add_spacing_2D,
    tool_add_spacing_3D,
    tool_matplotlib_define_2D_plot_ax,
    tool_matplotlib_define_3D_plot_ax, 
    tool_set_plot_axis_properties_matplotlib
)

def plot_vector_field_matplotlib(
        self: 'BaseSystem',
        vector_field: Union[np.ndarray, List],
        **kwargs: Any
        ) -> Tuple[matplotlib.figure.Figure, matplotlib.axes.Axes]:
    """Plot the vector field using matplotlib.

    Parameters
    ----------
    self : BaseSystem
        A BaseSystem (or derived) instance.
    vector_field : np.ndarray
        Array containing the components of the vector field
    kwargs : Any
        spacing : int, optional. The spacing for the quiver plot which defaults 
        to self.xRes//20. Additional keyword arguments for plot customization, 
        see https://comfitlib.com/Plotting/

    Returns
    -------
    tuple[matplotlib.figure.Figure, matplotlib.axes.Axes]
        Figure and axes containing the plot

    Raises
    ------
    Exception
        If an invalid field is provided to the plot_vector_field function
    """

    spacing = kwargs.get('spacing', max(self.xRes//20,1))

    vector_field, fig, ax, kwargs = self.plot_prepare(vector_field, field_type = 'vector', **kwargs)

    # Extract coordinates
    x = kwargs.get('x', self.x/self.a0).flatten()
    dx = x[1] - x[0]
    xmin = x[0]
    xmax = x[-1]+dx
    
    if self.dim > 1:
        y = kwargs.get('y', self.y/self.a0).flatten()
        dy = y[1] - y[0]
        ymin = y[0]
        ymax = y[-1]+dy

    if self.dim > 2:
        z = kwargs.get('z', self.z/self.a0).flatten()
        dz = z[1] - z[0]
        zmin = z[0]
        zmax = z[-1]+dz


    ###############################################################
    ########### DIMENSION: 1 - VECTOR-DIMENSION: 1 ################
    ###############################################################
        
    if self.dim == 1 and vector_field.shape == (1,self.xRes):

        ax = tool_matplotlib_define_2D_plot_ax(fig, ax)

        X, Y = np.meshgrid(x, np.array([0]), indexing='ij')

        U = np.zeros(X.shape)
        V = np.zeros(X.shape)

        V[:,0] = vector_field[0]

        X,Y,U,V = tool_add_spacing_2D(X,Y,U,V,spacing)

        ax.quiver(X, Y, U, V, color='blue', angles='xy', scale_units='xy', scale=1)
        kwargs['ylim'] = [np.min(vector_field[0]), np.max(vector_field[0])]
        

    ###############################################################
    ########### DIMENSION: 1 - VECTOR-DIMENSION: 2 ################
    ###############################################################

    elif self.dim == 1 and vector_field.shape == (2,self.xRes):

        ax = tool_matplotlib_define_3D_plot_ax(fig, ax)
        kwargs['plot_is_3D'] = True
            
        X, Y, Z = np.meshgrid(x, np.array([0]), np.array([0]), indexing='ij')

        U = np.zeros(X.shape)
        V = np.zeros(X.shape)
        W = np.zeros(X.shape)

        V[:,0,0] = vector_field[0]
        W[:,0,0] = vector_field[1]

        X,Y,Z,U,V,W = tool_add_spacing_3D(X,Y,Z,U,V,W,spacing)

        ax.quiver(X, Y, Z, U, V, W, color='blue')

        kwargs['ylim'] = [np.min(vector_field[0]), np.max(vector_field[0])]
        delta_y = kwargs['ylim'][1] - kwargs['ylim'][0]

        kwargs['zlim'] = [np.min(vector_field[1]), np.max(vector_field[1])]
        delta_z = kwargs['zlim'][1] - kwargs['zlim'][0]

        if delta_y < 0.15*delta_z:
            kwargs['ylim'] = [kwargs['ylim'][0] - 0.15*delta_z, kwargs['ylim'][1] + 0.15*delta_z]
        
        if delta_z < 0.15*delta_y:
            kwargs['zlim'] = [kwargs['zlim'][0] - 0.15*delta_y, kwargs['zlim'][1] + 0.15*delta_y]

    ###############################################################
    ########### DIMENSION: 1 - VECTOR-DIMENSION: 3 ################
    ###############################################################

    elif self.dim == 1 and vector_field.shape == (3,self.xRes):
        
        ax = tool_matplotlib_define_3D_plot_ax(fig, ax)
        kwargs['plot_is_3D'] = True

        X, Y, Z = np.meshgrid(x, np.array([0]), np.array([0]), indexing='ij')

        U = np.zeros(X.shape)
        V = np.zeros(X.shape)
        W = np.zeros(X.shape)

        # Add the vector field
        U[:,0,0] = vector_field[0]
        V[:,0,0] = vector_field[1]
        W[:,0,0] = vector_field[2]

        # Add spacing
        X,Y,Z,U,V,W = tool_add_spacing_3D(X,Y,Z,U,V,W,spacing)

        # Normalize the vectors
        max_vector = np.max(np.sqrt(U ** 2 + V ** 2 + W ** 2))

        # Normalizing
        U = U/max_vector
        V = V/max_vector
        W = W/max_vector

        # Scale factors
        vx_scale = kwargs.get('vx_scale', spacing*self.size_x/15/self.a0)
        vy_scale = kwargs.get('vy_scale', 1)
        vz_scale = kwargs.get('vz_scale', 1)

        # Scaling
        U = vx_scale*U
        V = vy_scale*V
        W = vz_scale*W

        ax.quiver(X, Y, Z, U, V, W, color='blue')

        kwargs['ylim'] = [-1,1]
        kwargs['zlim'] = [-1,1]

    ###############################################################
    ########### DIMENSION: 2 - VECTOR-DIMENSION: 1 ################
    ###############################################################

    elif self.dim == 2 and vector_field.shape == (1,self.xRes,self.yRes):
        
        ax = tool_matplotlib_define_2D_plot_ax(fig, ax)

        X, Y = np.meshgrid(x, y, indexing='ij')

        U = vector_field[0]
        V = np.zeros(X.shape)

        X,Y,U,V = tool_add_spacing_2D(X,Y,U,V,spacing)

        # Normalize the vectors
        max_vector = np.max(np.sqrt(U ** 2))
        
        U = U / max_vector

        # Scale factors
        vx_scale = kwargs.get('vx_scale', spacing*dx)

        # Scaling
        U = vx_scale*U

        ax.quiver(X, Y, U, V, color='blue',
            angles='xy', scale_units='xy', scale=1,
            headwidth=3, headlength=4, headaxislength=3, pivot='middle')

    ###############################################################
    ########### DIMENSION: 2 - VECTOR-DIMENSION: 2 ################
    ###############################################################

    elif self.dim == 2 and vector_field.shape == (2,self.xRes,self.yRes):

        ax = tool_matplotlib_define_2D_plot_ax(fig, ax)

        X, Y = np.meshgrid(x, y, indexing='ij')

        X, Y, U, V = tool_add_spacing_2D(X,Y,vector_field[0],vector_field[1],spacing)

        max_vector = np.max(np.sqrt(U ** 2 + V ** 2))
    
        U = U / max_vector
        V = V / max_vector

        # Scale factors
        vx_scale = kwargs.get('vx_scale', 1.0*spacing*dx)
        vy_scale = kwargs.get('vy_scale', 1.0*spacing*dy)

        # Scaling
        U = vx_scale*U
        V = vy_scale*V

        ax.quiver(X, Y, U, V, color='blue', 
            angles='xy', scale_units='xy', scale=1,
            headwidth=3, headlength=4, headaxislength=3, pivot='middle')


    ###############################################################
    ########### DIMENSION: 2 - VECTOR-DIMENSION: 3 ################
    ###############################################################

    elif self.dim == 2 and vector_field.shape == (3,self.xRes,self.yRes):

        ax = tool_matplotlib_define_3D_plot_ax(fig, ax)
        kwargs['plot_is_3D'] = True
        
        X, Y, Z = np.meshgrid(x, y, np.array([0]), indexing='ij')
        U = np.zeros(X.shape)
        V = np.zeros(X.shape)
        W = np.zeros(X.shape)
        
        U[:,:,0] = vector_field[0]
        V[:,:,0] = vector_field[1]
        W[:,:,0] = vector_field[2]

        X,Y,Z,U,V,W = tool_add_spacing_3D(X,Y,Z,U,V,W,spacing)

        max_vector = np.max(np.sqrt(U ** 2 + V ** 2 + W ** 2))

        # Normalizing
        U = U / max_vector
        V = V / max_vector
        W = W / max_vector
        
        # Scale factors
        vx_scale = kwargs.get('vx_scale', 2*spacing*self.size_x/max_vector)
        vy_scale = kwargs.get('vy_scale', 2*spacing*self.size_y/max_vector)
        vz_scale = kwargs.get('vz_scale', spacing)

        # Scaling
        U = vx_scale*U
        V = vy_scale*V
        W = vz_scale*W 
        
        ax.quiver(X, Y, Z, U, V, W, color='blue')
       
        kwargs['axis_equal'] = False
        kwargs['zlim'] = [-spacing,spacing]


    ###############################################################
    ########### DIMENSION: 3 - VECTOR-DIMENSION: 1 ################
    ###############################################################

    elif self.dim == 3 and vector_field.shape == (1,self.xRes,self.yRes,self.zRes):

        ax = tool_matplotlib_define_3D_plot_ax(fig, ax)
        kwargs['plot_is_3D'] = True

        X, Y, Z = np.meshgrid(x, y, z, indexing='ij')              

        # Define the vector field
        U = vector_field[0]
        V = np.zeros(U.shape)
        W = np.zeros(U.shape)

        # Add spacing
        X,Y,Z,U,V,W = tool_add_spacing_3D(X,Y,Z,U,V,W,spacing)

        # Normalize the vectors
        max_vector = np.max(np.sqrt(U ** 2))
        U = U / max_vector

        # Scale factors
        vx_scale = kwargs.get('vx_scale', spacing*dx)

        # Scaling
        U = vx_scale*U

        ax.quiver(X, Y, Z, U, V, W, color='blue')
        
    ###############################################################
    ########### DIMENSION: 3 - VECTOR-DIMENSION: 2 ################
    ###############################################################

    elif self.dim == 3 and vector_field.shape == (2,self.xRes,self.yRes,self.zRes):

        ax = tool_matplotlib_define_3D_plot_ax(fig, ax)
        kwargs['plot_is_3D'] = True

        X, Y, Z = np.meshgrid(x, y, z, indexing='ij')

        # Define the vector field
        U = vector_field[0]
        V = vector_field[1]
        W = np.zeros(U.shape)

        # Add spacing
        X,Y,Z,U,V,W = tool_add_spacing_3D(X,Y,Z,U,V,W,spacing)

        # Normalize the vectors
        max_vector = np.max(np.sqrt(U ** 2 + V ** 2))
        U = U / max_vector
        V = V / max_vector

        # Scale factors
        vx_scale = kwargs.get('vx_scale', spacing*dx)
        vy_scale = kwargs.get('vy_scale', spacing*dy)

        # Scaling
        U = vx_scale*U
        V = vy_scale*V
        

        ax.quiver(X, Y, Z, U, V, W, color='blue')
        
   
    ###############################################################
    ########### DIMENSION: 3 - VECTOR-DIMENSION: 3 ################
    ###############################################################

    elif self.dim == 3 and vector_field.shape == (3,self.xRes,self.yRes,self.zRes):

        ax = tool_matplotlib_define_3D_plot_ax(fig, ax)
        kwargs['plot_is_3D'] = True

        X, Y, Z = np.meshgrid(x, y, z, indexing='ij')

        # Define the vector field
        U = vector_field[0]
        V = vector_field[1]
        W = vector_field[2]

        X,Y,Z,U,V,W = tool_add_spacing_3D(X,Y,Z,U,V,W,spacing)



        

        # Normalize the vectors
        max_vector = np.max(np.sqrt(U ** 2 + V ** 2 + W ** 2))

        U = U / max_vector
        V = V / max_vector
        W = W / max_vector

        # Scale factors
        vx_scale = kwargs.get('vx_scale', spacing*dx)
        vy_scale = kwargs.get('vy_scale', spacing*dy)
        vz_scale = kwargs.get('vz_scale', spacing*dz)

        # Scaling
        U = vx_scale*U
        V = vy_scale*V
        W = vz_scale*W
        
        ax.quiver(X, Y, Z, U, V, W, color='blue')
        

    ###############################################################
    ###########     NON-VALID DIMENSION            ################
    ###############################################################

    else:
        raise Exception("You have entered an invalid field to the plot_vector_field function.")

    kwargs['ax'] = ax
    tool_set_plot_axis_properties_matplotlib(self, **kwargs)
    return fig, ax

--- End of file: comfit\plot\plot_vector_field_matplotlib.py ---

--- Start of file: comfit\plot\plot_vector_field_plotly.py ---
from typing import TYPE_CHECKING, Any, Tuple, Union, List

if TYPE_CHECKING:
    from comfit.core.base_system import BaseSystem

# Standard library imports
from typing import Optional, Union

# Third-party imports
import numpy as np
import plotly.graph_objects as go

# Local imports
from comfit.tool.tool_set_plot_axis_properties_plotly import tool_set_plot_axis_properties_plotly
from comfit.tool import (
    tool_complete_field,
    tool_add_spacing_2D,
    tool_add_spacing_3D,
    tool_plotly_define_2D_plot_ax,
    tool_plotly_define_3D_plot_ax,
    tool_plotly_colorbar
)

def plot_vector_field_plotly(
        self: 'BaseSystem',
        vector_field: Union[np.ndarray, List],
        **kwargs: Any
        ) -> Tuple[go.Figure, dict]:
    """Plot the vector field using Plotly.

    Parameters
    ----------
    self : BaseSystem
        A BaseSystem (or derived) instance.
    vector_field : np.ndarray
        Array containing the vector field components. Shape depends on dimensionality.
    kwargs : Any
        spacing : int, optional. The spacing for the quiver plot. Defaults to max(self.xRes//20, 1).
        Additional keyword arguments for plot customization, see https://comfitlib.com/Plotting/

    Returns
    -------
    Tuple[go.Figure, dict]
        The figure containing the plot and the axes dictionary containing plot properties.

    Raises
    ------
    Exception
        If an invalid field is provided to the plot_vector_field function.
    """

    spacing = kwargs.get('spacing', max(self.xRes//20,1))

    vector_field, fig, ax, kwargs = self.plot_prepare(vector_field, field_type = 'vector', **kwargs)


    # Extract coordinates
    x = kwargs.get('x', self.x/self.a0).flatten()
    dx = x[1] - x[0]
    xmin = x[0]
    xmax = x[-1]+dx
    
    if self.dim > 1:
        y = kwargs.get('y', self.y/self.a0).flatten()
        dy = y[1] - y[0]
        ymin = y[0]
        ymax = y[-1]+dy

    if self.dim > 2:
        z = kwargs.get('z', self.z/self.a0).flatten()
        dz = z[1] - z[0]
        zmin = z[0]
        zmax = z[-1]+dz

    ###############################################################
    ########### DIMENSION: 1 - VECTOR-DIMENSION: 1 ################
    ###############################################################
        
    if self.dim == 1 and vector_field.shape == (1,self.xRes):

        kwargs['colorbar'] = False
        ax = tool_plotly_define_2D_plot_ax(fig, ax)
        
        X, Y = np.meshgrid(x, np.array([0]), indexing='ij')
        
        U = np.zeros(X.shape)
        V = np.zeros(X.shape)

        V[:,0] = vector_field[0]

        X,Y,U,V = tool_add_spacing_2D(X,Y,U,V,spacing)
        
        fig, ax = self.plot_field(vector_field[0], **kwargs)

        
    ###############################################################
    ########### DIMENSION: 1 - VECTOR-DIMENSION: 2 ################
    ###############################################################

    elif self.dim == 1 and vector_field.shape == (2,self.xRes):

        ax = tool_plotly_define_3D_plot_ax(fig, ax)
            
        X, Y, Z = np.meshgrid(x, np.array([0]), np.array([0]), indexing='ij')

        U = np.zeros(X.shape)
        V = np.zeros(X.shape)
        W = np.zeros(X.shape)

        V[:,0,0] = vector_field[0]
        W[:,0,0] = vector_field[1]

        ax['vmin'] = kwargs.get('vmin', 0)
        ax['vmax'] = kwargs.get('vmax', np.max(np.sqrt(vector_field[0]**2 + vector_field[1]**2)))

        X,Y,Z,U,V,W = tool_add_spacing_3D(X,Y,Z,U,V,W,spacing)

        if not kwargs['field_is_nan']:
            fig.add_trace(go.Cone(x=X.flatten(), 
                                    y=Y.flatten(), 
                                    z=Z.flatten(), 
                                    u=U.flatten(), 
                                    v=V.flatten(), 
                                    w=W.flatten(), 
                                    colorscale=kwargs['colormap_object'], 
                                    sizemode='scaled', 
                                    sizeref=1, 
                                    showscale=False,
                                    scene = ax['sceneN'],
                                    hovertemplate='x: %{x:.1f} a₀ <br>' +
                                                'ux: %{u:.1f} <br>' +
                                                'uy: %{v:.1f} <br>' +
                                                'uz: %{w:.1f} <br>' +
                                                '|u|: %{customdata:.1f}<extra></extra>',
                                                customdata=np.sqrt(U**2 + V**2 + W**2).flatten()))



        # kwargs['ylim'] = [np.min(vector_field[0]), np.max(vector_field[0])]
        # delta_y = kwargs['ylim'][1] - kwargs['ylim'][0]

        # kwargs['zlim'] = [np.min(vector_field[1]), np.max(vector_field[1])]
        # delta_z = kwargs['zlim'][1] - kwargs['zlim'][0]

        # if delta_y < 0.15*delta_z:
        #     kwargs['ylim'] = [kwargs['ylim'][0] - 0.15*delta_z, kwargs['ylim'][1] + 0.15*delta_z]
        
        # if delta_z < 0.15*delta_y:
        #     kwargs['zlim'] = [kwargs['zlim'][0] - 0.15*delta_y, kwargs['zlim'][1] + 0.15*delta_y]

    ###############################################################
    ########### DIMENSION: 1 - VECTOR-DIMENSION: 3 ################
    ###############################################################

    elif self.dim == 1 and vector_field.shape == (3,self.xRes):
        

        ax = tool_plotly_define_3D_plot_ax(fig, ax)
        
        X, Y, Z = np.meshgrid(x, np.array([0]), np.array([0]), indexing='ij')

        U = np.zeros(X.shape)
        V = np.zeros(X.shape)
        W = np.zeros(X.shape)

        # Add the vector field
        U[:,0,0] = vector_field[0]
        V[:,0,0] = vector_field[1]
        W[:,0,0] = vector_field[2]

        # Add spacing
        X,Y,Z,U,V,W = tool_add_spacing_3D(X,Y,Z,U,V,W,spacing)

        # Normalize the vectors
        max_vector = np.max(np.sqrt(U ** 2 + V ** 2 + W ** 2))

        ax['vmin'] = kwargs.get('vmin', 0)
        ax['vmax'] = kwargs.get('vmax', np.max(max_vector))

        # Normalizing
        U = U/max_vector
        V = V/max_vector
        W = W/max_vector

        # Scale factors
        vx_scale = kwargs.get('vx_scale', spacing*self.size_x/15)
        vy_scale = kwargs.get('vy_scale', 1)
        vz_scale = kwargs.get('vz_scale', 1)

        # Scaling
        U = vx_scale*U
        V = vy_scale*V
        W = vz_scale*W

        if not kwargs['field_is_nan']:
            fig.add_trace(go.Cone(x=X.flatten(), 
                            y=Y.flatten(), 
                            z=Z.flatten(), 
                            u=U.flatten(), 
                            v=V.flatten(), 
                            w=W.flatten(), 
                            colorscale=kwargs['colormap_object'], 
                            sizemode='scaled', 
                            sizeref=1, 
                            showscale=False, 
                            scene = ax['sceneN'],
                            hovertemplate='<b>x:</b> %{x:.1f} a₀ <br>' +
                                        '<b>ux:</b> %{u:.1f} <br>' +
                                        '<b>uy:</b> %{v:.1f} <br>' +
                                        '<b>uz:</b> %{w:.1f} <br>' +
                                        '<b>|u|:</b> %{customdata:.1f}<extra></extra>',
                                        customdata=np.sqrt(U**2 + V**2 + W**2).flatten()))

        # kwargs['axis_equal'] = False
        # kwargs['ylim'] = [-1,1]
        # kwargs['zlim'] = [-1,1]

    ###############################################################
    ########### DIMENSION: 2 - VECTOR-DIMENSION: 1 ################
    ###############################################################

    elif self.dim == 2 and vector_field.shape == (1,self.xRes,self.yRes):
  
        ax = tool_plotly_define_2D_plot_ax(fig, ax)

        X, Y = np.meshgrid(x, y, indexing='ij')

        U = vector_field[0]
        V = np.zeros(X.shape)

        X,Y,U,V = tool_add_spacing_2D(X,Y,U,V,spacing)

        # Normalize the vectors
        max_vector = np.max(np.sqrt(U ** 2))
        
        ax['vmin'] = kwargs.get('vmin', 0)
        ax['vmax'] = kwargs.get('vmax', np.max(max_vector))

        U = U / max_vector

        # Scale factors
        vx_scale = kwargs.get('vx_scale', spacing*dx)

        # Scaling
        U = vx_scale*U

        
        fig = kwargs.get('fig', go.Figure())

        u = U.flatten()
        v = V.flatten()
        
        magnitude = np.sqrt(u**2 + v**2)
        magnitude_normalized = magnitude/max(np.max(magnitude),1e-12)

        angle = np.arctan2(v, u)
        direction = np.array([np.cos(angle), np.sin(angle)]).T
        
        fig.add_trace(go.Scatter(
        x=X.flatten(),
        y=Y.flatten(),
        xaxis=ax['xN'],
        yaxis=ax['yN'],
        mode='markers',
        showlegend=False,
        marker=dict(symbol='arrow', 
            angle=90-angle.flatten()*180/np.pi, 
            size=2*spacing*magnitude_normalized.flatten(), 
            sizemode='diameter',
            color=magnitude.flatten(), 
            colorscale=kwargs['colormap_object'], 
            showscale=False,
            line=dict(color='black')
            ),
            hovertemplate='<b>x:</b> %{x:.1f}a0<br>' +
                        '<b>y:</b> %{y:.1f}a0<br>' +
                        '<b>ux:</b> %{customdata[0]:.2f}<br>' +
                        '<b>uy:</b> %{customdata[1]:.2f}<br>' +
                        '<b>|u|:</b> %{customdata[2]:.2f}<extra></extra>',
            customdata=np.stack((u.flatten(), v.flatten(),magnitude.flatten() ), axis=-1)  # Adding ux, uy and u as customdata
        )
        )

    ###############################################################
    ########### DIMENSION: 2 - VECTOR-DIMENSION: 2 ################
    ###############################################################

    elif self.dim == 2 and vector_field.shape == (2,self.xRes,self.yRes):

        ax = tool_plotly_define_2D_plot_ax(fig, ax)

        X, Y = np.meshgrid(x, y, indexing='ij')

        X, Y, U, V = tool_add_spacing_2D(X,Y,vector_field[0],vector_field[1],spacing)

        u = U.flatten()
        v = V.flatten()
        
        magnitude = np.sqrt(u**2 + v**2)

        ax['vmin'] = kwargs.get('vmin', 0)
        ax['vmax'] = kwargs.get('vmax', np.max(magnitude))

        magnitude_max = max(np.max(magnitude),1e-12)
        magnitude_normalized = magnitude/magnitude_max

        angle = np.arctan2(v, u)
        direction = np.array([np.cos(angle), np.sin(angle)]).T
        
        if not kwargs['field_is_nan']:
            fig.add_trace(go.Scatter(
            x=X.flatten(),
            y=Y.flatten(),
            mode='markers',
            xaxis=ax['xN'],
            yaxis=ax['yN'],
            showlegend=False,
            marker=dict(symbol='arrow', 
                angle=90-angle.flatten()*180/np.pi, 
                size=4*spacing*magnitude_normalized.flatten(), 
                sizemode='diameter',
                color=magnitude.flatten(), 
                colorscale=kwargs['colormap_object'], 
                showscale=False,
                cmin=0,
                cmax=magnitude_max,
                line=dict(color='black')
                ),
                hovertemplate='<b>x:</b> %{x:.2f}a0<br>' +
                    '<b>y:</b> %{y:.2f}a0<br>' +
                    '<b>ux:</b> %{customdata[0]:.2e}<br>' +  
                    '<b>uy:</b> %{customdata[1]:.2e}<br>' +
                    '<b>|u|:</b> %{customdata[2]:.2e}<extra></extra>',
                customdata=np.stack((u.flatten(), v.flatten(), magnitude.flatten()), axis=-1)  # Adding ux, uy and u as customdata
            )
            )


    ###############################################################
    ########### DIMENSION: 2 - VECTOR-DIMENSION: 3 ################
    ###############################################################

    elif self.dim == 2 and vector_field.shape == (3,self.xRes,self.yRes):

        ax = tool_plotly_define_3D_plot_ax(fig, ax)
        
        X, Y, Z = np.meshgrid(x, y, np.array([0]), indexing='ij')
        U = np.zeros(X.shape)
        V = np.zeros(X.shape)
        W = np.zeros(X.shape)
        
        U[:,:,0] = vector_field[0]
        V[:,:,0] = vector_field[1]
        W[:,:,0] = vector_field[2]

        X,Y,Z,U,V,W = tool_add_spacing_3D(X,Y,Z,U,V,W,spacing)

        max_vector = np.max(np.sqrt(U ** 2 + V ** 2 + W ** 2))

        ax['vmin'] = kwargs.get('vmin', 0)
        ax['vmax'] = kwargs.get('vmax', np.max(max_vector))

        # Normalizing
        U = U / max_vector
        V = V / max_vector
        W = W / max_vector
        
        # Scale factors
        vx_scale = kwargs.get('vx_scale', 2*spacing*self.size_x/max_vector)
        vy_scale = kwargs.get('vy_scale', 2*spacing*self.size_y/max_vector)
        vz_scale = kwargs.get('vz_scale', spacing)

        # Scaling
        U = vx_scale*U
        V = vy_scale*V
        W = vz_scale*W

        if not kwargs['field_is_nan']:
            fig.add_trace(go.Cone(x=X.flatten(), 
                                y=Y.flatten(), 
                                z=Z.flatten(), 
                                u=U.flatten(), 
                                v=V.flatten(), 
                                w=W.flatten(), 
                                colorscale=kwargs['colormap_object'], 
                                sizemode='scaled', 
                                sizeref=1, 
                                showscale=False,
                                scene=ax['sceneN'],
                                hovertemplate='<b>x:</b> %{x:.1f} a₀ <br>' +
                                                '<b>y:</b> %{y:.1f} a₀ <br>' +
                                                '<b>z:</b> %{z:.1f} a₀ <br>' +
                                                '<b>ux:</b> %{u:.1f} <br>' +
                                                '<b>uy:</b> %{v:.1f} <br>' +
                                                '<b>uz:</b> %{w:.1f} <br>' +
                                                '<b>|u|:</b> %{customdata:.1f}<extra></extra>',
                                                customdata=np.sqrt(U**2 + V**2 + W**2).flatten()))



        kwargs['axis_equal'] = False
        kwargs['zlim'] = [-spacing,spacing]


    ###############################################################
    ########### DIMENSION: 3 - VECTOR-DIMENSION: 1 ################
    ###############################################################

    elif self.dim == 3 and vector_field.shape == (1,self.xRes,self.yRes,self.zRes):

        ax = tool_plotly_define_3D_plot_ax(fig, ax)

        X, Y, Z = np.meshgrid(x, y, z, indexing='ij')              

        # Define the vector field
        U = vector_field[0]
        V = np.zeros(U.shape)
        W = np.zeros(U.shape)

        # Add spacing
        X,Y,Z,U,V,W = tool_add_spacing_3D(X,Y,Z,U,V,W,spacing)

        # Normalize the vectors
        max_vector = np.max(np.sqrt(U ** 2))

        ax['vmin'] = kwargs.get('vmin', 0)
        ax['vmax'] = kwargs.get('vmax', np.max(max_vector))

        U = U / max_vector

        # Scale factors
        vx_scale = kwargs.get('vx_scale', spacing*dx)

        # Scaling
        U = vx_scale*U

        if not kwargs['field_is_nan']:
            fig.add_trace(go.Cone(x=X.flatten(), 
                                    y=Y.flatten(), 
                                    z=Z.flatten(), 
                                    u=U.flatten(), 
                                    v=V.flatten(), 
                                    w=W.flatten(), 
                                    colorscale=kwargs['colormap_object'], 
                                    sizemode='scaled', 
                                    sizeref=1, 
                                    showscale=False,
                                    scene=ax['sceneN'],
                                    hovertemplate='<b>x:</b> %{x:.1f} a₀ <br>' +
                                                    '<b>y:</b> %{y:.1f} a₀ <br>' +
                                                    '<b>z:</b> %{z:.1f} a₀ <br>' +
                                                    '<b>ux:</b> %{u:.1f} <br>' +
                                                    '<b>uy:</b> %{v:.1f} <br>' +
                                                    '<b>uz:</b> %{w:.1f} <br>' +
                                                    '<b>|u|:</b> %{customdata:.1f}<extra></extra>',
                                                    customdata=np.sqrt(U**2 + V**2 + W**2).flatten()))

    ###############################################################
    ########### DIMENSION: 3 - VECTOR-DIMENSION: 2 ################
    ###############################################################

    elif self.dim == 3 and vector_field.shape == (2,self.xRes,self.yRes,self.zRes):

        ax = tool_plotly_define_3D_plot_ax(fig, ax)

        X, Y, Z = np.meshgrid(x, y, z, indexing='ij')

        # Define the vector field
        U = vector_field[0]
        V = vector_field[1]
        W = np.zeros(U.shape)

        # Add spacing
        X,Y,Z,U,V,W = tool_add_spacing_3D(X,Y,Z,U,V,W,spacing)

        # Normalize the vectors
        max_vector = np.max(np.sqrt(U ** 2 + V ** 2))

        ax['vmin'] = kwargs.get('vmin', 0)
        ax['vmax'] = kwargs.get('vmax', np.max(max_vector))

        U = U / max_vector
        V = V / max_vector

        # Scale factors
        vx_scale = kwargs.get('vx_scale', spacing*dx)
        vy_scale = kwargs.get('vy_scale', spacing*dy)

        # Scaling
        U = vx_scale*U
        V = vy_scale*V

        if not kwargs['field_is_nan']:
            fig.add_trace(go.Cone(x=X.flatten(), 
                                    y=Y.flatten(), 
                                    z=Z.flatten(), 
                                    u=U.flatten(), 
                                    v=V.flatten(), 
                                    w=W.flatten(), 
                                    colorscale=kwargs['colormap_object'], 
                                    sizemode='scaled', 
                                    sizeref=1, 
                                    showscale=False,
                                    scene=ax['sceneN'],
                                    hovertemplate='<b>x:</b> %{x:.1f} a₀ <br>' +
                                                    '<b>y:</b> %{y:.1f} a₀ <br>' +
                                                    '<b>z:</b> %{z:.1f} a₀ <br>' +
                                                    '<b>ux:</b> %{u:.1f} <br>' +
                                                    '<b>uy:</b> %{v:.1f} <br>' +
                                                    '<b>uz:</b> %{w:.1f} <br>' +
                                                    '<b>|u|:</b> %{customdata:.1f}<extra></extra>',
                                                    customdata=np.sqrt(U**2 + V**2 + W**2).flatten()))

    ###############################################################
    ########### DIMENSION: 3 - VECTOR-DIMENSION: 3 ################
    ###############################################################

    elif self.dim == 3 and vector_field.shape == (3,self.xRes,self.yRes,self.zRes):

        ax = tool_plotly_define_3D_plot_ax(fig, ax)

        X, Y, Z = np.meshgrid(x, y, z, indexing='ij')

        # Define the vector field
        U = vector_field[0]
        V = vector_field[1]
        W = vector_field[2]

        X,Y,Z,U,V,W = tool_add_spacing_3D(X,Y,Z,U,V,W,spacing)

        max_vector = np.max(np.sqrt(U ** 2 + V ** 2 + W ** 2))
        ax['vmin'] = kwargs.get('vmin', 0)
        ax['vmax'] = kwargs.get('vmax', np.max(max_vector))

        if not kwargs['field_is_nan']:
            fig.add_trace(go.Cone(x=X.flatten(), 
                                    y=Y.flatten(), 
                                    z=Z.flatten(), 
                                    u=U.flatten(), 
                                    v=V.flatten(), 
                                    w=W.flatten(), 
                                    colorscale=kwargs['colormap_object'], 
                                    sizemode='scaled', 
                                    sizeref=1, 
                                    showscale=False,
                                    scene=ax['sceneN'],
                                    hovertemplate='<b>x:</b> %{x:.1f} a₀ <br>' +
                                                    '<b>y:</b> %{y:.1f} a₀ <br>' +
                                                    '<b>z:</b> %{z:.1f} a₀ <br>' +
                                                    '<b>ux:</b> %{u:.1f} <br>' +
                                                    '<b>uy:</b> %{v:.1f} <br>' +
                                                    '<b>uz:</b> %{w:.1f} <br>' +
                                                    '<b>|u|:</b> %{customdata:.1f}<extra></extra>',
                                                    customdata=np.sqrt(U**2 + V**2 + W**2).flatten()))

    ###############################################################
    ###########     NON-VALID DIMENSION            ################
    ###############################################################

    else:
        raise Exception("You have entered an invalid field to the plot_vector_field function.")


    if kwargs['colorbar'] and not(ax['colorbar']) and not(kwargs['field_is_nan']):
        ax['colormap_object'] = kwargs['colormap_object']
        fig.add_trace(tool_plotly_colorbar(ax, type='normal'))
        ax['colorbar'] = True

    kwargs['fig'] = fig
    kwargs['ax'] = ax
    tool_set_plot_axis_properties_plotly(self, **kwargs)
    return fig, ax
--- End of file: comfit\plot\plot_vector_field_plotly.py ---

--- Start of file: comfit\plot\__init__.py ---
from .plot_field_plotly import plot_field_plotly
from .plot_field_matplotlib import plot_field_matplotlib

from .plot_complex_field_matplotlib import plot_complex_field_matplotlib
from .plot_complex_field_plotly import plot_complex_field_plotly

from .plot_angle_field_matplotlib import plot_angle_field_matplotlib
from .plot_angle_field_plotly import plot_angle_field_plotly

from .plot_vector_field_plotly import plot_vector_field_plotly
from .plot_vector_field_matplotlib import plot_vector_field_matplotlib

from .plot_field_in_plane_plotly import plot_field_in_plane_plotly
from .plot_field_in_plane_matplotlib import plot_field_in_plane_matplotlib

from .plot_complex_field_in_plane_plotly import plot_complex_field_in_plane_plotly
from .plot_complex_field_in_plane_matplotlib import plot_complex_field_in_plane_matplotlib

from .plot_vector_field_in_plane_both_plot_libs import plot_vector_field_in_plane_both_plot_libs

from .plot_nodes_matplotlib import plot_nodes_matplotlib
from .plot_nodes_plotly import plot_nodes_plotly

from .plot_subplots_matplotlib import plot_subplots_matplotlib
from .plot_subplots_plotly import plot_subplots_plotly

from .plot_surface_matplotlib import plot_surface_matplotlib
from .plot_surface_plotly import plot_surface_plotly
--- End of file: comfit\plot\__init__.py ---

--- Start of file: comfit\quantum_mechanics\quantum_mechanics.py ---
from typing import Optional, Union, Literal, TYPE_CHECKING, List, Dict, Any

# General packages
import numpy as np
import matplotlib.pyplot as plt
import scipy as sp

# Local packages
from comfit.core import BaseSystem
from comfit.tool import tool_colormap

class QuantumMechanics(BaseSystem):
    def __init__(self : 'QuantumMechanics', 
            dimension: int, 
            **kwargs: Dict[str, Any]
            ) -> None:
        """Initializes a quamtum mechanics system evolving according to the Schrödinger equation

        Parameters
        ----------
        dimension : int
            The dimension of the system.
        kwargs : dict, optional
            Optional keyword arguments to set additional parameters. 
            See https://comfitlib.com/ClassBaseSystem/.

        Examples
        --------
        >>> qm = cf.QuantumMechanics(3,xRes=101,yRes=101,zRes=101)
        Creates a BoseEinsteinCondensate system with 3 dimensions and a spatial resolution of 101.
        """

        # First initialize the BaseSystem class
        super().__init__(dimension, **kwargs)

        # Type of the system
        self.psi = None
        self.psi_f = None
        self.type = 'QuantumMechanics1' #Quantum mechanical system with one particle.

        # Default simulation parameters
        self.V_ext = 0  # External potential

        # If there are additional arguments provided, set them as attributes
        for key, value in kwargs.items():
            setattr(self, key, value)

    def __str__(
        self: 'QuantumMechanics',
        ) -> str:
        """Returns a string representation of the QuantumMechanics system.

        This method is called when str() is invoked on an instance of the class.

        Returns
        -------
        str: String representation 'QuantumMechanics' of the system
        """
        return 'QuantumMechanics'

    def conf_initial_condition_Gaussian(
            self : 'QuantumMechanics',
            position: Optional[Union[List[float], np.ndarray]] = None,
            width: Optional[float] = None,
            initial_velocity: Optional[Union[float, list[float]]] = None
            ) -> None:
        """Set the initial condition to a Gaussian wavepacket.

        Parameters
        ----------
        position : array_like, optional
            The position of the wavepacket.
        width : float, optional
            The width of the wavepacket.
        initial_velocity : float or array_like, optional
            The initial velocity of the wavepacket.

        Returns
        -------
        None
            Configures self.psi and self.psi_f.
        """

        if position is None:
            position = self.rmid
        if width is None:
            width = self.size_x/10

        self.psi = np.sqrt(self.calc_Gaussian(position=position,width=width))
        
        if initial_velocity is not None:
            if self.dim == 1:
                v0 = initial_velocity
                self.psi = self.psi * np.exp(1j * v0 * self.x)

            elif self.dim == 2:
                v0 = initial_velocity
                self.psi = self.psi * np.exp(1j * (v0[0] * self.x + v0[1] * self.y))

            elif self.dim == 3:
                v0 = initial_velocity
                self.psi = self.psi * np.exp(1j * (v0[0] * self.x + v0[1] * self.y + v0[2] * self.z))
        
        self.psi_f = sp.fft.fftn(self.psi)


    def conf_harmonic_potential(
            self : 'QuantumMechanics', 
            trapping_strength: Optional[float] = None
            ) -> None:
        """Set the external potential to a harmonic trap with R_tf being the thomas fermi radius
        
        Parameters
        ----------
        trapping_strength : float, optional
            The strength of the trapping potential.

        Returns
        -------
        None       
            Configures self.V_ext.
        """

        if trapping_strength is None:
            trapping_strength = 1/(0.25*self.size_x)**2

        if self.dim == 1:
            return  trapping_strength*(self.x - self.xmid )**2

        if self.dim == 2:
            return trapping_strength*(((self.x-self.xmid)**2) +((self.y-self.ymid)**2) )
        if self.dim == 3:
            return trapping_strength * (((self.x - self.xmid) ** 2)
                                           + ((self.y - self.ymid) ** 2)
                                           +((self.z - self.zmid) ** 2) )

    def conf_hydrogen_state(
            self: 'QuantumMechanics', 
            n: int, 
            l: int, 
            m: int
            ) -> None:
        """Set the initial condition to a hydrogen state with quantum numbers n,l,m

        Parameters
        ----------
        n : int 
            principal quantum number
        l : int
            azimuthal quantum number
        m : int 
            magnetic quantum number

        Returns
        -------
        None
            Configures self.psi and self.psi_f.
        """

        self.psi = self.calc_hydrogen_state(n,l,m)
        self.psi_f = sp.fft.fftn(self.psi)

    def conf_wavefunction(
            self: 'QuantumMechanics', 
            psi: np.ndarray
            ) -> None:
        """Set the initial condition to a given wavefunction.

        Parameters
        ----------
        psi : np.ndarray
            The wavefunction.

        Returns
        -------
        None
            Configures self.psi and self.psi_f.
        """
        self.psi = psi
        self.psi_f = sp.fft.fftn(self.psi)   

    def calc_hydrogen_state(
            self: 'QuantumMechanics', 
            n: int, 
            l: int, 
            m: int
            ) -> np.ndarray:
        """Calculate the hydrogen state with quantum numbers n,l,m

        Parameters
        ----------
        n : int
            principal quantum number
        l : int
            azimuthal quantum number
        m : int
            magnetic quantum number

        Returns
        -------
        np.ndarray
            Wavefunction of the hydrogen state. (np.ndarray)
        """

        if not self.dim == 3:
            raise(Exception('The hydrogen state is only defined in 3D'))

        r = np.sqrt(self.x**2 + self.y**2 + self.z**2)
        theta = np.arccos(self.z/r)
        theta[np.isnan(theta)] = 0
        phi = np.arctan2(self.y,self.x)

        R = (2*r/n)**l * np.exp(-r/n) *  sp.special.genlaguerre(n-l-1,2*l+1)(2*r/n)
        Y = sp.special.sph_harm(m,l,phi,theta)
        
        return R*Y
    

    ## Calculation functions
    def calc_nonlinear_evolution_function_f(
            self: 'QuantumMechanics', 
            psi: np.ndarray, 
            t: float
            ) -> np.ndarray:
        """Calculate the nonlinear evolution function f of the Schrödinger equation

        Parameters
        ----------
        psi : np.ndarray 
            The wavefunction.
        t : float
            Time
        
        Returns
        -------
        np.ndarray
            The nonlinear evolution function f.
        """

        if callable(self.V_ext):
            potential = self.V_ext(t)
        else:
            potential = self.V_ext
        return sp.fft.fftn((1j) * (-potential) * psi)


    ## Time evolution functions
    def evolve_schrodinger(
            self: 'QuantumMechanics', 
            number_of_steps: int, 
            method: Literal['ETD2RK', 'ETD4RK'] = 'ETD4RK'
            ) -> None:
        """Evolve the system according to the Schrödinger equation

        Parameters
        ----------
        number_of_steps : int
            Number of time steps to evolve the system.
        method : str
            The method to use for the time evolution. 
        
        Returns
        -------
        None
            Updates self.psi and self.psi_f.
        """

        omega_f = -1j / 2 * self.calc_k2()
        if method == 'ETD2RK':
            integrating_factors_f = self.calc_evolution_integrating_factors_ETD2RK(omega_f)
            solver = self.evolve_ETD2RK_loop
        elif method == 'ETD4RK':
            integrating_factors_f = self.calc_evolution_integrating_factors_ETD4RK(omega_f)
            solver = self.evolve_ETD4RK_loop
        else:
            raise(Exception('This method is not implemented'))
        for n in range(number_of_steps):
            self.psi, self.psi_f = solver(integrating_factors_f, self.calc_nonlinear_evolution_function_f,
                                                           self.psi, self.psi_f)
--- End of file: comfit\quantum_mechanics\quantum_mechanics.py ---

--- Start of file: comfit\quantum_mechanics\__init__.py ---
from .quantum_mechanics import QuantumMechanics
--- End of file: comfit\quantum_mechanics\__init__.py ---

--- Start of file: comfit\bose_einstein_condensate\bose_einstein_condensate.py ---
from typing import Callable, Union, Optional

import numpy as np
import matplotlib.pyplot as plt
from comfit.core.base_system import BaseSystem
from tqdm import tqdm
from mpl_toolkits.mplot3d import Axes3D  
import scipy as sp

class BoseEinsteinCondensate(BaseSystem):
    def __init__(self, dim: int, **kwargs):
        """Initializes a system to simulate a Bose-Einstein Condensate using the Gross-Pitaevskii equation.

        Args:
            dim : int
                The dimension of the system.
            kwargs : dict, optional
                Optional keyword arguments to set additional parameters. see
                https://comfitlib.com/ClassBoseEinsteinCondensate/

        Returns:
            The system object representing the BoseEinsteinCondensate simulation. BoseEinsteinCondensate object

        Example:
            bec = BoseEinsteinCondensate(3,xRes=101,yRes=101,zRes=101, gamma=0.5)
            Creates a BoseEinsteinCondensate system with 3 dimensions and a spatial resolution of 101 in all directions.
            The dissipative factor gamma is set to 0.5.
        """

        # First initialize the BaseSystem class
        super().__init__(dim, **kwargs)

        # Type of the system
        self.psi = None
        self.psi_f = None
        self.type = 'BoseEinsteinCondensate'

        # Default simulation parameters
        self.gamma = 0.01 if 'gamma' not in kwargs else kwargs['gamma']  # Dissipation (gamma)

        self.V_ext = lambda t: 0  # External potential, note this is a function of t

        # If there are additional arguments provided, set them as attributes
        for key, value in kwargs.items():
            setattr(self, key, value)

    def __str__(self) -> str:
        """Output a string representation of the system.

        Args:
            None

        Returns:
            A string representation of the system.
        """
        return f"ComFiT object: BoseEinsteinCondensate\n \
                Dimension: {self.dim}\n"

    # CONFIGURATION FUNCTIONS
    def conf_initial_condition_disordered(self, noise_strength: float = 0.01) -> np.ndarray:
        """Sets disordered initial condition for the BoseEinsteinCondensate with some thermal flcutiations
        
        Args:
            noise_strength: the strength of the noise

        Returns:
            Sets the value of self.psi and self.psi_f
        """

        if self.dim == 1:
            self.psi = np.random.rand(self.xRes) - 0.5 + \
                       1j * np.random.rand(self.xRes) - 0.5j

        elif self.dim == 2:
            self.psi = np.random.rand(self.xRes, self.yRes) - 0.5 + \
                       1j * np.random.rand(self.xRes, self.yRes) - 0.5j

        elif self.dim == 3:
            self.psi = np.random.rand(self.xRes, self.yRes, self.zRes) - 0.5 + \
                       1j * np.random.rand(self.xRes, self.yRes, self.zRes) - 0.5j
        else:
            raise Exception("Code for this dimension has not yet been implemented.")

        self.psi = noise_strength * self.psi
        self.psi_f = sp.fft.fftn(self.psi)

    def conf_external_potential(self, V_ext: Union[Callable, float], additive: bool = False) -> None:
        """Sets the external potential of the system.

        Args:
            V_ext (function or float): the external potential
            additive (bool, optional): whether to add the new potential to the existing potential or not

        Returns:
            Modifies the value of self.V_ext
        """

        if not callable(V_ext):
            original_V_ext = V_ext  # Preserve the original value of V_ext
            V_ext = lambda t: original_V_ext
        
        if additive:
            self.V_ext = lambda t: self.V_ext(t) + V_ext(t)
        else:
            self.V_ext = V_ext



    def conf_initial_condition_Thomas_Fermi(self) -> None:
        """Finds the Thomas_Fermi ground state.

        Must be precided by an energy relaxation to find the true ground state

        Args:
            None
        
        Returns: 
            Sets the value of self.psi and self.psi_f
        """
        V_0 = np.zeros(self.dims) + self.V_ext(self.time)
        self.psi = np.emath.sqrt(1 - V_0)

        self.psi[V_0 > 1] = 0
        self.psi_f = sp.fft.fftn(self.psi)

    # CONFIGURATION FUNCTIONS
    def conf_insert_vortex(self, charge: int = 1, position: Optional[list[float]] = None):
        """Sets the initial condition for a vortex dipole

        Args:
            charge (int): the charge of the vortex
            position (list): the position of the vortex

        Returns:
            Modifies the value of self.psi and self.psi_f
        """
        if not (self.dim == 2):
            raise Exception("The dimension of the system must be 2 for a single point vortex.")

        if position is None:
            position = [self.xmid, self.ymid]

        if self.psi is None:
            self.conf_initial_condition_Thomas_Fermi()

        self.psi = self.psi * np.exp(1j * self.calc_angle_field_single_vortex(position=position, charge=charge))
        self.psi_f = sp.fft.fftn(self.psi)

    def conf_insert_vortex_dipole(
        self,
        dipole_vector: Optional[list[float]] = None,
        dipole_position: Optional[list[float]] = None
    ):
        """Sets the initial condition for a vortex dipole configuration in a 2-dimensional system.

        Args:
            None

        Returns:
            Modifies the value of self.psi and self.psi_f

        Raises:
            Exception: If the dimension of the system is not 2.
        """
        if not (self.dim == 2):
            raise Exception("The dimension of the system must be 2 for a vortex dipole configuration.")

        if self.psi is None:
            self.conf_initial_condition_Thomas_Fermi()

        if dipole_vector is None:
            dipole_vector = [self.size_x / 3, 0]

        if dipole_position is None:
            dipole_position = self.rmid

        self.psi = self.psi * np.exp(1j * self.calc_angle_field_vortex_dipole(dipole_vector, dipole_position))
        self.psi_f = sp.fft.fftn(self.psi)

    def conf_insert_vortex_ring(
        self,
        position: Optional[list[float]] = None,
        radius: Optional[float] = None,
        normal_vector: list[float] = [0, 0, 1]
    ) -> None:
        """Sets the initial condition for a vortex ring configuration in a 3-dimensional system
        
        Args:
            position: the position of the vortex ring (list)
            radius: the radius of the vortex ring (float)
            normal_vector: the normal vector of the vortex ring (list)
        
        Returns:
            Modifies the value of self.psi and self.psi_f
        """
        if not (self.dim == 3):
            raise Exception("The dimension of the system must be 3 for a vortex ring configuration.")

        if position is None:
            position = self.rmid

        if radius is None:
            radius = self.size_x/ 3

        theta = self.calc_angle_field_vortex_ring(position=position, radius=radius, normal_vector=normal_vector)

        if self.psi is None:
            self.conf_initial_condition_Thomas_Fermi()

        self.psi = self.psi * np.exp(1j * theta)
        self.psi_f = sp.fft.fftn(self.psi)

    def conf_vortex_remover(self, nodes: list[dict], Area: list[float]) -> None:
        '''Removes vortices
        
        Function that finds and removes vortices outside of the area defined by the corners
        (x1,y1), (x1,y2), (x2,y1), (x2,y2)

        Args:
            nodes (list) a list containing the vortices
            Area  (array) list on the format (x1,x2,y1,y2)

        Returns:
            Modifies the value of self.psi and self.psi_f
        '''
        for vortex in nodes:
            x_coord = vortex['position'][0]
            y_coord = vortex['position'][1]
            if not (Area[0] < x_coord and x_coord < Area[1] \
                    and Area[2] < y_coord and y_coord < Area[3]):
                self.conf_insert_vortex(charge=-1 * vortex['charge'], position=[x_coord + self.dx, y_coord])
                # self.conf_insert_vortex(charge=vortex['charge'], position=[7, 0])

    def conf_dissipative_frame(self, interface_width: float = 7, 
                                    frame_width_x: float = None, 
                                    frame_width_y: float = None, 
                                    frame_width_z: float = None) -> None:

        '''Configures a dissipative frame around the computational domain

        This function sets self.gamma so that it has a low value in the bulk and a large value near the edges.
        This sets a dissipative frame around the computational domain
        
        Args:
            d: length of the interface between the low gamma and high gamma regions (float)
            frame_width_x: distance fom center to the frame in x-direction (float)
            frame_width_y:    -- " --                         y-direction (float)
            frame_width_z:     -- " --                         z-direction (float)

        Returns:
            modify self.gamma
        '''

        # If configuration is called for the first time, set initial_gamma
        if not hasattr(self, 'initial_gamma'):
            self.initial_gamma = self.gamma

        # Set default values for frame_width
        if frame_width_x is None:
            frame_width_x = 0.8*self.size_x
        if frame_width_y is None:
            frame_width_y = 0.8*self.size_y
        if frame_width_z is None:
            frame_width_z = 0.8*self.size_z

        # Set the frame
        if self.dim == 2:
            X, Y = np.meshgrid(self.x, self.y, indexing='ij')
            gammax = self.initial_gamma + 0.5 * (2 + np.tanh((X - self.xmid - frame_width_x/2) /interface_width) - np.tanh((X - self.xmid + frame_width_x/2) /interface_width))
            gammay = self.initial_gamma + 0.5 * (2 + np.tanh((Y - self.ymid - frame_width_y/2) /interface_width) - np.tanh((Y - self.ymid + frame_width_y/2) /interface_width))
            self.gamma = np.real(np.maximum(gammax, gammay))
        elif self.dim == 3:
            X, Y, Z = np.meshgrid(self.x, self.y, self.z, indexing='ij')
            gammax = self.initial_gamma + 0.5 * (2 + np.tanh((X - self.xmid - frame_width_x/2) /interface_width) - np.tanh((X - self.xmid + frame_width_x/2) /interface_width))
            gammay = self.initial_gamma + 0.5 * (2 + np.tanh((Y - self.ymid - frame_width_y/2) /interface_width) - np.tanh((Y - self.ymid + frame_width_y/2) /interface_width))
            gammaz = self.initial_gamma + 0.5 * (2 + np.tanh((Z - self.zmid - frame_width_z/2) /interface_width) - np.tanh((Z - self.zmid + frame_width_z/2) /interface_width))
            self.gamma = np.real(np.maximum(gammax, gammay, gammaz))
        else:
            raise Exception("This feature is not yet available for the given dimension.")


    # Time evolution
    def evolve_dGPE(self, number_of_steps: int , method: str = 'ETD2RK') -> None:
        '''Evolver for the dGPE.
        
        Args:
            number_of_steps: the number of time steps that we are evolving the equation  (int)
            method: the integration method we want to use. ETD2RK is sett as default  (string, optional)
        
        Returns:
            Updates the self.psi and self.psi_f
       '''

        k2 = self.calc_k2()
        omega_f = (1j + self.gamma) * (1 - 1 / 2 * k2)

        integrating_factors_f, solver = self.calc_integrating_factors_f_and_solver(omega_f, method)

        for n in tqdm(range(number_of_steps), desc='evolving the dGPE'):
            self.psi, self.psi_f = solver(integrating_factors_f,
                                          self.calc_nonlinear_evolution_function_f,
                                          self.psi, self.psi_f)

    def evolve_relax(self, number_of_steps: int, method: str = 'ETD2RK') -> None:
        '''Evolver for the dGPE in imaginary time that relax the equation closer to the ground state
        
        Args:
            number_of_steps: the number of time steps that we are evolving the equation (int)
            method: the integration method we want to use. ETD2RK is sett as default (string)
        
        Returns:
            Updates the self.psi and self.psi_f
        '''
        temp_t = self.time
        gamma0 = self.gamma

        self.gamma = 1 - 1j

        temp_V = self.V_ext

        self.conf_external_potential(temp_V(temp_t))

        print("Relaxing the BoseEinsteinCondensate...")
        self.evolve_dGPE(number_of_steps, method)

        self.gamma = gamma0
        self.time = temp_t
        
        self.conf_external_potential(temp_V)

    def evolve_comoving_dGPE(self, number_of_steps: int, velx: float, method: str = 'ETD2RK') -> None:
        '''Evolver for the dGPE in the comoving frame.

        This evolver assume that the stirring is in the x-direction and that gamma is spatialy dependent
        
        Args:
            number_of_steps: the number of time steps that we are evolving the equation (int)
            velx: velocity in x direction (float) 
            method: the integration method we want to use. ETD2RK is sett as default (string)
        
        Returns:
            Updates the fields self.psi and self.psi_f
        '''
        k2 = self.calc_k2()

        omega_f = (1j) * (1 - 1 / 2 * k2) + velx * self.dif[0]

        if method == 'ETD2RK':
            integrating_factors_f = self.calc_evolution_integrating_factors_ETD2RK(omega_f)
            solver = self.evolve_ETD2RK_loop
        elif method == 'ETD4RK':
            integrating_factors_f = self.calc_evolution_integrating_factors_ETD4RK(omega_f)
            solver = self.evolve_ETD4RK_loop
        else:
            raise Exception('This method is not implemented')

        for n in tqdm(range(number_of_steps), desc='evolving the dGPE in the comoving frame'):
            self.psi, self.psi_f = solver(integrating_factors_f, self.calc_nonlinear_evolution_term_comoving_f,
                                          self.psi, self.psi_f)

    # CALCULATION FUNCTIONS

    def calc_nonlinear_evolution_function_f(self, psi: np.ndarray, t) -> np.ndarray:
        """Calculates the non-linear evolution term of the dGPE
        
        Args:
            psi: the wavefunction at a given time. (numpy.ndarray)
        
        Returns:
            The non-linear evolution term (numpy.ndarray)
        """
        
        psi2 = np.abs(psi) ** 2
        return sp.fft.fftn((1j + self.gamma) * (-self.V_ext(t) - psi2) * psi)

    def calc_nonlinear_evolution_term_comoving_f(self, psi: np.ndarray, t) -> np.ndarray:
        """Calculates the non-linear evolution term of the dGPE when gamma is not a constant.

        Relevant for example in the comoving frame when we have a dissipative frame around the edge.
        
        Args:
            psi: the wavefunction at a given time. (numpy.ndarray)
        
        Returns:
            the non-linear evolution term (numpy.ndarray)
        """
        psi2 = np.abs(psi) ** 2
        term1 = sp.fft.fftn(-(1j + self.gamma) * (self.V_ext(t) + psi2) * psi)
        term2 = sp.fft.fftn(self.gamma * psi)
        term3 = 0.5 * sp.fft.fftn(self.gamma * sp.fft.ifftn(-self.calc_k2() * sp.fft.fftn(psi)))
        return (term1 + term2 + term3)

        # Functions for callculationg properties of the BoseEinsteinCondensate

    def calc_superfluid_current(self) -> np.ndarray:
        """Calculates the superfluid current

        Args:
            None
        
        Returns:
            The superfluid current (numpy.ndarray) 
        """
        if self.dim == 2:
            J_s = np.zeros((self.dim,self.xRes,self.yRes))
        elif self.dim == 3:
            J_s = np.zeros((self.dim, self.xRes, self.yRes,self.zRes))
        else:
            raise(Exception('Calculation of the  superfluid current is not implemented in this dimension'))
        for i in range(self.dim):
            J_s[i] = np.imag( np.conj(self.psi) * sp.fft.ifftn(1j*self.k[i] *self.psi_f ))
        return J_s

    def calc_velocity(self) -> np.ndarray:
        """Calculates the weighted velocity field
        
        Args:
            None

        Returns:
            The weighted velocity field (numpy.ndarray) 
        """
        if self.dim == 2:
            u = np.zeros((self.dim, self.xRes, self.yRes))
        elif self.dim == 3:
            u = np.zeros((self.dim, self.xRes, self.yRes, self.zRes))
        else:
            raise (Exception('Calculation of the weighted velocity is not implemented in this dimension'))
        theta = np.angle(self.psi)
        for i in range(self.dim):
            u[i] = np.imag(np.exp(-1j*theta)* sp.fft.ifftn(1j * self.k[i] * self.psi_f))
        return u

    def calc_kinetic_energy(self) -> float:
        """Calculates the kinetic energy.

        Args:
            None

        Returns:
            The kinetic energy (float) 
        """
        u = self.calc_velocity()
        u2 = np.sum(u[i]**2 for i in range(self.dim))
        return 0.5*self.calc_integrate_field(u2)


    def calc_hamiltonian_density(self) -> np.ndarray:
        """Calculates the hamiltonian density

        Args:
            None

        Returns:
            The hamiltonian density (numpy.ndarray) 
        """
        k2 = self.calc_k2()
        interaction_term = 1/2*np.abs(self.psi)**4
        potential_term = (self.V_ext(self.time) - 1 )* np.abs(self.psi)**2
        laplacian_term = -1/2 *np.real( np.conj(self.psi) * sp.fft.ifftn(-k2*self.psi_f))
        return laplacian_term +potential_term + interaction_term

    def calc_hamiltonian(self) -> float:
        """Function that calculates the Hamiltonian

        Args:
            None

        Returns:
            The Hamiltonian
        """
        H = self.calc_hamiltonian_density()
        return self.calc_integrate_field(H)

    def calc_harmonic_potential(self, R_tf: float) -> np.ndarray:
        """Calculates a harmonic trap with R_tf being the Thomas-Fermi radius
        
        Args:
            R_tf (float): The Thomas-Fermi radius
        
        Returns:
            A harmonic potential
        """
        trapping_strength = 1 / (R_tf ** 2)
        if self.dim == 1:
            return trapping_strength * (self.x - self.xmid) ** 2
        if self.dim == 2:
            return trapping_strength * (((self.x - self.xmid) ** 2).reshape(self.xRes, 1)
                                        + ((self.y - self.ymid) ** 2).reshape(1, self.yRes))
        if self.dim == 3:
            return trapping_strength * (((self.x - self.xmid) ** 2).reshape(self.xRes, 1, 1)
                                        + ((self.y - self.ymid) ** 2).reshape(1, self.yRes, 1)
                                        + ((self.z - self.zmid) ** 2).reshape(1, 1, self.zRes))

    def calc_force_on_external_potential(self) -> np.ndarray: 
        """Calculates the average force acting on the external potential.
        
        Args:
            None
        
        Returns:
            Average force on the potential (numpy.ndarray) 
        """
        Force =np.zeros(self.dim)
        potential_f = sp.fft.ifftn(self.V_ext(self.time))
        for i in range(self.dim):
            Force_density = np.real(np.abs(self.psi)**2 * sp.fft.ifftn(1j*self.k[i]* potential_f))
            Force[i] = self.calc_integrate_field(Force_density)
        return Force
        #TODO: It is not clear to me exactly what this function does (Vidar 04.12.23)



    ## Functions for calculating vortex properties
    def calc_vortex_density(self, psi: Optional[np.ndarray] = None) -> np.ndarray:
        """Calculates the vortex density of the system.

        Args:
            psi: The wavefunction of the system. (numpy.ndarray)
        
        Returns:
            The vortex density of the system. numpy.ndarray
        """
        if psi is None:
            psi = self.psi

        return self.calc_defect_density([np.real(psi), np.imag(psi)])

    def calc_vortex_density_singular(self) -> np.ndarray:
        """Calculates the vortex density of the system using the singular method.

        Args:
            None
        
        Returns:
            The vortex density of the system. (numpy.ndarray)
        """
        # TODO: Insert the correct value of the equilibrium of psi, based on theory (Vidar 03.12.23)
        return self.calc_defect_density([np.real(self.psi), np.imag(self.psi)])

    def calc_vortex_velocity_field(self, dt_psi: np.ndarray, psi: Optional[np.ndarray] = None) -> np.ndarray:
        """Calculates the vortex velocity field of the system.

        Args:
            dt_psi: The time derivative of the wavefunction of the system. (numpy.ndarray)
            psi: The wavefunction of the system. (numpy.ndarray)

        Returns:
            The vortex velocity field of the system. numpy.ndarray: 
        """
        if psi is None:
            psi = self.psi

        return self.calc_defect_velocity_field([np.real(psi), np.imag(psi)],
                                        [np.real(dt_psi), np.imag(dt_psi)])

    def calc_vortex_nodes(self, dt_psi: Optional[np.ndarray] = None) -> list[dict]:
        """
        Calculate the positions and charges of vortex nodes based on the defect density.

        Args:
            dt_psi: The time derivative of the wavefunction of the system.     (numpy.ndarray)
    
        Returns:
            List of dictionaries representing the vortex nodes. Each dictionary contains the following keys:
                  - 'position_index': The position index of the vortex node in the defect density array.
                  - 'charge': The charge of the vortex node.
                  - 'position': The position of the vortex node as a list [x, y].
                  - 'velocity': The velocity of the vortex node as a list [vx, vy].
        """

        # Calculate defect density
        rho = self.calc_vortex_density(self.psi)

        if dt_psi is not None:
            velocity_field = self.calc_vortex_velocity_field(dt_psi, self.psi)

        if self.dim == 2:
            vortex_nodes = self.calc_defect_nodes(np.abs(rho), 
                                                    charge_tolerance = 0.2,
                                                    integration_radius = self.a0)
            for vortex in vortex_nodes:
                vortex['charge'] = np.sign(rho[vortex['position_index']])
                if dt_psi is not None:
                    vortex['velocity'] = [velocity_field[0][vortex['position_index']], 
                                        velocity_field[1][vortex['position_index']]]
                else:
                    vortex['velocity'] = [float('nan'), float('nan')]
        elif self.dim == 3:
            vortex_nodes = self.calc_defect_nodes(np.sqrt(rho[0]**2 + rho[1]**2 + rho[2]**2), 
                                                charge_tolerance = 2*self.a0,
                                                integration_radius = 2*self.a0
                )
            for vortex in vortex_nodes:
                tangent_vector = np.array([rho[i][vortex['position_index']] for i in range(3)]),
                vortex['tangent_vector'] = tangent_vector[0]/np.linalg.norm(tangent_vector)
                
                if dt_psi is not None:
                    vortex['velocity'] = [velocity_field[0][vortex['position_index']], 
                                        velocity_field[1][vortex['position_index']], 
                                        velocity_field[2][vortex['position_index']]]
                else:
                    vortex['velocity'] = [float('nan'), float('nan'), float('nan')]

        return vortex_nodes



    

--- End of file: comfit\bose_einstein_condensate\bose_einstein_condensate.py ---

--- Start of file: comfit\bose_einstein_condensate\__init__.py ---
from .bose_einstein_condensate import BoseEinsteinCondensate
--- End of file: comfit\bose_einstein_condensate\__init__.py ---

--- Start of file: comfit\nematic_liquid_crystal\nematic_liquid_crystal.py ---
import numpy
import numpy as np
from comfit.core.base_system import BaseSystem
import scipy as sp
from tqdm import tqdm
import matplotlib.pyplot as plt

from comfit.plot.plot_nodes_plotly import plot_nodes_plotly

from comfit.tool.tool_colormap import tool_colormap
from comfit.tool.tool_create_orthonormal_triad import tool_create_orthonormal_triad

from comfit.nematic_liquid_crystal.plot_field_velocity_and_director_matplotlib import plot_field_velocity_and_director_matplotlib

from comfit.nematic_liquid_crystal.plot_field_velocity_and_director_plotly import plot_field_velocity_and_director_plotly



from comfit.tool.tool_math_functions import levi_civita_symbol
from mpl_toolkits.mplot3d import axes3d
import matplotlib.cm as cm
from matplotlib.colors import Normalize

class NematicLiquidCrystal(BaseSystem):

    def __init__(self, dim, **kwargs):
        """Initializes a system to simulate a (active) nematic liquid crystal

        Args:
            dimension : The dimension of the system.
            kwargs : dict, optional
            Optional keyword arguments to set additional parameters. See
            https://comfitlib.com/ClassNematicLiquidCrystal/

        Returns:
        - NematicLiquidCrystal object
            The system object representing the nematic simulation.

        Example:
            nematic = NematicLiquidCrystal(2, xRes=100, yRes = 100, alpha=-0.5)
            Creates a nematic liquid crystal with 2 dimensions and a spatial resolution of 100.
            The activity alpha is set to -0.5.
        """
        super().__init__(dim, **kwargs)

        # Type of the system
        self.Q = None
        self.Q_f = None
        self.u = None
        self.u_f = None
        self.type = 'NematicLiquidCrystal'

        #defoult parameters
        self.alpha = -1 if 'alpha' not in kwargs else kwargs['alpha']   #defult is an extensile system
        self.K = 1 if 'K' not in kwargs else kwargs['K']
        self.A = 1 if 'A' not in kwargs else kwargs['A']
        self.B = 1 if 'B' not in kwargs else kwargs['B']
        self.C = 0 if 'C' not in kwargs  else kwargs['C']  # note: in two dim C is never called
        self.Lambda = 0 if 'Lambda' not in kwargs else kwargs['Lambda'] #flow allignment, not sure if this will be implemented
        self.gamma = 1  if 'gamma' not in kwargs else kwargs['gamma']  # rotational diffusion
        self.Gamma = 0 if 'Gamma' not in kwargs else kwargs['Gamma'] # friction,
        self.eta = 1 if 'eta' not in kwargs else kwargs['eta'] # viscosity


        for key, value in kwargs.items():
            setattr(self, key, value)

    def __str__(self):
        """Output a string representation of the system.

        Input:
            None

        Returns:
            A string representation of the system.
        """
        return "NematicLiquidCrystal"

    # Initial condition
    def conf_initial_condition_ordered(self, noise_strength=0.01):
        """Configures the system with the nematogens pointing in the x-direction in 2D and in the z-direction in 3D
        with some random noise in the angle.
        
        Args:
             noise_strength: A meshure for how much noise to put in the angle (float)
        
        Returns:
            Initialises self.Q and self.Q_f
        
        Raises:
            Exception if the dimension is not 2 or 3
        """
        if self.dim == 2:
            S0 = np.sqrt(self.B)
            theta_rand = noise_strength*np.random.randn(self.xRes,self.yRes)
            self.Q = np.zeros((2,self.xRes,self.yRes))
            self.Q[0] = S0/2 *np.cos(2*theta_rand)
            self.Q[1] =  S0/2 *np.sin(2*theta_rand)


            self.Q_f = sp.fft.fft2(self.Q)

            self.k2 = self.calc_k2() # k2
            self.k2_press = self.calc_k2()
            self.k2_press[0,0] = 1 # for calculating pressure and velocity

        elif self.dim == 3:

            S0 = 1/8* self.C/self.A + 1/2 * np.sqrt(self.C**2 /(16*self.A**2) + 3*self.B)


            theta_rand = noise_strength*np.random.randn(self.xRes,self.yRes,self.zRes)
            phi_rand = noise_strength*np.random.randn(self.xRes,self.yRes,self.zRes)

            nx = np.cos(theta_rand)*np.sin(phi_rand)
            ny = np.sin(theta_rand)*np.sin(phi_rand)
            nz = np.cos(phi_rand)

            self.Q = np.zeros((5, self.xRes, self.yRes, self.zRes))
            self.Q[0] = S0 *(nx*nx -1/3)
            self.Q[1] = S0 *(nx*ny)
            self.Q[2] = S0 *(nx*nz)
            self.Q[3] = S0 *(ny*ny -1/3)
            self.Q[4] = S0 *(ny*nz)

            self.Q_f = sp.fft.fftn(self.Q, axes=(range(-self.dim, 0)))

            self.k2 = self.calc_k2()  # k2
            self.k2_press = self.calc_k2()
            self.k2_press[0, 0, 0] = 1  # for calculating pressure and velocity

        else:
            raise Exception("This dimension is not included for the moment")

    def conf_insert_disclination_dipole(self, dipole_vector=None, dipole_position=None):
        """Sets the initial condition for a disclination dipole configuration in a 2-dimensional system.

        Args:
            None

        Returns:
            Configures self.Q and self.Q_f with a disclination dipole configuration.

        Raises:
            Exception: If the dimension of the system is not 2.
        """
        if not (self.dim == 2):
            raise Exception("The dimension of the system must be 2 for a disclination dipole configuration.")

        if self.Q is None:
            self.conf_initial_condition_ordered(noise_strength=0)

        if dipole_vector is None:
            dipole_vector = [self.size_x/ 3, 0]

        if dipole_position is None:
            dipole_position = self.rmid

        psi = (self.Q[0] + 1j*self.Q[1]) * np.exp(1j * self.calc_angle_field_vortex_dipole(dipole_vector, dipole_position))
        self.Q[0] = np.real(psi)
        self.Q[1] = np.imag(psi)
        self.Q_f = sp.fft.fft2(self.Q)

    def conf_initial_disclination_lines(self, position1=None,position2 = None):
        """Sets the initial condition for a disclination line in a 3-dimensional system.

        The dislocation is parralell to the z-axis

        Args:
            position1 (list): the position of the first dislocation. Only the position in the xy plane is used

        Returns:
            Sets the value of self.Q and self.Q_f
        """
        if not (self.dim == 3):
            raise Exception("The dimension of the system must be 3 for a disclination line configuration.")

        if position1 is None:
            position1 = [self.xmid+self.size_x/3, self.ymid]
        if position2 is None:
            position2 = [self.xmid - self.size_x / 3, self.ymid]


        theta_1 = 1/2*np.arctan2((self.y-position1[1]),(self.x-position1[0]))
        theta_2 = -1/2*np.arctan2((self.y-position2[1]),(self.x-position2[0]))
        theta = theta_1 +theta_2

        S0 = 1/8* self.C/self.A + 1/2 * np.sqrt(self.C**2 /(16*self.A**2) + 3*self.B)

        nx =  np.cos(theta)
        ny = np.sin(theta)
        nz = np.zeros_like(nx)

        self.Q = np.zeros((5, self.xRes, self.yRes, self.zRes))
        self.Q[0] = S0 * (nx * nx - 1 / 3)
        self.Q[1] = S0 * (nx * ny)
        self.Q[2] = S0 * (nx * nz)
        self.Q[3] = S0 * (ny * ny - 1 / 3)
        self.Q[4] = S0 * (ny * nz)

        self.Q_f = sp.fft.fftn(self.Q, axes=(range(-self.dim, 0)))

        self.k2 = self.calc_k2()  # k2
        self.k2_press = self.calc_k2()
        self.k2_press[0, 0, 0] = 1




    def conf_active_channel(self,width = None,d=7):
        """Configures the activity to zero everywhere exept for inside a channel of width "width"
        
        Args:
            width: width of the channel (float)
            d: width of interface (float, optional)
        
        Returns:
            Updates the activity to the channel configuration.
        """
        if self.dim ==2:
            X, Y = np.meshgrid(self.x, self.y, indexing='ij')
            alpha_0 = self.alpha
            if width is None:
                width = self.size_x/3

            self.alpha = alpha_0*(1- 1 / 2 * (2 + np.tanh((X - self.xmid - width/2) / d) - np.tanh((X - self.xmid + width/2) / d)))
        else:
            raise Exception("The active channel is only permitted in two dimensions")

    ## calculations related to the flow field
    def conf_velocity(self,Q):
        '''
        Updates the velocity and its fourier transform given a nematic field Q.
        
        Args:
            (numpy.narray) the Q tensor
        
        Returns:
            (numpy.narray) velocity
        '''
        F_af = self.calc_active_force_f(Q)
        F_pf = self.calc_passive_force_f(Q)
        p_f = self.calc_pressure_f(F_af,F_pf)
        grad_pf = self.calc_gradient_pressure_f(p_f)
        self.u_f = (F_af + F_pf-grad_pf )/ (self.Gamma +self.eta*self.k2_press)

        self.u = np.real(sp.fft.ifftn(self.u_f, axes=(range(-self.dim, 0))))

    def calc_active_force_f(self,Q):
        '''Function that calculates the activ force in Fourier space.
        
        Args:
            Q: the order parameter that we use to find the force.  (numpy.narray) 
        
        Returns:
            The active force in Fourier space (numpy.narray) 
        '''
        F_af = []
        for j in range(self.dim):
            F_af.append(np.sum(1j*self.k[i]*sp.fft.fftn(self.alpha *self.get_sym_tl(Q,j,i),axes=(range(-self.dim, 0)) ) for i in range(self.dim)))
        return np.array(F_af)

    def calc_passive_force_f(self,Q):
        '''Calculates the passive force in Fourier space
        
        Args:
            Q: the order parameter that we use to find the force. (numpy.narray)
        
        Returns: 
            The passive force in Fourier space numpy.ndarray: 
        '''
        Pi_f = self.calc_passive_stress_f(Q)
        F_pf = []
        for j in range(self.dim):
            F_pf.append(np.sum(1j * self.k[i] *Pi_f[j][i] for i in range(self.dim)))
        return numpy.array(F_pf)

    def calc_passive_stress_f(self,Q):
        """Calculates the passive stress in fourier space

        Args:
            Q: the order parameter that we use to find the stress.
        
        Returns: 
            The passive stress in fourier space (numpy.narray) 
        """
        if self.dim == 2:
            H = self.calc_molecular_field(Q)
            Antisym_QH = np.sum(self.get_sym_tl(Q,0,k)*self.get_sym_tl(H,k,1) -self.get_sym_tl(H,0,k)*self.get_sym_tl(Q,k,1) for k in range(self.dim))
            Ericksen = np.zeros((self.dim,self.xRes,self.yRes),dtype=np.complex128)
            Ericksen[0] = - self.K*np.sum(sp.fft.ifftn(1j*self.k[0]*sp.fft.fftn(self.get_sym_tl(Q,m,l)))*
                                              sp.fft.ifftn(1j * self.k[0] * sp.fft.fftn(self.get_sym_tl(Q,m,l)))
                                              for m in range(self.dim) for l in range(self.dim))
            Ericksen[1] = - self.K*np.sum(sp.fft.ifftn(1j*self.k[0]*sp.fft.fftn(self.get_sym_tl(Q,m,l)))*
                                              sp.fft.ifftn(1j * self.k[1] * sp.fft.fftn(self.get_sym_tl(Q,m,l)))
                                              for m in range(self.dim) for l in range(self.dim))

            stress = np.zeros((self.dim,self.dim,self.xRes,self.yRes),dtype=np.complex128)
            for i in range(self.dim):
                for j in range(self.dim):
                    stress[i][j] = self.get_sym_tl(Ericksen,i,j) + self.get_anti_sym(Antisym_QH,i,j)
            return sp.fft.fftn(stress, axes=(range(-self.dim, 0)) )

        elif self.dim == 3:

            H = self.calc_molecular_field(Q)

            Antisym_QH = np.zeros((3, self.xRes, self.yRes,self.zRes), dtype=np.complex128)

            Antisym_QH[0] = np.sum(self.get_sym_tl(Q,0,k)*self.get_sym_tl(H,k,1) -self.get_sym_tl(H,0,k)*self.get_sym_tl(Q,k,1) for k in range(self.dim))
            Antisym_QH[1] = np.sum(
                self.get_sym_tl(Q, 0, k) * self.get_sym_tl(H, k, 2) - self.get_sym_tl(H, 0, k) * self.get_sym_tl(Q, k, 2) for k in
                range(self.dim))
            Antisym_QH[2] = np.sum(
                self.get_sym_tl(Q, 1, k) * self.get_sym_tl(H, k, 2) - self.get_sym_tl(H, 1, k) * self.get_sym_tl(Q, k, 2) for k in
                range(self.dim))

            Ericksen = np.zeros((5, self.xRes, self.yRes,self.zRes), dtype=np.complex128)
            Ericksen[0] = - self.K * np.sum(sp.fft.ifftn(1j * self.k[0] * sp.fft.fftn(self.get_sym_tl(Q, m, l))) *
                                            sp.fft.ifftn(1j * self.k[0] * sp.fft.fftn(self.get_sym_tl(Q, m, l)))
                                            for m in range(self.dim) for l in range(self.dim))
            Ericksen[1] = - self.K * np.sum(sp.fft.ifftn(1j * self.k[0] * sp.fft.fftn(self.get_sym_tl(Q, m, l))) *
                                            sp.fft.ifftn(1j * self.k[1] * sp.fft.fftn(self.get_sym_tl(Q, m, l)))
                                            for m in range(self.dim) for l in range(self.dim))
            Ericksen[2] = - self.K * np.sum(sp.fft.ifftn(1j * self.k[0] * sp.fft.fftn(self.get_sym_tl(Q, m, l))) *
                                            sp.fft.ifftn(1j * self.k[2] * sp.fft.fftn(self.get_sym_tl(Q, m, l)))
                                            for m in range(self.dim) for l in range(self.dim))
            Ericksen[3] = - self.K * np.sum(sp.fft.ifftn(1j * self.k[1] * sp.fft.fftn(self.get_sym_tl(Q, m, l))) *
                                            sp.fft.ifftn(1j * self.k[1] * sp.fft.fftn(self.get_sym_tl(Q, m, l)))
                                            for m in range(self.dim) for l in range(self.dim))
            Ericksen[4] = - self.K * np.sum(sp.fft.ifftn(1j * self.k[1] * sp.fft.fftn(self.get_sym_tl(Q, m, l))) *
                                            sp.fft.ifftn(1j * self.k[2] * sp.fft.fftn(self.get_sym_tl(Q, m, l)))
                                            for m in range(self.dim) for l in range(self.dim))

            stress = np.zeros((self.dim,self.dim,self.xRes,self.yRes,self.zRes))
            for i in range(self.dim):
                for j in range(self.dim):
                    stress[i][j] = self.get_sym_tl(Ericksen,i,j) + self.get_anti_sym(Antisym_QH,i,j)
            return sp.fft.fftn(stress, axes=(range(-self.dim, 0)) )

    def calc_trace_Q2(self,Q):

        if self.dim == 2:
            return 2*( Q[0]**2 + Q[1]**2)
        elif self.dim == 3:
            return 2 *(Q[0]**2 + Q[1]**2+ Q[2]**2+Q[3]**2 + Q[4]**2 + Q[0]*Q[3])


    def calc_molecular_field(self,Q):
        """Finds the molecular field 
        
        Args:
            Q (numpy.ndarray): The nematic tensor
        
        Returns:
            The molecular field (numpy.ndarray)
        """

        Q2 =  self.calc_trace_Q2(Q)
        temp = -self.K * sp.fft.ifftn( self.k2* sp.fft.fftn(Q,axes=(range(-self.dim,0))),axes=(range(-self.dim,0)) )

        if self.dim == 2 or self.C == 0:
            return temp +self.A*self.B*Q -2*self.A*Q2*Q

        elif self.dim == 3:
            C_term = np.zeros((5,self.xRes,self.yRes,self.zRes))

            C_term[0] = self.C * (Q[0]**2 + Q[1]**2 +Q[2]**2 - 1/3 *Q2)
            C_term[1] = self.C * (Q[0]*Q[1] + Q[1]*Q[3] +Q[2]*Q[4])
            C_term[2] = self.C * (Q[1]*Q[4] -Q[2] * Q[3] )
            C_term[3] = self.C * (Q[1]**2 + Q[3]**2 +Q[4]**2 - 1/3 *Q2)
            C_term[4] = self.C * (Q[1]*Q[2]  -Q[4]*Q[0] )

            return temp +self.A*self.B*Q -2*self.A*Q2*Q +C_term


    def calc_pressure_f(self,F_af,F_pf):
        '''Calculates the pressure in Fourier space. The zero mode is set to zero
        
        Args:
            F_af: the active force in Fourier space  (numpy.narray)
            F_pf:the passive force in Fourier space  (numpy.narray) 
        
        Returns: 
            The pressure (numpy.ndarray) 
        '''
        p_af = np.sum(1j*self.k[i]*F_af[i] for i in range(self.dim))
        p_pf = np.sum(1j*self.k[i]*F_pf[i] for i in range(self.dim))
        return -(p_af + p_pf)/self.k2_press

    
    def calc_gradient_pressure_f(self,p_f):
        """Caclulates the gradient of the pressure
        
        Args: 
            p_f: the pressure in Fourier space  (numpy.narray)
        
        Returns:
            Gradient of the pressure (numpy.ndarray) 
        """
        grad_pf = []
        for i in range(self.dim):
            grad_pf.append(1j*self.k[i]*p_f)
        return np.array(grad_pf)

    def calc_vorticity_tensor(self):
        """Calculates the vorticity tensor

        Args:
            None

        Returns:
            The vorticity tensor (numpy.ndarray) 
        """
        if self.dim == 2:

            Omega_f = (1j*self.k[0]*self.u_f[1] -1j*self.k[1]*self.u_f[0])/2
            Omega = sp.fft.ifftn(Omega_f,axes=range(-self.dim,0))
            return np.real(Omega)

        elif self.dim ==3:
            Omega = np.zeros((3,self.xRes,self.yRes,self.zRes))
            Omega[0] = np.real(sp.fft.ifftn((1j*self.k[0]*self.u_f[1] -1j*self.k[1]*self.u_f[0])/2,axes=range(-self.dim,0)))
            Omega[1] = np.real(sp.fft.ifftn((1j * self.k[0] * self.u_f[2] - 1j * self.k[2] * self.u_f[0]) / 2,
                                            axes=range(-self.dim, 0)))
            Omega[2] = np.real(sp.fft.ifftn((1j * self.k[1] * self.u_f[2] - 1j * self.k[2] * self.u_f[1]) / 2,
                                            axes=range(-self.dim, 0)))
            return Omega

    def calc_strain_rate_tensor_f(self):
        """
        Calculates the strainrate tensor

        Args:
            None

        Returns: 
            The strainrate (numpy.ndarray) 
        """
        trace_u = np.sum(1j*self.k[i]*self.u_f[i] for i in range(self.dim))
        if self.dim == 2:
            E_f = np.zeros((2,self.xRes,self.yRes),dtype=np.complex128)
            E_f[0] = (1j*self.k[0] *self.u_f[0]) - trace_u/2
            E_f[1] = (1j*self.k[0] *self.u_f[1] +1j*self.k[1] *self.u_f[0])/2
        elif self.dim == 3:
            E_f = np.zeros((5, self.xRes, self.yRes,self.zRes), dtype=np.complex128)
            E_f[0] = (1j*self.k[0] *self.u_f[0]) - trace_u/3
            E_f[1] = (1j*self.k[0] *self.u_f[1] +1j*self.k[1] *self.u_f[0])/2
            E_f[2] = (1j * self.k[0] * self.u_f[2] + 1j * self.k[2] * self.u_f[0]) / 2
            E_f[3] =  (1j*self.k[1] *self.u_f[1]) - trace_u/3
            E_f[4] = (1j * self.k[1] * self.u_f[2] + 1j * self.k[2] * self.u_f[1]) / 2
        return E_f

    ## Calculation of non-linear evolution terms
    def calc_nonlinear_evolution_function_f(self,Q,t):
        """Calculates the non-linear evolution function for the nematic
        
        Args:
            Q: the nematic orderparameter (numpy.narray) 
        
        Returns:
            
            The non-linear evolution function evaluated in Fourier space (numpy.narray) 
        """
        if self.dim == 2:
            self.conf_velocity(Q)
            Q_f = sp.fft.fftn(Q,axes=range(-self.dim,0))
            N_f = self.calc_nonlinear_evolution_term_no_flow_f(Q,t)
            Omega =self.calc_vorticity_tensor()
            Antisym_Omega_Q = np.zeros_like(Q_f)

            Antisym_Omega_Q[0] = -2 *Q[1]*Omega
            Antisym_Omega_Q[1] = 2*Q[0]*Omega

            advectiv_deriv = - np.sum(self.u[k]* sp.fft.ifftn(1j*self.k[k] * Q_f,axes=(range(-self.dim,0)))for k in range(self.dim) )

            return sp.fft.fftn(Antisym_Omega_Q +advectiv_deriv, axes=range(-self.dim,0)) +N_f

        elif self.dim == 3:
            self.conf_velocity(Q)
            Q_f = sp.fft.fftn(Q, axes=range(-self.dim, 0))
            N_f = self.calc_nonlinear_evolution_term_no_flow_f(Q,t)
            Omega = self.calc_vorticity_tensor()

            advectiv_deriv = - np.sum(
                self.u[k] * sp.fft.ifftn(1j * self.k[k] * Q_f, axes=(range(-self.dim, 0))) for k in range(self.dim))

            Antisym_Omega_Q = np.zeros_like(Q_f)

            Antisym_Omega_Q[0] = -2 * (Q[1]*Omega[0] + Q[2]*Omega[1] )
            Antisym_Omega_Q[1] = Omega[0]*(Q[0]-Q[3]) - Omega[2]*Q[2] -Omega[1]*Q[4]
            Antisym_Omega_Q[2] = Omega[1]*(2*Q[0] + Q[3] ) + Omega[2]*Q[1] - Omega[0]*Q[4]
            Antisym_Omega_Q[3] = 2*(Q[1]*Omega[0] -Q[4]*Omega[2])
            Antisym_Omega_Q[4] = Omega[2]*(2*Q[3]+Q[0]) + Omega[1]*Q[1] + Omega[0]*Q[2]

            return sp.fft.fftn(Antisym_Omega_Q + advectiv_deriv, axes=range(-self.dim, 0)) + N_f

        else:
            raise Exception("This dimension is not implemented at the moment")

    def calc_nonlinear_evolution_term_no_flow_f(self,Q,t):
        """Calculates the non-linear evolution function for the nematic without the flow field
        
        Args:
            Q: the nematic orderparameter  (numpy.narray)
        
        Returns:
            The non-linear evolution function evaluated in Fourier space (numpy.narray) 
        """
        Q2 = self.calc_trace_Q2(Q)
        if self.dim ==2 or self.C == 0:
            return -2*self.A*sp.fft.fftn(Q2 *Q,axes =(range(-self.dim,0)))/self.gamma

        elif self.dim == 3:
            C_term = np.zeros((5, self.xRes, self.yRes, self.zRes))

            C_term[0] = self.C * (Q[0] ** 2 + Q[1] ** 2 + Q[2] ** 2 - 1 / 3 * Q2)
            C_term[1] = self.C * (Q[0] * Q[1] + Q[1] * Q[3] + Q[2] * Q[4])
            C_term[2] = self.C * (Q[1] * Q[4] - Q[2] * Q[3])
            C_term[3] = self.C * (Q[1] ** 2 + Q[3] ** 2 + Q[4] ** 2 - 1 / 3 * Q2)
            C_term[4] = self.C * (Q[1] * Q[2] - Q[4] * Q[0])
            return -2*self.A*sp.fft.fftn(Q2 *Q,axes =(range(-self.dim,0)))/self.gamma + sp.fft.fftn(C_term ,axes =(range(-self.dim,0)))/self.gamma


##### evolvers
    def evolve_nematic(self, number_of_steps, method= 'ETD2RK'):
        '''Evolves the nematic system
        
        Args:
            number_of_steps: the number of time steps that we are evolving the equation  (int)
            method: the integration method we want to use. ETD2RK is sett as default  (string)
        
        Returns:
            Updates the fields self.Q and self.Q_f
        '''
        omega_f = (self.A * self.B - self.K * self.k2) / self.gamma

        if method == 'ETD2RK':
            integrating_factors_f = self.calc_evolution_integrating_factors_ETD2RK(omega_f)
            solver = self.evolve_ETD2RK_loop

        elif method == 'ETD4RK':
            integrating_factors_f = self.calc_evolution_integrating_factors_ETD4RK(omega_f)
            solver = self.evolve_ETD4RK_loop
        else:
            raise Exception('Mehtod is not implemented')
        for n in tqdm(range(number_of_steps), desc='evolving the active nematic'):
            self.Q, self.Q_f = solver(integrating_factors_f,
                                                       self.calc_nonlinear_evolution_function_f,
                                                       self.Q, self.Q_f)
        self.Q = np.real(self.Q)
        self.conf_velocity(self.Q)

    def evolve_nematic_no_flow(self,number_of_steps,method = 'ETD2RK'):
        ''' Evolves the nematic system without the flow field
        
        Args:
            number_of_steps: the number of time steps that we are evolving the equation  (int)
            method: the integration method we want to use. ETD2RK is sett as default  (string)
        
        Returns:
            Updates the fields self.Q and self.Q_f
        '''
        omega_f = (self.A * self.B - self.K * self.k2) / self.gamma

        if method == 'ETD2RK':
            integrating_factors_f = self.calc_evolution_integrating_factors_ETD2RK(omega_f)
            solver = self.evolve_ETD2RK_loop

        elif method == 'ETD4RK':
            integrating_factors_f = self.calc_evolution_integrating_factors_ETD4RK(omega_f)
            solver = self.evolve_ETD4RK_loop
        else:
            raise Exception('Mehtod is not implemented')

        for n in tqdm(range(number_of_steps), desc='evolving the active nematic'):
            self.Q, self.Q_f = solver(integrating_factors_f,self.calc_nonlinear_evolution_term_no_flow_f,
                                                           self.Q, self.Q_f)
        self.Q = np.real(self.Q)


    ## Disclination tracking
    def calc_disclination_density_nematic(self):
        """
        Calculates the disclination density for the nematic. Note that in three dimension the disclination density is a tensor

        Args:
            None

        Returns:
            The disclination density (numpy.narray) 
        """
        if self.dim == 2:
            psi0 = np.sqrt(self.B)/2
            psi =[self.Q[0],self.Q[1]]
            return self.calc_defect_density(psi, psi0)

        elif self.dim == 3:
            D = np.zeros((self.dim,self.dim,self.xRes,self.yRes,self.zRes))
            term_trace = np.sum(np.real(sp.fft.ifftn(1j*self.k[k]* self.get_sym_tl(self.Q_f,k,a)))*
                                    np.real(sp.fft.ifftn(1j*self.k[l] * self.get_sym_tl(self.Q_f,l,a)))
                                    - np.real(sp.fft.ifftn(1j*self.k[k]* self.get_sym_tl(self.Q_f,l,a)))*
                                    np.real(sp.fft.ifftn(1j*self.k[l] * self.get_sym_tl(self.Q_f,k,a)))
                                    for k in range(self.dim) for a in range(self.dim) for l in range(self.dim))

            for gam in range(self.dim):
                for i in range(self.dim):
                    D[gam, i] = 2*np.sum(np.real(sp.fft.ifftn(1j*self.k[gam]* self.get_sym_tl(self.Q_f,k,a)))*
                                    np.real(sp.fft.ifftn(1j*self.k[k] * self.get_sym_tl(self.Q_f,i,a)))
                                    - np.real(sp.fft.ifftn(1j*self.k[gam]* self.get_sym_tl(self.Q_f,i,a)))*
                                    np.real(sp.fft.ifftn(1j*self.k[k] * self.get_sym_tl(self.Q_f,k,a)))
                                    for k in range(self.dim) for a in range(self.dim))
                    if gam == i:
                        D[gam,i] += term_trace
            S0 = self.calc_equilibrium_S()
            return D/(S0**2 *np.pi)
        else:
            raise Exception("Only two and three dimensions are currently supported")


    def calc_disclination_density_decoupled(self):
        """Calculates the decoupled disclination density

        Args:
            None
        
        Returns:
            The disclination density (numpy.narray)
        """ 
        if self.dim == 3:
            rho = self.calc_disclination_density_nematic()


            omega = np.sqrt(np.sum(rho[i,j]*rho[i,j] for i in range(self.dim) for j in range(self.dim)) )

            DDT = np.zeros((self.xRes,self.yRes,self.zRes,self.dim,self.dim))
            DTD = np.zeros((self.xRes,self.yRes,self.zRes,self.dim,self.dim))

            for i in range(self.dim):
                for j in range(self.dim):
                    DDT[:,:,:,i,j] = np.sum(rho[i,k]*rho[j,k] for k in range(self.dim))
                    DTD[:, :, :, i, j] = np.sum(rho[k,i] * rho[ k,j] for k in range(self.dim))

            vals_1,vecs_1 =  numpy.linalg.eigh(DDT)
            vals_2, vecs_2 = numpy.linalg.eigh(DTD)

            Omega_R = np.transpose(vecs_1[:,:,:,:,2], (3,0,1,2))
            T = np.transpose(vecs_2[:,:,:,:,2], (3,0,1,2))
            trRho = np.sum(rho[i,i] for i in range(self.dim))
            return omega, Omega_R, T, trRho

    def calc_g_matrix(self,dt_Q):
        """Calculates the matrix g, that is used to find the disclination velocity in 3D

                Args:
                    None

                Returns:
                    The disclination density (numpy.narray)
                """
        if not self.dim == 3:
            raise Exception("The g matrix is only relevant in 3D")
        g =  np.zeros((self.dim,self.dim,self.xRes,self.yRes,self.zRes))
        for gamma in range(self.dim):
            for k in range(self.dim):
                g[gamma,k] = np.sum(levi_civita_symbol(gamma,mu,nu) * self.get_sym_tl(dt_Q,mu,alpha)
                       * np.real(sp.fft.ifftn(1j*self.k[k]* self.get_sym_tl(self.Q_f,nu,alpha)))
                       for mu in range(self.dim) for nu in range(self.dim) for alpha in range(self.dim))
        return g


    def calc_dt_psi(self,Q_prev,delta_t):
        """Calculates the time derivative of the order parameter as a complex field

        Args:
            Q_prev: the order parameter at the previous time step (numpy.narray)
            delta_t: the time step (float)
        
        Returns:
            The time derivative of the order parameter (numpy.narray)
        """

        dt_Q = (self.Q -Q_prev)/delta_t
        return dt_Q[0] + 1j*dt_Q[1]

    def calc_equilibrium_S(self):
        '''Calculates the strength of nematic order S

        Args:
            None

        Returns:
            equilibrium value of S (numpy.narray)
        '''
        if self.dim == 2:
            return  np.sqrt(self.B)

        elif self.dim == 3:
            S0 = 1 / 8 * self.C / self.A + 1 / 2 * np.sqrt(self.C ** 2 / (16 * self.A ** 2) + 3 * self.B)
            return S0

    def calc_order_and_director(self):
        """Calculates the amount of order (S) and the director field (n)

        Args:
            None

        Returns:
            Tuple consisting of 
                - Amount of order (scalar field) 
                - the director field (vector field)
        """
        if self.dim == 2:
            psi_n = self.Q[0] + 1j*self.Q[1]
            angle = np.angle(psi_n)
            S =2 * np.sqrt((self.Q[0]) ** 2 + (self.Q[1]) ** 2)
            return S, [np.cos(angle/2),np.sin(angle/2)]
        elif self.dim ==3:
        ## need to construct a matrix
            Q_eig = numpy.zeros((self.xRes,self.yRes,self.zRes,self.dim,self.dim))
            for i in range(self.dim):
                for j in range(self.dim):
                    Q_eig[:,:,:,i,j] = self.get_sym_tl(self.Q,i,j)

            eigvals, eigvectors = numpy.linalg.eigh(Q_eig)
            S = 3/2 *eigvals[:,:,:,2]
            n = np.transpose(eigvectors[:,:,:,:,2], (3,0,1,2))

            return S, n

    def calc_disclination_velocity_field(self, dt_Q, T =None, Omega_R = None, g =None, omega=None):
        """
        Calculates the velocity field of the disclination in two dimensions
        
        Args:
            dt_Q: the time derivative of the order parameter (numpy.narray)

        Returns:
            The velocity field (numpy.narray).
             Note in 2D this returns a field while in 3D this is returning a vector
        """
        if self.dim ==2:

            psi = self.Q[0] +1j*self.Q[1]

            dt_psi = dt_Q[0] + 1j * dt_Q[1]

            return self.calc_defect_velocity_field([np.real(psi), np.imag(psi)],
                                                   [np.real(dt_psi), np.imag(dt_psi)])
        if self.dim ==3:
            if (T is not None) and (Omega_R is not None) and (g is not None) and (omega is not None):
                dot_Omega_g = np.zeros((self.dim))
                for i in range(self.dim):
                    dot_Omega_g[i] = np.sum(Omega_R[k] * g[k,i] for k in range(self.dim))

                dislocation_velocity = np.zeros((self.dim))
                for i in range(self.dim):
                    dislocation_velocity[i] = np.sum(
                        levi_civita_symbol(i,j,k)*T[j]* dot_Omega_g[k] for j in range(self.dim)
                        for k in range(self.dim)
                    )
                return 2*dislocation_velocity/omega


    def calc_disclination_polarization_field(self):
        """Calculates the polarization field of the disclination in two dimensions

        Args:
            None
        
        Returns:
            The polarization field (numpy.narray)
        """
        ex = np.real(sp.fft.ifftn(1j*self.k[0]*self.Q_f[0] + 1j*self.k[1]*self.Q_f[1]))
        ey = np.real(sp.fft.ifftn(1j * self.k[0] * self.Q_f[1] - 1j * self.k[1] * self.Q_f[0]))
        return np.array([ex,ey])

    def calc_disclination_nodes_nem(self, dt_Q=None,polarization = None,charge_tolerance=0.1):
        """Calculates the positions and charges of disclination nodes based on the disclination density.
        
        Args:
            dt_Q: The time derivative of the order parameter. If not provided, the velocity of the disclination nodes will not be calculated. (numpy.narray, optional)
            polarization: The polarization field for positive defects in 2D. If provided the direction of the positive defects are shown. (numpy.narray, optional)
            charge_tolerance: The tolerance given to the defect finding algorithm in 3D. Default 0.1 (float, optional)
        
        Returns:
            A list of dictionaries representing the disclination nodes. Each dictionary contains the following keys:
                  - 'position_index': The position index of the disclination node in the disclination density array.
                  - 'charge': The charge of the disclination node.
                  - 'position': The position of the disclination node as a list [x, y].
                  - 'velocity': The velocity of the disclination node as a list [vx, vy].
            In 3F the charge key is removed and we instead have
                  -'tangent_vector': The tangent vector of the dislocation
                  -'Rotation_vector': The rotation vector of the dislocation
        """

        # Calculate disclination density
        if self.dim == 2:

            rho = self.calc_disclination_density_nematic()

            if dt_Q is not None:
                velocity_field = self.calc_disclination_velocity_field(dt_Q)


            disclination_nodes = self.calc_defect_nodes(np.abs(rho))
            for disclination in disclination_nodes:
                disclination['charge'] = np.sign(rho[disclination['position_index']])

                if dt_Q is not None:
                    disclination['velocity'] = [velocity_field[0][disclination['position_index']],
                                          velocity_field[1][disclination['position_index']]]
                else:
                    disclination['velocity'] = [float('nan'), float('nan')]

                if disclination['charge'] >0 and polarization is not None:
                    disclination['polarization'] = [polarization[0][disclination['position_index']]
                        ,polarization[1][disclination['position_index']]]
                else:
                    disclination['polarization'] = [float('nan'), float('nan')]

        elif self.dim == 3:
            omega, Omega_R, T, trD = self.calc_disclination_density_decoupled()
            S0 = self.calc_equilibrium_S()
            print(S0)
            disclination_nodes = self.calc_defect_nodes(omega,charge_tolerance=charge_tolerance)
            position_list = []
            if dt_Q is not None:
                g_matrix = self.calc_g_matrix(dt_Q)
                print(g_matrix.shape)

            for disclination in disclination_nodes:

                tangent_vector = np.array([T[i][disclination['position_index']] for i in range(3)])
                rotation_vector = np.array([Omega_R[i][disclination['position_index']] for i in range(3)])
                omega_at_dislocation = omega[disclination['position_index']]


                for i in range(len(position_list)):
                    pos = position_list[i]
                    if np.sqrt(sum( (disclination['position'][i] -pos[i])**2 for i in range(self.dim) )) <  5*self.a0:
                        tan_neight = disclination_nodes[i]['tangent_vector']
                        if np.sum((tan_neight[j] -tangent_vector[j] )**2 -(tan_neight[j] + tangent_vector[j])**2 for j in range(self.dim)) > 0:

                            tangent_vector = -1* tangent_vector
                        break

                if np.sign(np.sum([tangent_vector[i]*rotation_vector[i] for i in range(self.dim)])) != np.sign(trD[disclination['position_index']]):
                    rotation_vector = -1*rotation_vector

                if dt_Q is not None:
                    g = np.zeros((self.dim,self.dim))
                    for i in range(self.dim):
                        for j in range(self.dim):
                            g[i,j] = g_matrix[i,j][disclination['position_index']]

                    disclination_velocity = self.calc_disclination_velocity_field(dt_Q,T=tangent_vector, Omega_R=rotation_vector, g= g,omega=omega_at_dislocation)
                    disclination['velocity'] = disclination_velocity

                disclination['tangent_vector'] = tangent_vector
                disclination['rotation_vector'] = rotation_vector

                position_list.append(disclination['position'])

        return disclination_nodes

    def plot_field_velocity_and_director(self, field, velocity, director, **kwargs):
        if self.plot_lib == 'plotly':
            return plot_field_velocity_and_director_plotly(self, field, velocity, director, **kwargs)
        elif self.plot_lib == 'matplotlib':
            return plot_field_velocity_and_director_matplotlib(self, field, velocity, director, **kwargs)

--- End of file: comfit\nematic_liquid_crystal\nematic_liquid_crystal.py ---

--- Start of file: comfit\nematic_liquid_crystal\plot_field_velocity_and_director_matplotlib.py ---
import numpy as np
import matplotlib.pyplot as plt
from comfit.tool.tool_complete_field import tool_complete_field
from comfit.tool.tool_set_plot_axis_properties_matplotlib import tool_set_plot_axis_properties_matplotlib

def plot_field_velocity_and_director_matplotlib(self, field, velocity, director, **kwargs):
    """Plot the fields, velocity, and director field in 2 dimensions

    Args:
        field (ndarray): The field to be plotted.
        velocity (ndarray): The velocity to be plotted.
        director (ndarray): The director to be plotted.
        **kwargs: Keyword arguments for the plot.
            See https://comfitlib.com/ClassBaseSystem/
            for a full list of keyword arguments.

    Returns:
        A tuple consisting of
            - The figure
            - The axes with the plotted field, velocity, and director. ax (Axes)

    Raises:
        Exception: If the dimension is other than 2.
    """
    if field.dtype == bool:
        field = field.astype(float)

    # Check if the vector field is complex
    if np.iscomplexobj(field):
        print(
                "\033[91mWarning: the provided field was complex. This might be due to residual imaginary parts from the Fourier transform. The imaginary parts will be removed.\033[0m")
        print('Max imaginary part: ', np.max(np.imag(field)))
    field = np.real(field)

    # Check if an axis object is provided
    fig = kwargs.get('fig', plt.gcf())
    ax = kwargs.get('ax', None)

    # Kewyord arguments
    colorbar = kwargs.get('colorbar', True)

    # Extend the field if not a complete array is given
    field = tool_complete_field(self, field)

    if self.dim == 2:

        # Keyword arguments particular to the 2D case
        kwargs['grid'] = kwargs.get('grid', False)

        if ax == None:
            fig.clf()
            ax = plt.gcf().add_subplot(111)

        colormap = kwargs.get('colormap', 'viridis')

        if colormap == 'bluewhitered':
            colormap = tool_colormap_bluewhitered()

        elif colormap == 'sunburst':
            colormap = tool_colormap_sunburst()
        else:
            colormap = plt.get_cmap(colormap)

        X, Y = np.meshgrid(self.x, self.y, indexing='ij')
        pcm = ax.pcolormesh(X / self.a0, Y / self.a0, field, shading='gouraud', cmap=colormap)

        xlim = [self.xmin, self.xmax - self.dx]
        ylim = [self.ymin, self.ymax - self.dy]

        limits_provided = False
        if 'xlim' in kwargs:
            xlim = kwargs['xlim']
            limits_provided = True
        else:
            if 'xmin' in kwargs:
                xlim[0] = kwargs['xmin']
                limits_provided = True

            if 'xmax' in kwargs:
                xlim[1] = kwargs['xmax']
                limits_provided = True

        if 'ylim' in kwargs:
            ylim = kwargs['ylim']
            limits_provided = True
        else:
            if 'ymin' in kwargs:
                ylim[0] = kwargs['ymin']
                limits_provided = True

            if 'ymax' in kwargs:
                ylim[1] = kwargs['ymax']
                limits_provided = True
        if limits_provided:
            region_to_plot = np.zeros(self.dims).astype(bool)
            region_to_plot[(xlim[0] <= X) * (X <= xlim[1]) * (ylim[0] <= Y) * (Y <= ylim[1])] = True
            vlim = [np.min(field[region_to_plot]), np.max(field[region_to_plot])]

        else:
            vlim = [np.min(field), np.max(field)]

        # Set the value limitses
        if 'vlim' in kwargs:
            vlim = kwargs['vlim']
        else:
            if 'vmin' in kwargs:
                vlim[0] = kwargs['vmin']
            if 'vmax' in kwargs:
                vlim[1] = kwargs['vmax']

        if vlim[1] - vlim[0] < 1e-10:
            vlim = [vlim[0] - 0.05, vlim[1] + 0.05]

        pcm.set_clim(vmin=vlim[0], vmax=vlim[1])

        if 'vlim_symmetric' in kwargs:
            vlim_symmetric = kwargs['vlim_symmetric']
            if vlim_symmetric:
                cmax = abs(field).max()
                cmin = -cmax
                pcm.set_clim(vmin=cmin, vmax=cmax)

        colorbar = kwargs.get('colorbar', True)

        if colorbar:
            cbar = plt.colorbar(pcm, ax=ax)



        ax.streamplot(X.T, Y.T, (velocity[0]).T, (velocity[1]).T, color='w')
        ax.quiver(X, Y, director[0], director[1], headwidth=0, scale=50)
        ax.quiver(X, Y, -director[0], -director[1], headwidth=0, scale=50)
        ax.set_aspect('equal')

    else:
        raise Exception("This plotting function is currently only implemented in 2D! ")

    kwargs['fig'] = fig
    tool_set_plot_axis_properties_matplotlib(self, **kwargs)
    return fig, ax
--- End of file: comfit\nematic_liquid_crystal\plot_field_velocity_and_director_matplotlib.py ---

--- Start of file: comfit\nematic_liquid_crystal\plot_field_velocity_and_director_plotly.py ---
import numpy as np
import plotly.graph_objects as go
import plotly.figure_factory as ff
from comfit.tool.tool_complete_field import tool_complete_field
from comfit.tool.tool_set_plot_axis_properties_plotly import tool_set_plot_axis_properties_plotly
from comfit.tool.tool_add_spacing_2D import tool_add_spacing_2D

from comfit.plot.plot_field_plotly import plot_field_plotly


def plot_field_velocity_and_director_plotly(self, field, velocity, director, **kwargs):
    """Plot the fields, velocity, and director field in 2 dimensions using Plotly.

    Args:
        field (ndarray): The field to be plotted.
        velocity (ndarray): The velocity to be plotted.
        director (ndarray): The director to be plotted.
        **kwargs: Keyword arguments for the plot.

    Returns:
        The plotly figure (go.Figure).
    """
    if field.dtype == bool:
        field = field.astype(float)

    # Check if the vector field is complex
    if np.iscomplexobj(field):
        print(
                "\033[91mWarning: the provided field was complex. This might be due to residual imaginary parts from the Fourier transform. The imaginary parts will be removed.\033[0m")
        print('Max imaginary part: ', np.max(np.imag(field)))
    field = np.real(field)

    # Check if an axis object is provided
    fig = kwargs.get('fig', go.Figure())

    # Extend the field if not a complete array is given
    field = tool_complete_field(self, field)

    kwargs['colormap'] = kwargs.get('colormap', 'Picnic')
    kwargs['vlim_symmetric'] = kwargs.get('vlim_symmetric', True)

    fig_tmp = plot_field_plotly(self, field, **kwargs)
    fig.add_trace(fig_tmp.data[0].update(showlegend=False))

    # Plot the director field using quiver
    X, Y = np.meshgrid(self.x, self.y, indexing='ij')

    spacing = kwargs.get('spacing', 5)

    X, Y, U, V = tool_add_spacing_2D(X,Y,director[0],director[1],spacing)

    u = U.flatten()
    v = V.flatten()

    magnitude = np.sqrt(u**2 + v**2)
    magnitude_max = max(np.max(magnitude),1e-12)
    magnitude_normalized = magnitude/magnitude_max

    angle = np.arctan2(v, u)
    direction = np.array([np.cos(angle), np.sin(angle)]).T
    
    fig.add_trace(go.Scatter(
        x=X.flatten()/self.a0,
        y=Y.flatten()/self.a0,
        mode='markers',
        marker=dict(symbol='line-ew', 
            angle=90-angle.flatten()*180/np.pi, 
            size=2*spacing*magnitude_normalized.flatten(), 
            sizemode='diameter',
            color=magnitude.flatten(), 
            cmin=0,
            cmax=magnitude_max,
            line=dict(color='black')
            ),
            hovertemplate='<b>x:</b> %{x:.2f}a0<br>' +
                '<b>y:</b> %{y:.2f}a0<br>' +
                '<b>nx:</b> %{customdata[0]:.2e}<br>' +  
                '<b>ny:</b> %{customdata[1]:.2e}<br>',
            customdata=np.stack((u.flatten(), v.flatten()), axis=-1), showlegend=False  # Adding ux, uy and u as customdata
        )
        )

    fig_tmp = ff.create_streamline(x=self.x/self.a0, 
                                    y=self.y.flatten()/self.a0, 
                                    u=velocity[0].T, 
                                    v=velocity[1].T, 
                                    arrow_scale=1, 
                                    density=1)
        
    for trace in fig_tmp.data:
        trace.showlegend = False

    fig.add_trace(fig_tmp.data[0])

    kwargs['fig'] = fig
    tool_set_plot_axis_properties_plotly(self, **kwargs)
    return fig
--- End of file: comfit\nematic_liquid_crystal\plot_field_velocity_and_director_plotly.py ---

--- Start of file: comfit\nematic_liquid_crystal\__init__.py ---
from .nematic_liquid_crystal import NematicLiquidCrystal
--- End of file: comfit\nematic_liquid_crystal\__init__.py ---

--- Start of file: comfit\phase_field_crystal\phase_field_crystal.py ---
import numpy as np
from comfit.core.base_system import BaseSystem
from tqdm import tqdm
from scipy.optimize import fsolve
import scipy as sp
import matplotlib.pyplot as plt
from pprint import pprint
import copy
from scipy.optimize import curve_fit

# Plot functions
from comfit.plot.plot_field_plotly import plot_field_plotly
from comfit.plot.plot_field_matplotlib import plot_field_matplotlib

from comfit.tool.tool_print_in_color import tool_print_in_color

class PhaseFieldCrystal(BaseSystem):

    def __init__(self, dim, **kwargs):
        """
        Initializes a system to simulate a Phase Field Crystal.
        
        This class is the base of the other phase field crystal models implemented in comfit.
        
        Parameters
        ----------
        dim : int
            The dimension of the system.
        kwargs : dict
            Keyword arguments to set additional parameters. See https://comfitlib.com/ClassPhaseFieldCrystal/
            
        Returns
        -------
        PhaseFieldCrystal
            The system object representing the phase field crystal simulation.
        """
        
        # First initialize the BaseSystem class
        super().__init__(dim, **kwargs)

        # If there are additional arguments provided, set them as attributes
        for key, value in kwargs.items():
            setattr(self, key, value)
            
        self.dislocation_charges = np.array(
            [[np.round(np.dot(an, qn) / (2 * np.pi), decimals=8) for qn in self.q] for an in self.a])

        # Elastic constant
        if ((self.dim - 1) * self.el_lambda + 2 * self.el_mu + self.el_gamma)!=0:
            self.el_nu = self.el_lambda / ((self.dim - 1) * self.el_lambda + 2 * self.el_mu + self.el_gamma)
        else:
            self.el_nu = 0

        self.Phi = 2*sum(np.array(self.eta0)**2)

    def __str__(self):
        """
        Returns a string representation of the object.
        
        Returns
        -------
        str
            A string representation of the object.
        """
        string = "-------------------------------\n"
        string += "Phase Field Crystal instance\n"
        string += "-------------------------------\n"
        string += "Type: " + self.type + "\n"
        if self.dim == 1:
            string += "(nx) = (" + str(self.nx) + ")\n"
        elif self.dim == 2:
            string += "(nx, ny) = (" + str(self.nx) + ", " + str(self.ny) + ")\n"
        elif self.dim == 3:
            string += "(nx, ny, nz) = (" + str(self.nx) + ", " + str(self.ny) + ", " + str(self.nz) + ")\n"
        string += "micro_resolution: " + str(self.micro_resolution) + "\n"
        string += "-------------------------------\n"
        string += "Parameters\n"
        string += "-------------------------------\n"
        string += "r: " + str(self.r) + "\n"
        string += "t: " + str(self.t) + "\n"
        string += "v: " + str(self.v) + "\n"
        string += "-------------------------------\n"
        string += "Proto amplitudes\n"
        string += "-------------------------------\n"
        string += "psi0: " + str(self.psi0) + "\n"
        if self.type == 'PhaseFieldCrystal1DPeriodic':
            string += "A: " + str(self.A) + "\n"
        elif self.type == 'PhaseFieldCrystal2DTriangular':
            string += "A: " + str(self.A) + "\n"
        elif self.type == 'PhaseFieldCrystal2DSquare':
            string += "A: " + str(self.A) + "\n"
            string += "B: " + str(self.B) + "\n"
        elif self.type == 'PhaseFieldCrystal3DBodyCenteredCubic':
            string += "A: " + str(self.A) + "\n"
        elif self.type == 'PhaseFieldCrystal3DFaceCenteredCubic':
            string += "A: " + str(self.A) + "\n"
            string += "B: " + str(self.B) + "\n"
        elif self.type == 'PhaseFieldCrystal3DSimpleCubic':
            string += "A: " + str(self.A) + "\n"
            string += "B: " + str(self.B) + "\n"
            string += "C: " + str(self.C) + "\n"
        string += "-------------------------------\n"

        return string
    
    #######################################################
    ############ CONFIGURATION FUNCTIONS #################
    #######################################################

    def conf_PFC_from_amplitudes(self, eta=None, rotation=None):
        """
        Configures the PFC from the amplitudes.
        
        Parameters
        ----------
        eta : array_like, optional
            The amplitudes to configure the PFC from.
        rotation : array_like, optional
            Rotation vector to apply to the crystal.
        
        Returns
        -------
        None
            Configures self.psi and self.psi_f.
        """
        self.psi = self.calc_PFC_from_amplitudes(eta, rotation)
        self.psi_f = self.fft(self.psi)

    def conf_advect_PFC(self, u):
        """
        Advects the PFC according to the displacement field u.
        
        Parameters
        ----------
        u : array_like
            The displacement field to advect the PFC with.
        
        Returns
        -------
        None
            Updates the PFC state.
        """
        self.psi = np.real(self.calc_advect_field(self.psi, u, self.psi_f))
        self.psi_f = self.fft(self.psi)

    def conf_apply_distortion(self, distortion, update_q_and_a_vectors=False):
        """
        Applies a distortion to the PFC.
        
        Parameters
        ----------
        distortion : float or array_like
            The distortion to apply to the PFC. Can be a float for uniform distortion
            or a matrix for more complex distortions.
        update_q_and_a_vectors : bool, optional
            Whether to update the q-vectors and a-vectors, by default False
        
        Returns
        -------
        None
            Updates the PFC state.
        """
        if self.dim == 1:
            self.k[0] = self.k[0]/(1+distortion)
            self.dif[0] = self.dif[0]/(1+distortion)
            self.x = self.x*(1+distortion)
            self.xmax = self.xmax*(1+distortion)
            self.xmin = self.xmin*(1+distortion)
            self.size_x = self.size_x*(1+distortion)
            self.dx = self.dx*(1+distortion)
            self.volume = self.volume*(1+distortion)

        elif self.dim == 2:
            
            distortion_is_shear = False
            if isinstance(distortion, float):
                distortion_matrix = np.array([[1+distortion,0],[0,1+distortion]])
            else:
                distortion_matrix = np.eye(2) + np.array(distortion)

                if abs(distortion_matrix[0,1]) + abs(distortion_matrix[1,0])> 0:
                    distortion_is_shear = True

            # Updating the k and dif vectors
            inverse_distortion_matrix = np.linalg.inv(distortion_matrix)

            if distortion_is_shear:  
                self.bool_is_shear_distorted = True

                # Creating 2D meshgrid
                X,Y = np.meshgrid(self.x.flatten(),self.y.flatten(), indexing='ij')

                # Applying the strain
                X0 = X.copy()
                Y0 = Y.copy()
                X = distortion_matrix[0,0]*X0 + distortion_matrix[0,1]*Y0
                Y = distortion_matrix[1,0]*X0 + distortion_matrix[1,1]*Y0

                # Updating the x and y coordinates
                self.X = X
                self.Y = Y

                k00 = self.k[0].copy()
                k01 = self.k[1].copy()
                self.k[0] = k00*inverse_distortion_matrix[0,0] + k01*inverse_distortion_matrix[0,1]
                self.k[1] = k00*inverse_distortion_matrix[1,0] + k01*inverse_distortion_matrix[1,1]

            else:
                
                x0 = self.x.copy()
                y0 = self.y.copy()
                self.x = x0*distortion_matrix[0,0]
                self.y = y0*distortion_matrix[1,1] 

                X = self.x
                Y = self.y

                k00 = self.k[0].copy()
                k01 = self.k[1].copy()
                self.k[0] = k00*inverse_distortion_matrix[0,0]
                self.k[1] = k01*inverse_distortion_matrix[1,1]

            self.dif[0] = 1j*self.k[0]
            self.dif[1] = 1j*self.k[1]

            if update_q_and_a_vectors:
                    a00 = self.a[:,0].copy()
                    a01 = self.a[:,1].copy()
                    self.a[:,0] = a00*distortion_matrix[0,0] + a01*distortion_matrix[0,1]
                    self.a[:,1] = a00*distortion_matrix[1,0] + a01*distortion_matrix[1,1]

                    q00 = self.q[:,0].copy()
                    q01 = self.q[:,1].copy()
                    self.q[:,0] = q00*inverse_distortion_matrix[0,0] + q01*inverse_distortion_matrix[0,1]
                    self.q[:,1] = q00*inverse_distortion_matrix[1,0] + q01*inverse_distortion_matrix[1,1]

            # Updating the dx and dy
            original_dx = self.dx
            original_dy = self.dy

            self.dx = np.sqrt((distortion_matrix[0,0]*original_dx)**2 + (distortion_matrix[0,1]*original_dy)**2)
            self.dy = np.sqrt((distortion_matrix[1,0]*original_dx)**2 + (distortion_matrix[1,1]*original_dy)**2)

            # Updating the size_x and size_y
            original_size_x = self.size_x
            original_size_y = self.size_y
            self.size_x = np.sqrt((distortion_matrix[0,0]*original_size_x)**2 + (distortion_matrix[0,1]*original_size_y)**2)
            self.size_y = np.sqrt((distortion_matrix[1,0]*original_size_x)**2 + (distortion_matrix[1,1]*original_size_y)**2)

            # Updating the x and y coordinate limits
            self.xmax = np.max(X)
            self.xmin = np.min(X)

            self.ymax = np.max(Y)
            self.ymin = np.min(Y)

            volume_factor = np.linalg.det(distortion_matrix)
            self.dV = self.dV*volume_factor
            self.volume = self.volume*volume_factor


        elif self.dim == 3:
            # Distortion is shear
            distortion_is_shear = False
            if isinstance(distortion, float):
                distortion_matrix = np.array([[1+distortion,0,0],[0,1+distortion,0],[0,0,1+distortion]])
            else:
                distortion_matrix = np.eye(3) + np.array(distortion)

                if abs(distortion_matrix[0,1]) +\
                    abs(distortion_matrix[1,0]) + \
                    abs(distortion_matrix[0,2]) + \
                    abs(distortion_matrix[2,0]) + \
                    abs(distortion_matrix[1,2]) + \
                    abs(distortion_matrix[2,1]) > 0:
                    distortion_is_shear = True

            # Updating the k and dif vectors
            inverse_distortion_matrix = np.linalg.inv(distortion_matrix)

            # if distortion_is_shear:
            if distortion_is_shear:  
                self.bool_is_shear_distorted = True

                # Creating 2D meshgrid
                X,Y,Z = np.meshgrid(self.x.flatten(),self.y.flatten(), self.z.flatten(), indexing='ij')

                # Applying the strain
                X0 = X.copy()
                Y0 = Y.copy()
                Z0 = Z.copy()

                X = distortion_matrix[0,0]*X0 + distortion_matrix[0,1]*Y0 + distortion_matrix[0,2]*Z0
                Y = distortion_matrix[1,0]*X0 + distortion_matrix[1,1]*Y0 + distortion_matrix[1,2]*Z0
                Z = distortion_matrix[2,0]*X0 + distortion_matrix[2,1]*Y0 + distortion_matrix[2,2]*Z0

                # Updating the x and y coordinates
                self.X = X
                self.Y = Y
                self.Z = Z

                k00 = self.k[0].copy()
                k01 = self.k[1].copy()
                k02 = self.k[2].copy()
                self.k[0] = k00*inverse_distortion_matrix[0,0] + k01*inverse_distortion_matrix[0,1] + k02*inverse_distortion_matrix[0,2]
                self.k[1] = k00*inverse_distortion_matrix[1,0] + k01*inverse_distortion_matrix[1,1] + k02*inverse_distortion_matrix[1,2]
                self.k[2] = k00*inverse_distortion_matrix[2,0] + k01*inverse_distortion_matrix[2,1] + k02*inverse_distortion_matrix[2,2]

            else:
                
                x0 = self.x.copy()
                y0 = self.y.copy()
                z0 = self.z.copy()

                self.x = x0*distortion_matrix[0,0]
                self.y = y0*distortion_matrix[1,1] 
                self.z = z0*distortion_matrix[2,2]

                X = self.x
                Y = self.y
                Z = self.z

                k00 = self.k[0].copy()
                k01 = self.k[1].copy()
                k02 = self.k[2].copy()

                self.k[0] = k00*inverse_distortion_matrix[0,0]
                self.k[1] = k01*inverse_distortion_matrix[1,1]
                self.k[2] = k02*inverse_distortion_matrix[2,2]

            self.dif[0] = 1j*self.k[0]
            self.dif[1] = 1j*self.k[1]
            self.dif[2] = 1j*self.k[2]

            if update_q_and_a_vectors:
                    a00 = self.a[:,0].copy()
                    a01 = self.a[:,1].copy()
                    a02 = self.a[:,2].copy()
                    self.a[:,0] = a00*distortion_matrix[0,0] + a01*distortion_matrix[0,1] + a02*distortion_matrix[0,2]
                    self.a[:,1] = a00*distortion_matrix[1,0] + a01*distortion_matrix[1,1] + a02*distortion_matrix[1,2]
                    self.a[:,2] = a00*distortion_matrix[2,0] + a01*distortion_matrix[2,1] + a02*distortion_matrix[2,2]

                    q00 = self.q[:,0].copy()
                    q01 = self.q[:,1].copy()
                    q02 = self.q[:,2].copy()
                    self.q[:,0] = q00*inverse_distortion_matrix[0,0] + q01*inverse_distortion_matrix[0,1] + q02*inverse_distortion_matrix[0,2]
                    self.q[:,1] = q00*inverse_distortion_matrix[1,0] + q01*inverse_distortion_matrix[1,1] + q02*inverse_distortion_matrix[1,2]
                    self.q[:,2] = q00*inverse_distortion_matrix[2,0] + q01*inverse_distortion_matrix[2,1] + q02*inverse_distortion_matrix[2,2]

            # Updating the dx and dy
            original_dx = self.dx
            original_dy = self.dy
            original_dz = self.dz

            self.dx = np.sqrt((distortion_matrix[0,0]*original_dx)**2 + (distortion_matrix[0,1]*original_dy)**2 + (distortion_matrix[0,2]*original_dz)**2)
            self.dy = np.sqrt((distortion_matrix[1,0]*original_dx)**2 + (distortion_matrix[1,1]*original_dy)**2 + (distortion_matrix[1,2]*original_dz)**2)
            self.dz = np.sqrt((distortion_matrix[2,0]*original_dx)**2 + (distortion_matrix[2,1]*original_dy)**2 + (distortion_matrix[2,2]*original_dz)**2)

            # Updating the size_x and size_y
            original_size_x = self.size_x
            original_size_y = self.size_y
            original_size_z = self.size_z

            self.size_x = np.sqrt((distortion_matrix[0,0]*original_size_x)**2 + (distortion_matrix[0,1]*original_size_y)**2 + (distortion_matrix[0,2]*original_size_z)**2)
            self.size_y = np.sqrt((distortion_matrix[1,0]*original_size_x)**2 + (distortion_matrix[1,1]*original_size_y)**2 + (distortion_matrix[1,2]*original_size_z)**2)
            self.size_z = np.sqrt((distortion_matrix[2,0]*original_size_x)**2 + (distortion_matrix[2,1]*original_size_y)**2 + (distortion_matrix[2,2]*original_size_z)**2)

            # Updating the x and y coordinate limits
            self.xmax = np.max(X)
            self.xmin = np.min(X)

            self.ymax = np.max(Y)
            self.ymin = np.min(Y)

            self.zmax = np.max(Z)
            self.zmin = np.min(Z)

            volume_factor = np.linalg.det(distortion_matrix)
            self.dV = self.dV*volume_factor
            self.volume = self.volume*volume_factor

    def conf_strain_to_equilibrium(self):
        """Strain the PFC to equilibrium by adjusting the position variables and k-space variables.
        
        Parameters
        ----------
        None
        
        Returns
        -------
        float
            The final strain value that minimizes the free energy.
        """
        
        # Evolve PFC to reach initial state of equilibrium (100 time steps ok)
        number_of_initial_steps = 100
        self.evolve_PFC(number_of_initial_steps, suppress_output=True)
        number_of_steps = 10 # 10 steps is enough to reach equilibrium

        # Calculate average free energy to compare
        average_free_energy = self.calc_free_energy()/self.volume
        # print('Average free energy at initial state: ', average_free_energy)

        strain = 0
        strain_increment = 0.00001
        strain += strain_increment

        pfc_strained = copy.deepcopy(self)
        pfc_strained.conf_apply_distortion(strain, update_q_and_a_vectors=True)

        # Evolve PFC
        pfc_strained.evolve_PFC(number_of_steps, suppress_output=True)

        # Calculate free energy to compare
        average_free_energy_tmp = pfc_strained.calc_free_energy()/pfc_strained.volume

        positive_strain_required = False
        while average_free_energy_tmp < average_free_energy:

            positive_strain_required = True

            average_free_energy = average_free_energy_tmp

            strain += strain_increment

            pfc_strained = copy.deepcopy(self)
            pfc_strained.conf_apply_distortion(strain, update_q_and_a_vectors=True)
            
            pfc_strained.evolve_PFC(number_of_steps, suppress_output=True)

            average_free_energy_tmp = pfc_strained.calc_free_energy()/pfc_strained.volume
            # print('Average free energy at strain: ', strain, ' is: ', average_free_energy_tmp)
        
        if positive_strain_required:
            # Going one back to get the lowest free energy
            final_strain = strain - strain_increment
            self.conf_apply_distortion(final_strain, update_q_and_a_vectors=True)
            # tool_print_in_color('Lowest average free energy found at strain: ' + str(final_strain), 'green')

        else: #negative strain required

            strain = - strain_increment

            pfc_strained = copy.deepcopy(self)
            pfc_strained.conf_apply_distortion(strain, update_q_and_a_vectors=True)

            pfc_strained.evolve_PFC(number_of_steps, suppress_output=True)
            average_free_energy_tmp = pfc_strained.calc_free_energy()/pfc_strained.volume
            # print('Average Free energy at strain: ', strain, ' is: ', average_free_energy_tmp)

            while average_free_energy_tmp < average_free_energy:

                average_free_energy = average_free_energy_tmp

                strain -= strain_increment

                pfc_strained = copy.deepcopy(self)
                pfc_strained.conf_apply_distortion(strain, update_q_and_a_vectors=True)

                pfc_strained.evolve_PFC(number_of_steps, suppress_output=True)

                average_free_energy_tmp = pfc_strained.calc_free_energy()/pfc_strained.volume

                # print('Average free energy at strain: ', strain, ' is: ', average_free_energy_tmp)

            # Going one back to get the lowest free energy
            final_strain = strain + strain_increment
            self.conf_apply_distortion(final_strain, update_q_and_a_vectors=True)
            # tool_print_in_color('Lowest average free energy found at strain: ' + str(final_strain), 'green')   

        return final_strain

    def conf_create_polycrystal(self, type, **kwargs):
        """Creates a polycrystal.
        
        Parameters
        ----------
        type : str
            The type of polycrystal to create ('circular' or 'four_grain').
        kwargs : dict
            Additional arguments for the polycrystal creation, including:
            
            - relaxation_time : float
                The relaxation time to use for the polycrystal creation.
            - rotation : float
                The rotation angle for 'circular' type (default: pi/6).
            - position : array_like
                The position for 'circular' type (default: system midpoint).
            - radius : float
                The radius for 'circular' type (default: size_min/4).
        
        Returns
        -------
        None
            Updates the PFC state.
        """
        # First type of polycrystal, see documentation.
        if type == 'circular':
            # This creates a standard orientation of the crystal
            self.conf_PFC_from_amplitudes()

            rotation = kwargs.get('rotation', np.pi/6)
            position = kwargs.get('position', self.rmid)
            radius = kwargs.get('radius', self.size_min/4)

            # Create the rotated field
            psi_rotated = self.calc_PFC_from_amplitudes(rotation=[0,0,rotation])

            # Set the rotated field in the inclusion region
            region  = self.calc_region_disk(position, radius)
            self.psi[region] = psi_rotated[region]
            self.psi_f = self.fft(self.psi)

            # Smooth the interface
            relaxation_time = kwargs.get('relaxation_time', 10)
            self.evolve_PFC(round(relaxation_time/self.dt))

        elif type == 'four_grain':
            if self.dim == 1:
                raise Exception("Polycrystal type four_grain is not valid for 1 dimension.") 
                
            self.psi = self.calc_PFC_from_amplitudes(self.eta0)
            
            l1  = self.y>1/6*self.ymax+(4/6*self.ymax)/(1/1*self.xmax)*self.x
            l2  = self.y>1/2*self.ymax+(1/2*self.ymax)/(2/3*self.xmax)*self.x
            l3  = self.y>1/2*self.ymax-(1/2*self.ymax)/(2/3*self.xmax)*self.x
            l4  = self.y>5/6*self.ymax-(4/6*self.ymax)/(1/1*self.xmax)*self.x
            l5  = self.x>self.xmax/4
            l6  = self.y>5/4*self.ymax-(3/4*self.ymax)/(1/1*self.xmax)*self.x
            l7  = self.x>self.xmax/2
            l8  = self.y<1/2*self.ymax+(1/2*self.ymax)/(2/3*self.xmax)*self.x
            l9  = self.x>3/4*self.xmax
            l10 = self.y<-1/4*self.ymax+(3/4*self.ymax)/(1/1*self.xmax)*self.x

            zdir = 1 if self.dim == 2 else np.ones((1,1,self.zRes))

            pfcRotated = self.calc_PFC_from_amplitudes(self.eta0, rotation=[0,0,-22.5/180*np.pi])
            pfcRotated = np.roll(pfcRotated, -round(self.yRes/2), axis=1)
            pfcRotated = np.roll(pfcRotated, -round(self.xRes/3), axis=0)
            region = np.bool_((l4*~(l7)*~(l8) + ~(l1)*~(l3)*~(l7))*zdir)
            self.psi[region] = pfcRotated[region]

            pfcRotated = self.calc_PFC_from_amplitudes(self.eta0, rotation=[0,0,22.5/180*np.pi])
            pfcRotated = np.roll(pfcRotated, -round(self.yRes/2), axis=1)
            pfcRotated = np.roll(pfcRotated, round(self.xRes/3), axis=0)
            region = np.bool_((l1*l6*l7 + l7*l10*~(l4))*zdir)
            self.psi[region] = pfcRotated[region]

            pfcRotated = self.calc_PFC_from_amplitudes(self.eta0, rotation=[0,0,45/180*np.pi])
            pfcRotated = np.roll(pfcRotated, -round(self.xRes/2), axis=0)
            region = np.bool_((l1*~(l4)*~(l5) + ~(l1)*l4*l9)*zdir)
            self.psi[region] = pfcRotated[region]

            self.psi_f = self.fft(self.psi)

            relaxation_time = kwargs.get('relaxation_time', 10)
            
            self.evolve_PFC(round(relaxation_time/self.dt))


    #######################################################
    #######################################################
    ############### EVOLUTION FUNCTIONS ###################
    #######################################################
    #######################################################


    #######################################################
    #################### STANDARD #########################
    #######################################################
    def evolve_PFC(self, number_of_steps, method='ETD2RK', suppress_output=False):
        """Evolves the PFC according to classical PFC dynamics.
        
        Parameters
        ----------
        number_of_steps : int
            The number of steps to evolve the PFC.
        method : str, optional
            The method to use for the evolution, by default 'ETD2RK'.
        suppress_output : bool, optional
            Whether to suppress the progress bar, by default False.
        
        Returns
        -------
        None
            Updates self.psi and self.psi_f.
        """

        if self.type_of_evolution == 'conserved':
            omega_f = -self.calc_k2()*(self.r + self.calc_L_f()**2)
            non_linear_evolution_function_f = self.calc_nonlinear_evolution_function_conserved_f
        elif self.type_of_evolution == 'unconserved':
            omega_f = -(self.r + self.calc_L_f()**2)
            non_linear_evolution_function_f = self.calc_nonlinear_evolution_function_unconserved_f

        integrating_factors_f, solver = self.calc_integrating_factors_f_and_solver(omega_f, method)

        for n in tqdm(range(number_of_steps), desc='Evolving the PFC (conserved)', disable=suppress_output):
            self.psi, self.psi_f = solver(integrating_factors_f,
                                            non_linear_evolution_function_f,
                                            self.psi, self.psi_f)

            # These steps seem to be necessary for numerical stability (Vidar 18.12.23)
            self.psi = np.real(self.psi)
            self.psi_f = self.fft(self.psi)

    # Nonlinear part conserved
    def calc_nonlinear_evolution_function_conserved_f(self, psi, t):
        """Calculate the nonlinear part of the evolution function for conserved dynamics.
        
        Parameters
        ----------
        psi : ndarray
            The phase field.
        t : float
            The time.
            
        Returns
        -------
        ndarray
            The nonlinear part of the evolution function in Fourier space.
        """
        return -self.calc_k2()*self.fft(self.t * psi ** 2 + self.v * psi ** 3)

    # Non-linear part unconserved
    def calc_nonlinear_evolution_function_unconserved_f(self, psi, t):
        """Calculate the nonlinear part of the evolution function for unconserved dynamics.
        
        Parameters
        ----------
        psi : ndarray
            The phase field.
        t : float
            The time.
            
        Returns
        -------
        ndarray
            The nonlinear part of the evolution function in Fourier space.
        """
        return -self.fft(self.t * psi ** 2 + self.v * psi ** 3)
    #######################################################

    #######################################################
    ##### MECHANICAL EQUILIBRIUM (CONSERVED) ##############
    #######################################################
    def evolve_PFC_mechanical_equilibrium(self, time, Delta_t = 10, method='ETD2RK'):
        """Evolves the PFC in mechanical equilibrium.
        
        Parameters
        ----------
        time : float
            The total time to evolve the PFC.
        Delta_t : float, optional
            The time step for the mechanical equilibrium evolution, by default 10.
        method : str, optional
            The method to use for the evolution, by default 'ETD2RK'.
            
        Returns
        -------
        None
            Updates self.psi and self.psi_f.
        """
        
        number_of_steps = round(time/self.dt)
        number_of_steps_per_iteration = round(Delta_t/self.dt)
        number_of_iterations = round(number_of_steps/number_of_steps_per_iteration)

        for n in tqdm(range(number_of_iterations), desc='Evolving the PFC in mechanical equilibrium'):
            self.conf_advect_PFC(self.calc_displacement_field_to_equilibrium())
            self.evolve_PFC(number_of_steps_per_iteration, method)
    #######################################################

    #######################################################
    ######### HYDRODYNAMIC (CONSERVED) ####################
    #######################################################

    def evolve_PFC_hydrodynamic(self, number_of_steps, 
                                method = 'ETD2RK',
                                gamma_S = 2**-6,
                                rho0 = 2**-6):
        """Evolves the PFC according to hydrodynamic PFC dynamics.
        
        This requires introducing a velocity field. 
        If psi does not contain this field, it is added to the components psi[1], psi[2], psi[3].
        
        Parameters
        ----------
        number_of_steps : int
            The number of steps to evolve the PFC.
        method : str, optional
            The method to use for the evolution, by default 'ETD2RK'.
        gamma_S : float, optional
            The surface tension coefficient, by default 2**-6.
        rho0 : float, optional
            The mass density, by default 2**-6.
            
        Returns
        -------
        None
            Updates self.psi and self.psi_f.
        """
        
        if hasattr(self,'bool_has_velocity_field'):
            pass
        else:
            self.bool_has_velocity_field = True
            self.psi = np.array([self.psi]+[np.zeros_like(self.psi)]*self.dim)
            self.psi_f = np.array([self.psi_f]+[np.zeros_like(self.psi_f)]*self.dim)
            # print("psi shape", self.psi.shape).

            if not hasattr(self,'external_force_density_f'):
                self.external_force_density_f = np.zeros([self.dim] + self.dims, dtype=complex)

        self.gamma_S = gamma_S
        self.rho0 = rho0

        omega_f = self.calc_omega_hydrodynamic_f()
        integrating_factors_f, solver = self.calc_integrating_factors_f_and_solver(omega_f, method)

        for n in tqdm(range(number_of_steps), desc='Evolving the hydrodynamic PFC'):
            self.psi, self.psi_f = solver(integrating_factors_f,
                                            self.calc_nonlinear_hydrodynamic_evolution_function_f,
                                            self.psi, self.psi_f)
            
            self.psi = np.real(self.psi)
            self.psi_f = self.fft(self.psi )

    # Linear part
    def calc_omega_hydrodynamic_f(self):
        """Calculates the hydrodynamic evolution function omega_f.
        
        Parameters
        ----------
        None
        
        Returns
        -------
        ndarray
            The hydrodynamic evolution function omega_f in Fourier space.
        """
        k2 = self.calc_k2()

        if self.type_of_evolution == 'conserved':
            omega_f = -self.calc_k2()*(self.r + self.calc_L_f()**2)
        elif self.type_of_evolution == 'unconserved':
            omega_f = -(self.r + self.calc_L_f()**2)

        return np.array([omega_f]+[-self.gamma_S/self.rho0*k2]*self.dim)

    # Nonlinear part
    def calc_nonlinear_hydrodynamic_evolution_function_f(self, field, t):
        """Calculates the hydrodynamic evolution function of the PFC.
        
        Parameters
        ----------
        field : ndarray
            The field to calculate the evolution function of.
        t : float
            The time.
            
        Returns
        -------
        ndarray
            The nonlinear evolution function for the hydrodynamic PFC in Fourier space.
        """

        field_f = self.fft(field)

        k2 = self.calc_k2()

        N0_f = -k2*self.fft(self.t * field[0] ** 2 + self.v * field[0] ** 3) \
            - self.fft(sum([field[i+1]*self.ifft(self.dif[i]*field_f[0]) for i in range(self.dim)]))
        
        force_density_f = self.calc_stress_divergence_f(field_f[0])

        return np.array([N0_f] + [1/self.rho0*(force_density_f[i]+self.external_force_density_f[i]) for i in range(self.dim)])
    #######################################################


    #######################################################
    #######################################################
    ############## CALCULATION FUNCTIONS ##################
    #######################################################
    #######################################################
    
    def calc_strained_amplitudes(self):
        """Strains the PFC to equilibrium and returns the amplitudes.
    
        Parameters
        ----------
        None

        Returns
        -------
        tuple
            Depending on the PFC type, returns either:
            - (final_strain, psi0, A, el_lambda, el_mu, el_gamma) for 1 independent amplitude
            - (final_strain, psi0, A, B, el_lambda, el_mu, el_gamma) for 2 independent amplitudes
            - (final_strain, psi0, A, B, C, el_lambda, el_mu, el_gamma) for 3 independent amplitudes
        """
        # tool_print_in_color('Proto amplitudes and elastic constants', 'blue')
        # tool_print_in_color('---', 'blue')
        # print(f'Proto psi0: {self.psi0:.02f}')
        # # print(f'Proto A: {self.A:.05f}')
        # if self.type in ['PhaseFieldCrystal2DSquare','PhaseFieldCrystal3DFaceCenteredCubic','PhaseFieldCrystal3DSimpleCubic']:
        #     print(f'Proto B: {self.B:.05f}')
        # if self.type in ['PhaseFieldCrystal3DSimpleCubic']:
        #     print(f'Proto C: {self.C:.05f}')

        # print(f'Proto mu: {self.el_mu:.05f}')
        # print(f'Proto lambda: {self.el_lambda:.05f}')
        # print(f'Proto gamma: {self.el_gamma:.05f}')

        print('---')
        tool_print_in_color('Straining PFC to reach equilibrium', 'blue')
        print('---')

        # Strain PFC to equilibrium
        self.conf_PFC_from_amplitudes()
        final_strain = self.conf_strain_to_equilibrium()
        self.evolve_PFC(200, suppress_output=True)

        # tool_print_in_color('Amplitudes after strain', 'blue')
        # tool_print_in_color('---', 'blue')
        print(f'Equilibrium strain: {final_strain:.05f}')
        print(f'Equilibrium q-vector: {1/(1+final_strain):.05f}')

        psi0 = np.mean(self.psi)
        # print(f'Eq. psi0: {psi0:.02f}')

        eta = self.calc_demodulate_PFC(only_primary_modes=False)
        A = np.mean(np.real(eta[0]))
        number_of_independent_amplitudes = 1

        if self.type == 'PhaseFieldCrystal2DSquare':
            number_of_independent_amplitudes = 2
            B = np.mean(np.real(eta[2]))
        
        if self.type == 'PhaseFieldCrystal3DFaceCenteredCubic':
            number_of_independent_amplitudes = 2
            B = np.mean(np.real(eta[4]))

        if self.type == 'PhaseFieldCrystal3DSimpleCubic':
            number_of_independent_amplitudes = 3
            B = np.mean(np.real(eta[3]))
            C = np.mean(np.real(eta[9]))

        print('---')
        tool_print_in_color('Equilibrium amplitudes:', 'blue')
        print('---')
        print(f'Proto mean density psi0      : {self.psi0:.02f}')
        print(f'Equilibrium mean density psi0: {psi0:.02f}')
        print('Ratio (equilibrium/proto)     : {:.05f}'.format(psi0/self.psi0))

        if number_of_independent_amplitudes >= 1:
            print('---')
            print(f'Proto amplitude       A : {self.A:.05f}')
            print(f'Equilibrium amplitude A : {A:.05f}')
            print('Ratio (equilibrium/proto): {:.05f}'.format(A/self.A))
        if number_of_independent_amplitudes >= 2:
            print('---')
            print(f'Proto amplitude       B : {self.B:.05f}')
            print(f'Equilibrium amplitude B : {B:.05f}')
            print('Ratio (equilibrium/proto): {:.05f}'.format(B/self.B))
        
        if number_of_independent_amplitudes >= 3:
            print('---')
            print(f'Proto amplitude       C : {self.C:.05f}')
            print(f'Equilibrium amplitude C : {C:.05f}')
            print('Ratio (equilibrium/proto): {:.05f}'.format(C/self.C))
        
        # Finding elastic constants
        # def elastic_energy(strain, el_lambda, el_mu, el_gamma):
        #     exx, exy, eyy = strain
        #     return el_lambda/2*(exx+eyy)**2 + el_mu*(exx**2 + 2*exy**2 + eyy**2) + el_gamma/2*(exx**2 + eyy**2)

        # strain_magnitudes = np.linspace(-0.01,0.01,21)
        # exx = np.array([[a,0,a] for a in strain_magnitudes]).flatten()
        # exy = np.array([[0,a,0] for a in strain_magnitudes]).flatten()
        # eyy = np.array([[a,0,-a] for a in strain_magnitudes]).flatten()

        f0 = self.calc_free_energy()/self.volume

        # free_energies = np.zeros_like(exx)
        # for n in range(len(exx)):
        #     if self.dim == 2:
        #         distortion = [[exx[n], exy[n]],[exy[n], eyy[n]]]
        #     elif self.dim == 3:
        #         distortion = [[exx[n], exy[n], 0],[exy[n], eyy[n], 0],[0,0,0]]

        #     pfc_strained = copy.deepcopy(self)
        #     pfc_strained.conf_apply_distortion(distortion)
        #     f = pfc_strained.calc_free_energy()/pfc_strained.volume
        #     free_energies[n] = f-f0

        # params,_ = curve_fit(elastic_energy, (exx, exy, eyy), free_energies)
        # el_lambda, el_mu, el_gamma = params

        epsilon=0.01
        
        if self.dim == 2:
            pure_shear_distortion = [[0,epsilon],[epsilon,0]]
            volume_conserving_compression = [[epsilon,0],[0,-epsilon]]
            pure_compression_pos = [[epsilon,0],[0,epsilon]]
            pure_compression_neg = [[-epsilon,0],[0,-epsilon]]
        else:
            pure_shear_distortion = [[0,epsilon,0],[epsilon,0,0],[0,0,0]]
            volume_conserving_compression = [[epsilon,0,0],[0,-epsilon,0],[0,0,0]]
            pure_compression_pos = [[epsilon,0,0],[0,epsilon,0],[0,0,0]]
            pure_compression_neg = [[-epsilon,0,0],[0,-epsilon,0],[0,0,0]]

        pfc_strained = copy.deepcopy(self)
        pfc_strained.conf_apply_distortion(pure_shear_distortion)
        f_pure_shear = pfc_strained.calc_free_energy()/pfc_strained.volume - f0

        pfc_strained = copy.deepcopy(self)
        pfc_strained.conf_apply_distortion(volume_conserving_compression)
        f_volume_conserving_compression = pfc_strained.calc_free_energy()/pfc_strained.volume - f0

        pfc_strained = copy.deepcopy(self)
        pfc_strained.conf_apply_distortion(pure_compression_pos)
        f_pure_compression_pos = pfc_strained.calc_free_energy()/pfc_strained.volume - f0

        pfc_strained = copy.deepcopy(self)
        pfc_strained.conf_apply_distortion(pure_compression_neg)
        f_pure_compression_neg = pfc_strained.calc_free_energy()/pfc_strained.volume - f0

        f_pure_compression = (f_pure_compression_pos + f_pure_compression_neg)/2

        el_lambda = (0.5*f_pure_compression - 0.5*f_volume_conserving_compression)/(epsilon**2)
        el_mu = (0.5*f_pure_shear)/(epsilon**2)
        el_gamma = (-f_pure_shear + f_volume_conserving_compression)/(epsilon**2)


        if self.type == 'PhaseFieldCrystal1DPeriodic':
            el_lambda_from_eq_amplitudes = 2*(A**2)
        elif self.type == 'PhaseFieldCrystal2DTriangular':
            el_lambda_from_eq_amplitudes = 3*(A**2)
            el_mu_from_eq_amplitudes = 3*(A**2)
            el_gamma_from_eq_amplitudes = 0
        elif self.type == 'PhaseFieldCrystal2DSquare':
            el_lambda_from_eq_amplitudes = 16*(B**2)
            el_mu_from_eq_amplitudes = 16*(B**2)
            el_gamma_from_eq_amplitudes = 8*A**2 - 32*B**2
        elif self.type == 'PhaseFieldCrystal3DBodyCenteredCubic':
            el_lambda_from_eq_amplitudes = 4*(A**2)
            el_mu_from_eq_amplitudes = 4*(A**2)
            el_gamma_from_eq_amplitudes = -4*(A**2)
        elif self.type == 'PhaseFieldCrystal3DFaceCenteredCubic':
            el_lambda_from_eq_amplitudes = 32/81*(A**2)
            el_mu_from_eq_amplitudes = 32/81*(A**2)
            el_gamma_from_eq_amplitudes = 32/81*(2*B**2-A**2)
        elif self.type == 'PhaseFieldCrystal3DSimpleCubic':
            el_lambda_from_eq_amplitudes = 16*(B**2) + 128*(C**2)
            el_mu_from_eq_amplitudes = 16*(B**2) + 128*(C**2)
            el_gamma_from_eq_amplitudes = 32*(A**2) - 16*(B**2) - 256*(C**2)

        print('---')
        tool_print_in_color('Equilibrium elastic constants:', 'blue')
        print('---')
        print('Proto lambda                             : {:.05f}'.format(self.el_lambda))
        print('Equilibrium lambda (numerical)           : {:.05f}'.format(el_lambda))
        print('Equilibrium lambda (from eq. amplitudes) : {:.05f}'.format(el_lambda_from_eq_amplitudes))
        print('Ratio (equilibrium/proto)                : {:.05f}'.format(el_lambda/self.el_lambda))

        print('---')
        print('Proto mu                             : {:.05f}'.format(self.el_mu))
        print('Equilibrium mu (numerical)           : {:.05f}'.format(el_mu))
        print('Equilibrium mu (from eq. amplitudes) : {:.05f}'.format(el_mu_from_eq_amplitudes))
        print('Ratio (equilibrium/proto)            : {:.05f}'.format(el_mu/self.el_mu))

        print('---')
        print('Proto gamma                             : {:.05f}'.format(self.el_gamma))
        print('Equilibrium gamma (numerical)           : {:.05f}'.format(el_gamma))
        print('Equilibrium gamma (from eq. amplitudes) : {:.05f}'.format(el_gamma_from_eq_amplitudes))
        print('Ratio (equilibrium/proto)               : {:.05f}'.format(el_gamma/self.el_gamma))

        if number_of_independent_amplitudes == 1:
            return final_strain, psi0, A, el_lambda, el_mu, el_gamma
        elif number_of_independent_amplitudes == 2:
            return final_strain, psi0, A, B, el_lambda, el_mu, el_gamma
        elif number_of_independent_amplitudes == 3:
            return final_strain, psi0, A, B, C, el_lambda, el_mu, el_gamma

    def calc_PFC_free_energy_density_and_chemical_potential(self, field=None, field_f=None):
        """Calculates the free energy density and chemical potential of the PFC.

        Parameters
        ----------
        field : ndarray, optional
            The field to calculate the free energy density and chemical potential of.
            If None, self.psi is used.
        field_f : ndarray, optional
            The Fourier transform of the field.
            If None, self.psi_f is used.

        Returns
        -------
        tuple
            A tuple containing:
            - free_energy_density (ndarray): The free energy density of the PFC
            - chemical_potential (ndarray): The chemical potential of the PFC
        """

        if field is None:
            field = self.psi
            field_f = self.psi_f

        psi_f = field_f
        
        # print("field shape",field.shape)
        # print("field_f shape",field_f.shape)

        psi = field 
        psi2 = field**2 
        psi3 = psi2*psi
        psi4 = psi2**2

        Lpsi = self.ifft(self.calc_L_f()*psi_f)

        free_energy_density = 1/2*Lpsi**2 \
            + 1/2*self.r*psi2 + 1/3*self.t*psi3 + 1/4*self.v*psi4
        
        # print("Lpsi shape",self.calc_Lpsi(psi_f).shape)

        L2psi = self.ifft(self.calc_L_f()**2*psi_f)

        chemical_potential = L2psi*psi \
            + self.r*psi + self.t*psi2 + self.v*psi3
        
        # print("L2psi shape",self.calc_L2psi(psi_f).shape)
        
        # print("Free energy density shape", free_energy_density.shape)
        # print("Chem pot shape", chemical_potential.shape)
        return np.real(free_energy_density), np.real(chemical_potential)
    

    def calc_displacement_field_to_equilibrium(self):
        """Calculates the displacement field needed to put the PFC in mechanical equilibrium.

        Parameters
        ----------
        None

        Returns
        -------
        ndarray
            The displacement field u that would bring the system to mechanical equilibrium
        """

        # Calculate the stress divergence
        g_f = self.calc_stress_divergence_f()

        # Calculate the displacement field
        u_f = np.zeros([self.dim] + self.dims, dtype = complex)

        k2 = self.calc_k2()
        k = np.sqrt(k2)

        kappa = np.zeros([self.dim] + self.dims)
        for l in range(self.dim):
            kappa[l] = self.k[l]/k

        second_term_factor = (self.el_mu + self.el_lambda)/(1+sum([(self.el_mu + self.el_lambda)/(self.el_mu + self.el_gamma*kappa[l]**2)*kappa[l]**2 for l in range(self.dim)]))

        # print(second_term_factor)

        for i in range(self.dim):
            for j in range(self.dim):
                #Calculate the Green's function
                Gij_f = int(i==j)/(self.el_mu + self.el_gamma*kappa[i]**2) \
                - kappa[i]*kappa[j]/((self.el_mu + self.el_gamma*kappa[i]**2)*(self.el_mu + self.el_gamma*kappa[j]**2))*second_term_factor

                u_f[i] += 1/k2*Gij_f*g_f[j]
            
            # Set the zero mode to zero
            u_f[i][self.zero_index] = 0

            # print(u_f[i])

        return np.real(self.ifft(u_f))

    # Initial configuration methods
    def calc_amplitudes_with_dislocation(self, eta=None, x=None, y=None, dislocation_type=1):
        """Calculate the amplitudes with a single point dislocation inserted.

        Parameters
        ----------
        eta : array_like, optional
            The amplitudes to insert the dislocation in. If None, uses default amplitudes.
        x : float, optional
            The x-coordinate of the dislocation. If None, uses system midpoint.
        y : float, optional
            The y-coordinate of the dislocation. If None, uses system midpoint.
        dislocation_type : int, optional
            The dislocation type to insert, default is 1.
        
        Returns
        -------
        ndarray
            The amplitudes containing the dislocation.
            
        Raises
        ------
        Exception
            If the dimension of the system is not 2.
        """

        if not (self.dim == 2):
            raise Exception("The dimension of the system must be 2 for a single point dislocation.")

        if x == None:
            x = self.xmid
        if y == None:
            y = self.ymid
        if eta == None:
            eta = self.eta0

        sn = self.dislocation_charges[dislocation_type - 1]
        for n in range(self.number_of_reciprocal_lattice_modes):
            if sn[n] != 0:
                eta[n] *= np.exp(1j * self.calc_angle_field_single_vortex([x, y], charge=sn[n]))

        return eta

    def calc_amplitudes_with_dislocation_dipole(self, eta=None,
                                                x1=None, y1=None,
                                                x2=None, y2=None,
                                                dislocation_type=1):
        """Insert a dislocation dipole in the system corresponding to dislocation type and its negative.

        Parameters
        ----------
        eta : array_like, optional
            The amplitudes to insert the dislocation dipole in. If None, uses default amplitudes.
        x1 : float, optional
            The x-coordinate of the first dislocation. If None, uses 1/3 of system width.
        y1 : float, optional
            The y-coordinate of the first dislocation. If None, uses 1/2 of system height.
        x2 : float, optional
            The x-coordinate of the second dislocation. If None, uses 2/3 of system width.
        y2 : float, optional
            The y-coordinate of the second dislocation. If None, uses 1/2 of system height.
        dislocation_type : int, optional
            The dislocation type to insert, default is 1.
        
        Returns
        -------
        ndarray
            The amplitudes with the dislocation dipole inserted.
            
        Raises
        ------
        Exception
            If the dimension of the system is not 2.
        """

        if not (self.dim == 2):
            raise Exception("The dimension of the system must be 2 to insert a dislocation dipole.")

        if x1 == None:
            x1 = self.xmax / 3
        if y1 == None:
            y1 = self.ymax / 2
        if x2 == None:
            x2 = 2 * self.xmax / 3
        if y2 == None:
            y2 = self.ymax / 2

        if eta is None:
            eta = self.eta0.reshape(self.number_of_reciprocal_lattice_modes,1,1)\
                *np.ones([self.number_of_reciprocal_lattice_modes] + self.dims, dtype=complex)

        sn = self.dislocation_charges[dislocation_type - 1]

        theta = self.calc_angle_field_vortex_dipole(
            dipole_vector=[x2 - x1, y2 - y1],
            dipole_position=[(x1 + x2) / 2, (y1 + y2) / 2])

        for n in range(self.number_of_reciprocal_lattice_modes):
            if sn[n] != 0:
                eta[n] *= np.exp(1j * sn[n] * theta)

        return eta

    def calc_amplitudes_with_dislocation_ring(self, eta=None,
                                                position=None,
                                                radius=None,
                                                normal_vector=[0, 0, 1],
                                                dislocation_type=1):
        """Insert a dislocation ring in the system corresponding to dislocation type.

        Parameters
        ----------
        eta : array_like, optional
            The amplitudes to insert the dislocation ring in. If None, uses default amplitudes.
        position : array_like, optional
            The position of the dislocation ring. If None, uses system midpoint.
        radius : float, optional
            The radius of the dislocation ring. If None, uses 1/3 of minimum system dimension.
        normal_vector : array_like, optional
            The normal vector of the dislocation ring, default is [0, 0, 1].
        dislocation_type : int, optional
            The dislocation type to insert, default is 1.

        Returns
        -------
        ndarray
            The amplitudes with the dislocation ring inserted.
            
        Raises
        ------
        Exception
            If the dimension of the system is not 3.
        """

        if not (self.dim == 3):
            raise Exception("The dimension of the system must be 3 to insert a dislocation dipole.")

        if position == None:
            position = self.rmid

        if radius == None:
            radius = min(self.rmax)/3

        if eta == None:
            eta = self.eta0.reshape(self.number_of_reciprocal_lattice_modes,1,1,1)\
                *np.ones([self.number_of_reciprocal_lattice_modes] + self.dims, dtype=complex)

        sn = self.dislocation_charges[dislocation_type - 1]

        theta = self.calc_angle_field_vortex_ring(
            radius=radius,
            position=position,
            normal_vector=normal_vector)

        for n in range(self.number_of_reciprocal_lattice_modes):
            if sn[n] != 0:
                eta[n] *= np.exp(1j * sn[n] * theta)

        return eta

    def calc_PFC_from_amplitudes(self, eta=None, rotation=None):
        """Calculate the PFC from the amplitudes.

        Parameters
        ----------
        eta : array_like, optional
            The amplitudes to calculate the PFC from. If None, uses default amplitudes.
        rotation : array_like or float, optional
            The rotation to apply to the crystal. If float, rotation around z-axis.
            If array, rotation vector [rx, ry, rz].

        Returns
        -------
        ndarray
            The phase field crystal density field.
        """ 

        psi = self.psi0

        if rotation is None:
            rotation = [0,0,0]
        else:
            if isinstance(rotation, float):
                rotation = [0,0,rotation]

        rotation = sp.spatial.transform.Rotation.from_rotvec(rotation)
        rotation_matrix = rotation.as_matrix()

        # Rotate q-vectors to the new orientation
        if self.dim == 1:
            q = self.q # No rotation in 1D
        if self.dim == 2:
            q = (rotation_matrix[0:2,0:2]@self.q.transpose()).transpose()
        elif self.dim == 3:
            q = (rotation_matrix[0:3,0:3]@self.q.transpose()).transpose()

        if eta is None:
            eta = self.eta0

        for n in range(self.number_of_reciprocal_lattice_modes):

            if self.dim == 1:
                psi += 2 * eta[n] * np.exp(1j * q[n][0] * self.x)

            elif self.dim == 2:
                psi += 2 * eta[n] * np.exp(1j * (q[n][0] * self.x + q[n][1] * self.y))

            elif self.dim == 3:
                psi += 2 * eta[n] * np.exp(1j * (q[n][0] * self.x + q[n][1] * self.y + q[n][2] * self.z))

        return np.real(psi)

    def calc_demodulate_PFC(self, only_primary_modes=True):
        """Demodulate the PFC to extract amplitudes.

        Parameters
        ----------
        only_primary_modes : bool, optional
            Whether to only extract primary reciprocal lattice modes, default is True.

        Returns
        -------
        ndarray
            The amplitudes corresponding to the demodulated PFC.
        """
        
        number_of_modes = self.number_of_primary_reciprocal_lattice_modes if only_primary_modes else self.number_of_reciprocal_lattice_modes

        eta = np.zeros([number_of_modes] + self.dims, 
                       dtype=complex)

        Gaussian_filter_f = self.calc_Gaussian_filter_f()

        order_parameter = self.psi if self.psi.ndim == self.dim else self.psi[0]

        if self.dim == 2:
                for n in range(number_of_modes):
                    eta[n] = self.ifft(Gaussian_filter_f*self.fft(order_parameter*np.exp(
                        -1j*self.q[n][0]*self.x - 1j*self.q[n][1]*self.y)))

        elif self.dim == 3:
            for n in range(number_of_modes):
                eta[n] = self.ifft(Gaussian_filter_f*self.fft(order_parameter*np.exp(
                    -1j*self.q[n][0]*self.x - 1j*self.q[n][1]*self.y - 1j*self.q[n][2]*self.z  
                    )))
                
        return eta

    def calc_stress_tensor_microscopic(self):
        """Calculate the microscopic stress of the phase-field crystal.

        Parameters
        ----------
        None

        Returns
        -------
        ndarray
            The microscopic stress tensor of the phase-field crystal.
            For 2D: tensor with components [σxx, σxy, σyy].
            For 3D: tensor with components [σxx, σxy, σxz, σyy, σyz, σzz].
            
        Raises
        ------
        Exception
            If the dimension of the system is 1D.
        """

        if hasattr(self,'bool_has_velocity_field') and self.bool_has_velocity_field:
            psi_f = self.psi_f[0]
        else:
            psi_f = self.psi_f

        if self.dim==1:
            raise Exception("The stress tensor is not yet defined in 1D.")
        elif self.dim==2:
            stress = np.zeros((3,self.xRes,self.yRes))

            Lpsi = np.real(self.ifft(self.calc_L_f()*psi_f))
            stress[0] = -2*Lpsi*np.real(self.ifft(self.calc_L_sum_f()*self.dif[0]*self.dif[0]*psi_f))
            stress[1] = -2*Lpsi*np.real(self.ifft(self.calc_L_sum_f()*self.dif[0]*self.dif[1]*psi_f))
            stress[2] = -2*Lpsi*np.real(self.ifft(self.calc_L_sum_f()*self.dif[1]*self.dif[1]*psi_f))
        
        elif self.dim==3:
            stress = np.zeros((6,self.xRes,self.yRes,self.zRes))

            Lpsi = np.real(self.ifft(self.calc_L_f()*psi_f))
            stress[0] = -2*Lpsi*np.real(self.ifft(self.calc_L_sum_f()*self.dif[0]*self.dif[0]*psi_f))
            stress[1] = -2*Lpsi*np.real(self.ifft(self.calc_L_sum_f()*self.dif[0]*self.dif[1]*psi_f))
            stress[2] = -2*Lpsi*np.real(self.ifft(self.calc_L_sum_f()*self.dif[0]*self.dif[2]*psi_f))
            stress[3] = -2*Lpsi*np.real(self.ifft(self.calc_L_sum_f()*self.dif[1]*self.dif[1]*psi_f))
            stress[4] = -2*Lpsi*np.real(self.ifft(self.calc_L_sum_f()*self.dif[1]*self.dif[2]*psi_f))
            stress[5] = -2*Lpsi*np.real(self.ifft(self.calc_L_sum_f()*self.dif[2]*self.dif[2]*psi_f))

        return stress


    def calc_stress_tensor(self):
        """Calculates the stress of the phase-field crystal.

        Parameters
        ----------
        None

        Returns
        -------
        ndarray
            The stress tensor.
        """

        stress = self.calc_stress_tensor_microscopic()

        Gaussian_filter_f = self.calc_Gaussian_filter_f()

        # Number of independent stress components
        if self.dim == 1:
            number_of_stress_components = 1
        elif self.dim == 2:
            number_of_stress_components = 3
        elif self.dim == 3:
            number_of_stress_components = 6

        # Coarse-grain the microscopic stress
        stress_f = np.zeros([number_of_stress_components] + self.dims, dtype=complex)
        for n in range(number_of_stress_components):
            stress_f[n] = Gaussian_filter_f*self.fft(stress[n])

        # return stress
        # return np.real(self.ifft(Gaussian_filter_f))
        return self.ifft(stress_f).real

    def calc_stress_divergence_f(self, field_f = None):
        """Calculates the divergence of the stress tensor in Fourier space.

        Parameters
        ----------
        field_f : ndarray, optional
            The field in Fourier space. If None, uses the current system field.

        Returns
        -------
        ndarray
            The divergence of the stress tensor in Fourier space.
        """
        if field_f is None:
            PFC_has_velocity_field = hasattr(self, 'bool_has_velocity_field') and self.bool_has_velocity_field
            if PFC_has_velocity_field:
                field_f = self.psi_f[0]
            else:
                field_f = self.psi_f

        L_f = self.calc_L_f()
        Lpsi = self.ifft(L_f*field_f)

        L_sum_f = self.calc_L_sum_f()
        k2 = self.calc_k2()

        return np.array([
            -2*self.calc_Gaussian_filter_f()*self.fft(
                sum([
                self.ifft(L_f*self.dif[i]*field_f)*self.ifft(L_sum_f*self.dif[i]*self.dif[j]*field_f) 
                for i in range(self.dim)
                ]) 
                +Lpsi*self.ifft(L_sum_f*self.dif[j]*(-k2)*field_f)) 
                for j in range(self.dim)]
                )


    def calc_structure_tensor_f(self):
        """Calculates the structure tensor of the phase-field crystal in Fourier space.

        Parameters
        ----------
        None

        Returns
        -------
        ndarray
            The structure tensor in Fourier space.
        """

        if hasattr(self,'bool_has_velocity_field') and self.bool_has_velocity_field:
            field_f = self.psi_f[0]
        else:
            field_f = self.psi_f

        # Calculate the gradient
        diPsi = np.zeros([self.dim] + self.dims, dtype=complex)
        for i in range(self.dim):
            diPsi[i] = self.dif[i]*field_f
        diPsi = np.real(self.ifft(diPsi))

        if self.dim == 1:
            number_of_independent_strain_components = 1
        elif self.dim == 2:
            number_of_independent_strain_components = 3
        elif self.dim == 3:
            number_of_independent_strain_components = 6

        structure_tensor_f = np.zeros([number_of_independent_strain_components] + self.dims, dtype=complex)

        Gaussian_filter_f = self.calc_Gaussian_filter_f()
        if self.dim == 1:
            structure_tensor_f[0] = Gaussian_filter_f*self.fft(diPsi[0]*diPsi[0])
        elif self.dim == 2:
            structure_tensor_f[0] = Gaussian_filter_f*self.fft(diPsi[0]*diPsi[0])
            structure_tensor_f[1] = Gaussian_filter_f*self.fft(diPsi[0]*diPsi[1])
            structure_tensor_f[2] = Gaussian_filter_f*self.fft(diPsi[1]*diPsi[1])
        elif self.dim == 3:
            structure_tensor_f[0] = Gaussian_filter_f*self.fft(diPsi[0]*diPsi[0])
            structure_tensor_f[1] = Gaussian_filter_f*self.fft(diPsi[0]*diPsi[1])
            structure_tensor_f[2] = Gaussian_filter_f*self.fft(diPsi[0]*diPsi[2])
            structure_tensor_f[3] = Gaussian_filter_f*self.fft(diPsi[1]*diPsi[1])
            structure_tensor_f[4] = Gaussian_filter_f*self.fft(diPsi[1]*diPsi[2])
            structure_tensor_f[5] = Gaussian_filter_f*self.fft(diPsi[2]*diPsi[2])

        return structure_tensor_f
            

    def calc_structure_tensor(self):
        """Calculates the structure tensor of the phase-field crystal.

        Parameters
        ----------
        None
        
        Returns
        -------
        ndarray
            The structure tensor.
        """
        structure_tensor_f = self.calc_structure_tensor_f()
        return np.real(self.ifft(structure_tensor_f))
        

    def calc_strain_tensor(self):
        """Calculates the strain of the phase-field crystal.

        Parameters
        ----------
        None

        Returns
        -------
        ndarray
            The strain tensor.
        """
        
        strain = -self.dim/(2*self.Phi)*self.calc_structure_tensor()

        if self.dim == 1:
            strain = 1/2 + strain
        elif self.dim == 2:
            strain[0] = 1/2 + strain[0]
            strain[2] = 1/2 + strain[2]
        elif self.dim == 3:
            strain[0] = 1/2 + strain[0]
            strain[3] = 1/2 + strain[3]
            strain[5] = 1/2 + strain[5]
        
        return strain
        



    def calc_dislocation_density(self, eta = None):
        """Calculates the dislocation density.

        Parameters
        ----------
        eta : ndarray, optional
            The amplitudes to calculate the dislocation density from.
            If None, amplitudes are calculated using demodulation.

        Returns
        -------
        ndarray
            The dislocation density.
        """

        if eta is None:
            eta = self.calc_demodulate_PFC()

        if self.dim == 2:
            alpha = np.zeros([2] + self.dims)

            for n in range(self.number_of_primary_reciprocal_lattice_modes):
                D = self.calc_determinant_field([np.real(eta[n]), np.imag(eta[n])])
                alpha[0] += D*self.q[n,0]
                alpha[1] += D*self.q[n,1]

        elif self.dim == 3:
            alpha = np.zeros([3,3] + self.dims)

            for n in range(self.number_of_primary_reciprocal_lattice_modes):
                D = self.calc_determinant_field([np.real(eta[n]), np.imag(eta[n])])
                for i in range(3):
                    alpha[i][0] += D[i]*self.q[n,0]
                    alpha[i][1] += D[i]*self.q[n,1]
                    alpha[i][2] += D[i]*self.q[n,2]

        alpha = 2*self.dim/(self.number_of_primary_reciprocal_lattice_modes*self.A**2)*alpha

        return alpha
        

    def calc_dislocation_nodes(self):
        """Calculates the dislocation nodes.

        Parameters
        ----------
        None
        
        Returns
        -------
        list
            A list of dictionaries containing information about each dislocation node.
            
        Raises
        ------
        Exception
            If the PFC is distorted.
        """

        # At the moment (24.09.24 - Vidar), this function only works for unstrained PFCs
        if hasattr(self,'bool_is_shear_distorted') and self.bool_is_shear_distorted:
            raise Exception("Dislocation nodes cannot be calculated for distorted PFCs.")

        alpha = self.calc_dislocation_density()

        if self.dim == 2:
            # self.plot_field(np.sqrt(alpha[0]**2 + alpha[1]**2))
            # plt.show()
            # print(alpha)
            dislocation_nodes = self.calc_defect_nodes(np.sqrt(alpha[0]**2 + alpha[1]**2),
                                                        charge_tolerance=0.2*self.a0)
            
            for dislocation_node in dislocation_nodes:
                Burgers_vector = np.array([
                    alpha[0][dislocation_node['position_index']], 
                    alpha[1][dislocation_node['position_index']]
                    ])
                
                # print("Burgers vector:", Burgers_vector)
                
                # Find the Burgers vector 
                biggest_overlap = 0
                for a in self.a:
                    for sign in [-1, 1]:
                        overlap = np.dot(Burgers_vector, sign*a)
                        # print("Burgers vector",Burgers_vector)
                        # print("a-vector",a*sign)
                        # print("overlap",overlap)
                        # print("biggest overlap", biggest_overlap)
                        
                        if overlap > biggest_overlap:
                            # print("tjobing")
                            biggest_overlap = overlap
                            dislocation_node['Burgers_vector'] = sign*a
                
        elif self.dim == 3:
            dislocation_nodes = self.calc_defect_nodes(
                np.sqrt(
                        alpha[0][0]**2 + alpha[0][1]**2 + alpha[0][2]**2 \
                    + alpha[1][0]**2 + alpha[1][1]**2 + alpha[1][2]**2 \
                    + alpha[2][0]**2 + alpha[2][1]**2 + alpha[2][2]**2
                )
            )

            for dislocation_node in dislocation_nodes:
                alpha_tensor = np.array([
                    [alpha[0][0][dislocation_node['position_index']], alpha[0][1][dislocation_node['position_index']], alpha[0][2][dislocation_node['position_index']]],
                    [alpha[1][0][dislocation_node['position_index']], alpha[1][1][dislocation_node['position_index']], alpha[1][2][dislocation_node['position_index']]],
                    [alpha[2][0][dislocation_node['position_index']], alpha[2][1][dislocation_node['position_index']], alpha[2][2][dislocation_node['position_index']]]
                ])
                # print("alpha-tensor:",alpha_tensor)

                U, S, V = np.linalg.svd(alpha_tensor)
                tangent_vector = U[:,0]
                Burgers_vector = V[0,:]

                # print("U:",U)
                # print("S:",S)   
                # print("V:",V)

                # print("tangent vector:", tangent_vector)
                # print("Burgers vector:", Burgers_vector)

                # Find the Burgers vector 
                biggest_overlap = 0
                tangent_vector_sign = np.nan
                # print("Finding new Burgers vector...")
                for a in self.a:
                    for sign in [-1, 1]:
                        # print("Burgers vector",Burgers_vector)
                        # print("a-vector",a*sign)
                        # print("overlap",np.dot(Burgers_vector,sign*a))
                        overlap = np.dot(Burgers_vector, sign*a)
                        if overlap > biggest_overlap:
                            biggest_overlap = overlap
                            # print("New biggest overlap", overlap)
                            # print("Setting new BUrgers vector",a)
                            dislocation_node['Burgers_vector'] = a
                            tangent_vector_sign = sign

                dislocation_node['tangent_vector'] = tangent_vector_sign*tangent_vector

        return dislocation_nodes

    def calc_orientation_field(self):
        """Calculates the orientation field of the phase-field crystal.

        Args:
            None
        
        Returns:
            An orientation field, which is a vector field specifying the orientation of the crystal.
        """

        order_parameter = self.psi if self.psi.ndim == self.dim else self.psi[0]

        eta = np.zeros([self.number_of_primary_reciprocal_lattice_modes] + self.dims, 
                       dtype=complex)
        Gaussian_filter_f = self.calc_Gaussian_filter_f()

        if self.dim == 2:
            if self.type == 'PhaseFieldCrystal2DTriangular':
                wrap_factor = 3
            elif self.type == 'PhaseFieldCrystal2DSquare':
                wrap_factor = 2

            resolution = 16
            orientation_field = np.zeros((2,self.xRes,self.yRes))
            angles = np.arange(resolution)/resolution*np.pi/wrap_factor

            for angle in angles:
                rotation = sp.spatial.transform.Rotation.from_rotvec([0,0,angle])
                rotation_matrix = rotation.as_matrix()
                q = (rotation_matrix[0:2,0:2]@self.q.transpose()).transpose()
                for n in range(self.number_of_primary_reciprocal_lattice_modes):
                    eta[n] = self.ifft(Gaussian_filter_f*self.fft(order_parameter*np.exp(
                            -1j*q[n][0]*self.x - 1j*q[n][1]*self.y)))
                
                Phi2 = np.zeros(self.dims)
                for n in range(self.number_of_primary_reciprocal_lattice_modes):
                    Phi2 += abs(eta[n])**2
                
                orientation_field[0] += Phi2*np.cos(2*wrap_factor*angle)
                orientation_field[1] += Phi2*np.sin(2*wrap_factor*angle)

            return orientation_field
        
        elif self.dim == 3:

            # 1153 points
            xRes = 17
            yRes = 17
            zRes = 9

            x = np.linspace(-np.pi,np.pi, xRes)
            y = np.linspace(-np.pi,np.pi, yRes)
            z = np.linspace(0,np.pi, zRes)

            [X,Y,Z] = np.meshgrid(x,y,z,indexing='ij')

            # Flatten the meshgrid arrays into 1D arrays
            X_flat = X.flatten()
            Y_flat = Y.flatten()
            Z_flat = Z.flatten()

            # Compute the distance from the origin for each point
            distances = np.sqrt(X_flat**2 + Y_flat**2 + Z_flat**2)

            # Filter the points that lie inside the unit sphere
            inside_sphere = distances <= np.pi

            # Create a list of points that are inside the unit sphere
            points_inside_sphere = np.vstack((X_flat[inside_sphere], Y_flat[inside_sphere], Z_flat[inside_sphere])).T

            # Convert to a list of tuples
            points_inside_sphere_list = [tuple(point) for point in points_inside_sphere]

            # print(len(points_inside_sphere_list))
            # fig = plt.figure(figsize=(12, 12))
            # ax = fig.add_subplot(projection='3d')
            # ax.scatter(*zip(*points_inside_sphere_list))
            # plt.show()

            orientation_field = np.zeros((4,self.xRes,self.yRes,self.zRes))

            for point in points_inside_sphere_list:
                rotation = sp.spatial.transform.Rotation.from_rotvec(point)
                rotation_matrix = rotation.as_matrix()
                q = (rotation_matrix@self.q.transpose()).transpose()

                for n in range(self.number_of_primary_reciprocal_lattice_modes):
                    eta[n] = self.ifft(Gaussian_filter_f*self.fft(order_parameter*np.exp(
                            -1j*q[n][0]*self.x - 1j*q[n][1]*self.y)))
                
                Phi2 = np.zeros(self.dims)
                for n in range(self.number_of_primary_reciprocal_lattice_modes):
                    Phi2 += abs(eta[n])**2

                theta = np.sqrt(point[0]**2 + point[1]**2 + point[2]**2)
                nx = point[0]/theta if theta != 0 else 0
                ny = point[1]/theta if theta != 0 else 0
                nz = point[2]/theta if theta != 0 else 0

                orientation_field[0] += Phi2*np.cos(2*theta)
                orientation_field[1] += Phi2*np.sin(2*theta)*nx
                orientation_field[2] += Phi2*np.sin(2*theta)*ny
                orientation_field[3] += Phi2*np.sin(2*theta)*nz
            
            return orientation_field
                
    def calc_free_energy(self):
        """
        Calculate the total free energy of the system by integrating the free energy density over the computational domain.
        
        This method computes the phase field crystal free energy density using `calc_PFC_free_energy_density_and_chemical_potential`,
        and then integrates it over the entire domain using `calc_integrate_field`.
        
        Returns
        -------
        float
            The total free energy of the system.
        
        See Also
        --------
        calc_PFC_free_energy_density_and_chemical_potential : Method that calculates the free energy density and chemical potential.
        calc_integrate_field : Method that integrates a field over the computational domain.
        """
        free_energy_density, _ = self.calc_PFC_free_energy_density_and_chemical_potential()
        return self.calc_integrate_field(free_energy_density)

    #######################################################
    ############### PLOTTING FUNCTIONS ####################
    #######################################################
    def plot_field(self, field, **kwargs):
        """Plots the PFC.

        Parameters
        ----------
        field : ndarray
            The field to plot.
        kwargs : dict
            Keyword arguments for the plot. See https://comfitlib.com/ClassBaseSystem/ for a full list of keyword arguments.
            
        Returns
        -------
        tuple
            A tuple containing (ax, fig), the axes and figure containing the plot.
        """
        
        PFC_is_distorted = True if hasattr(self, 'bool_is_shear_distorted') and self.bool_is_shear_distorted else False

        if PFC_is_distorted:
            kwargs['xmin'] = np.min(self.X)
            kwargs['xmax'] = np.max(self.X)
            kwargs['ymin'] = np.min(self.Y)
            kwargs['ymax'] = np.max(self.Y)
            kwargs['X'] = self.X
            kwargs['Y'] = self.Y
        
        return super().plot_field(field, **kwargs)

    def plot_PFC(self, **kwargs):
        """Plots the PFC.

        Parameters
        ----------
        kwargs : dict
            Keyword arguments for the plot. See https://comfitlib.com/ClassBaseSystem/ for a full list of keyword arguments.
            
        Returns
        -------
        tuple
            A tuple containing (ax, fig), the axes and figure containing the plot.
        """
        PFC_has_velocity_field = hasattr(self, 'bool_has_velocity_field') and self.bool_has_velocity_field

        kwargs['colormap'] = kwargs.get('colormap', 'viridis' if self.plot_lib == 'plotly' else 'viridis')
        if PFC_has_velocity_field:
            return self.plot_field(self.psi[0], **kwargs)
        else:
            return self.plot_field(self.psi, **kwargs)

    def plot_orientation_field(self, orientation_field=None, **kwargs):
        """Plots the orientation field of the phase-field crystal.

        Parameters
        ----------
        orientation_field : ndarray, optional
            The orientation field to plot. If None, it will be calculated.
        kwargs : dict
            Keyword arguments for the plot. See https://comfitlib.com/ClassBaseSystem/ for a full list of keyword arguments.

        Returns
        -------
        tuple
            A tuple containing (ax, fig), the axes and figure containing the plot.
        """

        if orientation_field is None:
            orientation_field = self.calc_orientation_field()
        
        if self.dim == 2:
            complex_field = orientation_field[0] + 1j*orientation_field[1]
             
            if self.type == 'PhaseFieldCrystal2DTriangular':
                kwargs['cticks'] = [-np.pi, -2 * np.pi / 3, -np.pi / 3, 0, np.pi / 3, 2 * np.pi / 3, np.pi]
                kwargs['cticklabels'] = [r'$-\pi/6$', r'$-\pi/9$', r'$-\pi/18$', r'$0$', r'$\pi/18$', r'$\pi/9$', r'$\pi/6$']

            elif self.type == 'PhaseFieldCrystal2DSquare':
                kwargs['cticks'] = [-np.pi, -np.pi / 2, 0, np.pi / 2, np.pi]
                kwargs['cticklabels'] = [r'$-\pi/4$', r'$-\pi/8$', r'$0$', r'$\pi/8$', r'$\pi/4$']

            kwargs['plot_method'] = 'phase_angle'

            return self.plot_complex_field(complex_field, **kwargs)

        elif self.dim==3:
            theta = np.arccos(orientation_field[0])/2
            nnorm = np.sqrt(orientation_field[1]**2 + orientation_field[2]**2 + orientation_field[3]**2)
            nx = orientation_field[1]/nnorm
            ny = orientation_field[2]/nnorm 
            nz = orientation_field[3]/nnorm 

            vector_field = theta*np.array([nx,ny,nz])

            return self.plot_vector_field(vector_field, spacing=5, **kwargs)

--- End of file: comfit\phase_field_crystal\phase_field_crystal.py ---

--- Start of file: comfit\phase_field_crystal\phase_field_crystal_1d_periodic.py ---
from comfit.phase_field_crystal.phase_field_crystal import PhaseFieldCrystal

import numpy as np
from tqdm import tqdm
from scipy.optimize import fsolve
import scipy as sp
import matplotlib.pyplot as plt
from pprint import pprint

class PhaseFieldCrystal1DPeriodic(PhaseFieldCrystal):
    def __init__(self, nx, **kwargs):
        """
        Initializes a phase field crystal system in 1D with a periodic crystal structure.

        Parameters
        ----------
        nx : int
            The number of unit cells in the x direction.
        kwargs : dict, optional
            Additional parameters to configure the system.

        Returns
        -------
        PhaseFieldCrystal1DPeriodic
            The system object representing the simulation.
        """

        # Type of the system
        self.type = 'PhaseFieldCrystal1DPeriodic'
        self.dim = 1
        self.nx = nx

        # Default simulation parameters
        self.micro_resolution = kwargs.get('micro_resolution',[5])
        self.psi0 = -0.3
        self.r = -0.3
        self.t = 0
        self.v = 1
        self.dt = 0.1

        # If there are additional arguments provided, set them as attributes
        for key, value in kwargs.items():
            setattr(self, key, value)

        self.xRes = nx * self.micro_resolution[0]

        a0 = 2 * np.pi
        self.a = a0 * np.array([[1]])
        self.q = np.array([[1]])

        # Set the number of reciprocal modes
        self.number_of_reciprocal_lattice_modes = 1
        self.number_of_primary_reciprocal_lattice_modes = 1

        # Set the grid
        self.dx = a0 / self.micro_resolution[0]

        self.type_of_evolution = kwargs.get('type_of_evolution', 'conserved')
        self.A = self.calc_proto_amplitudes_conserved()
        self.eta0 = np.array([self.A])

        # Set the elastic constants
        self.el_mu = 3 * self.A ** 2
        self.el_lambda = 3 * self.A ** 2
        self.el_gamma = 0

        # Initialize the BaseSystem
        kwargs['xRes'] = self.xRes
        kwargs['dx'] = self.dx
        kwargs['dt'] = self.dt
        super().__init__(self.dim, **kwargs)

        # Set the a0
        self.a0 = a0
        self.bool_has_defined_length_scale = True

    def calc_proto_amplitudes_conserved(self):
        """
        Calculates the proto-amplitudes for the system.
        
        Returns
        -------
        float
            The proto-amplitudes for the system.
        """

        psi0 = self.psi0
        r = self.r
        t = self.t
        v = self.v

        A = 0
        
        A_tmp = 1/np.sqrt(3*v)*np.sqrt(- r - 2*t*psi0 - 3*v*psi0**2)
        if self.calc_free_energy_from_proto_amplitudes(psi0, A_tmp) < self.calc_free_energy_from_proto_amplitudes(psi0, A):
            A = A_tmp

        return A

    def calc_free_energy_from_proto_amplitudes(self, psi0, A):
        """
        Calculates the free energy of the system from the proto-amplitudes.

        Parameters
        ----------
        psi0 : float
            The average value of psi.
        A : float
            The proto-amplitude.

        Returns
        -------
        float
            The free energy of the system.
        """

        r = self.r
        t = self.t
        v = self.v

        return 2*np.pi*(1/2*psi0**2 + 1/2*r*(psi0**2 + 2*A**2) + 1/3*t*(psi0**3 + 6*psi0*A**2) + 1/4*v*(psi0**4 + 12*psi0**2*A**2 + 6*A**4))

    def calc_L_f(self):
        """
        Calculates the L operator in Fourier space.

        Returns
        -------
        ndarray
            The L operator in Fourier space.
        """
        k2 = self.calc_k2()
        return 1 - k2

    def calc_omega_f(self):
        """
        Calculates the free energy of the system.

        Returns
        -------
        ndarray
            The free energy of the system.
        """
        
        k2 = self.calc_k2()
        return - k2 * (self.r + (1 - k2)**2)
--- End of file: comfit\phase_field_crystal\phase_field_crystal_1d_periodic.py ---

--- Start of file: comfit\phase_field_crystal\phase_field_crystal_2d_square.py ---
from comfit.phase_field_crystal.phase_field_crystal import PhaseFieldCrystal

import numpy as np
from tqdm import tqdm
from scipy.optimize import fsolve
import scipy as sp
import matplotlib.pyplot as plt
from pprint import pprint

from comfit.tool.tool_print_in_color import tool_print_in_color

class PhaseFieldCrystal2DSquare(PhaseFieldCrystal):
    def __init__(self, nx, ny, **kwargs):
        """
        Initialize a phase field crystal system in 2D with a square crystal structure.

        Parameters
        ----------
        nx : int
            The number of unit cells in the x direction.
        ny : int
            The number of unit cells in the y direction.
        kwargs : dict, optional
            Additional keyword arguments to customize the simulation:
                micro_resolution : list
                    Resolution within each unit cell [x, y]
                psi0 : float
                    Average value of the density field
                r : float
                    Temperature parameter
                t : float
                    Parameter related to three-point correlation
                v : float
                    Parameter related to four-point correlation
                dt : float
                    Time step for simulation
                type_of_evolution : str
                    Type of dynamics ('conserved' or other)
                for_properties_calculation : bool
                    Whether this instance is for properties calculation

        Returns
        -------
        PhaseFieldCrystal2DSquare
            The system object representing the simulation.
        """

        # Type of the system
        self.type = 'PhaseFieldCrystal2DSquare'
        self.dim = 2
        self.nx = nx
        self.ny = ny

        # Default simulation parameters
        self.micro_resolution = [7, 7]
        self.psi0 = -0.3
        self.r = -0.3
        self.t = 0
        self.v = 1
        self.dt = 0.1

        # If there are additional arguments provided, set them as attributes
        for key, value in kwargs.items():
            setattr(self, key, value)

        self.xRes = nx * self.micro_resolution[0]
        self.yRes = ny * self.micro_resolution[1]

        a0 = 2 * np.pi
        self.a = a0 * np.array([[1, 0], [0, 1]])
        self.q = np.array([[1, 0], [0, 1], [1, -1], [1, 1]], dtype=float)

        # Set the number of reciprocal modes
        self.number_of_reciprocal_lattice_modes = 4
        self.number_of_primary_reciprocal_lattice_modes = 2

        # Set the grid
        self.dx = a0 / self.micro_resolution[0]
        self.dy = a0 / self.micro_resolution[1]

        self.type_of_evolution = kwargs.get('type_of_evolution', 'conserved')
        self.A_proto, self.B_proto = self.calc_proto_amplitudes_conserved()

        # Set the elastic constants
        self.el_lambda_proto = 16 * self.B_proto ** 2
        self.el_mu_proto = 16 * self.B_proto ** 2
        self.el_gamma_proto = 8 * self.A_proto ** 2 - 32 * self.B_proto ** 2

        bool_is_for_properties_calculation = kwargs.get('for_properties_calculation', False)

        if not bool_is_for_properties_calculation:
            tool_print_in_color('Initiating a 2D square PFC model.', 'green')
            kwargs.pop('for_properties_calculation', None)
            pfc = PhaseFieldCrystal2DSquare(1,1,for_properties_calculation=True, type_of_evolution=self.type_of_evolution, **kwargs)
            final_strain, self.psi0, self.A, self.B, self.el_lambda, self.el_mu, self.el_gamma = pfc.calc_strained_amplitudes()

            # Calculate S1111_ref
            dxxpsi = pfc.ifft(pfc.dif[0] * pfc.dif[0] * pfc.fft(pfc.psi)).real
            dxypsi = pfc.ifft(pfc.dif[0] * pfc.dif[1] * pfc.fft(pfc.psi)).real
            dyypsi = pfc.ifft(pfc.dif[1] * pfc.dif[1] * pfc.fft(pfc.psi)).real

            self.S1111_ref = np.mean(dxxpsi ** 2)
            self.Skkll_ref = np.mean(dxxpsi ** 2 + 2 * dxypsi ** 2 + dyypsi ** 2 )
            
        else:
            self.A = self.A_proto
            self.B = self.B_proto
            self.el_lambda = self.el_lambda_proto
            self.el_mu = self.el_mu_proto
            self.el_gamma = self.el_gamma_proto

        self.eta0 = np.array([self.A, self.A, self.B, self.B])

        # Initialize the BaseSystem
        kwargs['xRes'] = self.xRes
        kwargs['yRes'] = self.yRes
        kwargs['dx'] = self.dx
        kwargs['dy'] = self.dy
        kwargs['dt'] = self.dt
        super().__init__(self.dim, **kwargs)

        # Set the a0
        self.a0 = a0
        self.bool_has_defined_length_scale = True

        if not bool_is_for_properties_calculation:
            self.conf_apply_distortion([[final_strain,0],[0,final_strain]], update_q_and_a_vectors=True)
            self.a0 = self.a0 * (1+final_strain)
        
        
    def calc_proto_amplitudes_conserved(self):
        """Calculate the proto-amplitudes for the system.
        
        This method finds the optimal amplitude values (A, B) that minimize the free energy
        of the phase field crystal system with conserved dynamics.
        
        Returns
        -------
        tuple
            A tuple containing:
            - A : float
                The first proto-amplitude.
            - B : float
                The second proto-amplitude.
        """

        A = 0
        B = 0
        free_energy = self.calc_free_energy_from_proto_amplitudes(self.psi0, A, B)

        for A0 in np.linspace(0.01, 1, 10):
            for B0 in [A0/2]:
                [A_tmp, B_tmp] = fsolve(self.calc_proto_amplitude_equations_conserved, [A0, B0])
                free_energy_tmp = self.calc_free_energy_from_proto_amplitudes(self.psi0, A_tmp, B_tmp)

                if free_energy_tmp <= free_energy:
                    A = A_tmp
                    B = B_tmp
                    free_energy = free_energy_tmp

        return A, B

    def calc_proto_amplitude_equations_conserved(self, vars):
        """Calculate the equations for the proto-amplitudes for conserved dynamics.
        
        Parameters
        ----------
        vars : array_like
            The proto-amplitudes for the system [A, B].
            
        Returns
        -------
        list
            The equations for the proto-amplitudes that need to be solved.
            When both equations equal zero, the amplitudes are at equilibrium.
        """
        psi0 = self.psi0
        r = self.r
        t = self.t
        v = self.v
        
        A, B = vars
        eq1 = A*(r + 9*A**2*v + 18*B**2*v + 2*t*psi0 + 3*v*psi0**2 + 4*B*(t + 3*v*psi0))
        eq2 = 9*B**3*v + 2*A**2*(t + 3*v*psi0) + B*(r + 18*A**2*v + 2*t*psi0 + 3*v*psi0**2)

        return [eq1, eq2]

    def calc_free_energy_from_proto_amplitudes(self, psi0, A, B):
        """Calculate the free energy of the system from the proto-amplitudes.
        
        Parameters
        ----------
        psi0 : float
            The average value of psi.
        A : float
            The first proto-amplitude.
        B : float
            The second proto-amplitude.
            
        Returns
        -------
        float
            The free energy of the system.
        """
        r = self.r
        t = self.t
        v = self.v
        return (108*A**4*v + 108*B**4*v + psi0**2*(24 + 6*r + 4*t*psi0 + 3*v*psi0**2) + 24*B**2*(r + psi0*(2*t + 3*v*psi0)) + 24*A**2*(r + 18*B**2*v + 4*B*(t + 3*v*psi0) + psi0*(2*t + 3*v*psi0)))
    
    def calc_L_f(self):
        """Calculates the L operator in Fourier space.

        Parameters
        ----------
        None

        Returns
        -------
        np.ndarray
            The L operator in Fourier space.
        """
        k2 = self.calc_k2()
        return (1 - k2)*(2 - k2)

    def calc_L_sum_f(self):
        """Calculate the sum of the L operators in Fourier space. Needed for stress calculation functions.

        Returns
        -------
        np.ndarray
            The sum of the L operators in Fourier space.
        """
        k2 = self.calc_k2()
        return 3 - 2*k2
--- End of file: comfit\phase_field_crystal\phase_field_crystal_2d_square.py ---

--- Start of file: comfit\phase_field_crystal\phase_field_crystal_2d_triangular.py ---
from comfit.phase_field_crystal.phase_field_crystal import PhaseFieldCrystal

import numpy as np
from tqdm import tqdm
from scipy.optimize import fsolve
import scipy as sp
import matplotlib.pyplot as plt
from pprint import pprint

from comfit.tool.tool_print_in_color import tool_print_in_color

class PhaseFieldCrystal2DTriangular(PhaseFieldCrystal):
    def __init__(self, nx, ny, **kwargs):
        """
        Initializes a phase field crystal system in 2D with a triangular crystal structure.

        Parameters
        ----------
        nx : int
            The number of unit cells in the x direction.
        ny : int
            The number of unit cells in the y direction.
        kwargs : dict
            Additional arguments to set as attributes, possibly overwriting default values.

        Returns
        -------
        None
        """

        # Type of the system
        self.type = 'PhaseFieldCrystal2DTriangular'
        self.dim = 2
        self.nx = nx
        self.ny = ny

        # Default simulation parameters
        self.micro_resolution = [7, 12]
        self.psi0 = -0.3
        self.r = -0.3
        self.t = 0
        self.v = 1
        self.dt = 0.1

        # If there are additional arguments provided, set them as attributes
        # Possibly overwriting the default values
        for key, value in kwargs.items():
            setattr(self, key, value)

        self.xRes = nx * self.micro_resolution[0]
        self.yRes = ny * self.micro_resolution[1]

        a0 = 2 * np.pi * 2 / np.sqrt(3)
        self.a = a0 * np.array([[1, 0], [1 / 2, np.sqrt(3) / 2], [1 / 2, -np.sqrt(3) / 2]])
        self.q = np.array([[np.sqrt(3) / 2, -1 / 2], [0, 1], [-np.sqrt(3) / 2, -1 / 2]])

        # Set the number of reciprocal modes
        self.number_of_reciprocal_lattice_modes = 3
        self.number_of_primary_reciprocal_lattice_modes = 3

        # Set the grid
        self.dx = a0 / self.micro_resolution[0]
        self.dy = np.sqrt(3) * a0 / self.micro_resolution[1]

        self.type_of_evolution = kwargs.get('type_of_evolution', 'conserved')
        if self.type_of_evolution == 'unconserved':
            self.psi0_proto, self.A_proto = self.calc_proto_amplitudes_unconserved()
        else:
            if self.type_of_evolution != 'conserved':
                tool_print_in_color('Warning: type_of_evolution should be either conserved or unconserved. Setting to conserved.', 'red')
            self.A_proto = self.calc_proto_amplitudes_conserved()   

        # Set the elastic constants
        self.el_lambda_proto = 3 * self.A_proto ** 2
        self.el_mu_proto = 3 * self.A_proto ** 2
        self.el_gamma_proto = 0

        bool_is_for_properties_calculation = kwargs.get('for_properties_calculation', False)

        if not bool_is_for_properties_calculation:
            tool_print_in_color('Initiating a 2D triangular PFC model.', 'green')
            kwargs.pop('for_properties_calculation', None)
            pfc = PhaseFieldCrystal2DTriangular(1,1,for_properties_calculation=True, type_of_evolution=self.type_of_evolution, **kwargs)
            final_strain, self.psi0, self.A, self.el_lambda, self.el_mu, self.el_gamma = pfc.calc_strained_amplitudes()     

            # Calculate S1111_ref
            dxxxpsi = pfc.ifft(pfc.dif[0] * pfc.dif[0] * pfc.dif[0] * pfc.fft(pfc.psi)).real
            dxyypsi = pfc.ifft(pfc.dif[0] * pfc.dif[1] * pfc.dif[1] * pfc.fft(pfc.psi)).real
            dyyypsi = pfc.ifft(pfc.dif[1] * pfc.dif[1] * pfc.dif[1] * pfc.fft(pfc.psi)).real

            self.S111111_ref = np.mean(dxxxpsi ** 2)
            self.Skkllmm_ref = np.mean(dxxxpsi ** 2 + 3 * dxxxpsi*dxyypsi + 3 * dxyypsi**2 + dyyypsi**2)

        else:
            self.A = self.A_proto
            self.el_lambda = self.el_lambda_proto
            self.el_mu = self.el_mu_proto
            self.el_gamma = self.el_gamma_proto
            
        self.eta0 = np.array([self.A, self.A, self.A])

        # Initialize the BaseSystem
        kwargs['xRes'] = self.xRes
        kwargs['yRes'] = self.yRes
        kwargs['dx'] = self.dx
        kwargs['dy'] = self.dy
        kwargs['dt'] = self.dt
        super().__init__(self.dim,  **kwargs)
        
        # Set the a0
        self.a0 = a0
        self.bool_has_defined_length_scale = True
        
        if not bool_is_for_properties_calculation:
            self.conf_apply_distortion([[final_strain,0],[0,final_strain]], update_q_and_a_vectors=True)
            self.a0 = self.a0 *(1+final_strain)



    def calc_proto_amplitudes_conserved(self):
        """Calculate the proto-amplitudes for the system.

        Returns
        -------
        float
            The proto-amplitudes for the system.
        """

        psi0 = self.psi0
        r = self.r
        t = self.t
        v = self.v
        
        # Testing which of the three amplitudes give the lowest free energy
        A = 0
        A_tmp = 1 / (15 * v) * (-t - 3 * v * psi0 - np.sqrt(t**2 - 15 * v * r - 24 * t * v * psi0 - 36 * v ** 2 * psi0 ** 2)) 
        if self.calc_free_energy_from_proto_amplitudes(psi0, A_tmp) < self.calc_free_energy_from_proto_amplitudes(psi0, A):
            A = A_tmp
        A_tmp = 1 / (15 * v) * (-t - 3 * v * psi0 + np.sqrt(t**2 - 15 * v * r - 24 * t * v * psi0 - 36 * v ** 2 * psi0 ** 2)) 
        if self.calc_free_energy_from_proto_amplitudes(psi0, A_tmp) < self.calc_free_energy_from_proto_amplitudes(psi0, A):
            A = A_tmp
        return A

    def calc_proto_amplitudes_unconserved(self):
        """Calculate the proto-amplitudes for the system.

        Returns
        -------
        tuple
            The proto-amplitudes for the system.
        """

        psi0 = 0
        A = 0
        free_energy = self.calc_free_energy_from_proto_amplitudes(psi0, A)

        for psi00 in np.linspace(-1, 1, 10):
            for A0 in np.linspace(0.01, 1, 5):
                [psi0_tmp, A_tmp] = fsolve(self.calc_proto_amplitude_equations_unconserved, [psi00, A0])
                free_energy_tmp = self.calc_free_energy_from_proto_amplitudes(psi0_tmp, A_tmp)

                if free_energy_tmp <= free_energy:
                    psi0 = psi0_tmp
                    A = A_tmp
                    free_energy = free_energy_tmp

        return psi0, A

    def calc_proto_amplitude_equations_unconserved(self, vars):
        """
        Calculates the equations for the proto-amplitudes for the system in the case of conserved dynamics.

        Parameters
        ----------
        vars : tuple
            The proto-amplitudes for the system.

        Returns
        -------
        list
            The equations for the proto-amplitudes for the system.
        """
        r = self.r
        t = self.t
        v = self.v
        
        psi0, A = vars
        eq1 = 12 * A**3 * self.v + 6 * A**2 * (self.t + 3 * self.v * psi0) + psi0 * (1 + self.r + self.t * psi0 + self.v * psi0**2)
        eq2 = self.r + 15 * A**2 * self.v + 2 * A * (self.t + 3 * self.v * psi0) + psi0 * (2 * self.t + 3 * self.v * psi0) # *A not necessary  

        return [eq1, eq2]

    def calc_free_energy_from_proto_amplitudes(self, psi0, A):
        """
        Calculates the free energy of the system from the proto-amplitudes.

        Parameters
        ----------
        psi0 : float
            The average value of psi.
        A : float
            The proto-amplitude.

        Returns
        -------
        float
            The free energy of the system.
        """
        r = self.r
        t = self.t
        v = self.v

        return np.pi**2 / (3 * np.sqrt(3)) * (270 * A**4 * v + 48 * A**3 * (t + 3 * v * psi0) + psi0**2 * (6 + 6 * r + 4 * t * psi0 + 3 * v * psi0**2) + 36 * A**2 * (r + psi0 * (2 * t + 3 * v * psi0)))

    def calc_L_f(self):
        """
        Calculates the L operator in Fourier space.

        Returns
        -------
        np.ndarray
            The L operator in Fourier space.
        """
        k2 = self.calc_k2()
        return 1 - k2

    def calc_L_sum_f(self):
        """
        Calculates the sum of the L operators in Fourier space. Needed for stress calculation functions.

        Returns
        -------
        int
            The L operator in Fourier space.
        """
        return 1
--- End of file: comfit\phase_field_crystal\phase_field_crystal_2d_triangular.py ---

--- Start of file: comfit\phase_field_crystal\phase_field_crystal_3d_body_centered_cubic.py ---
from comfit.phase_field_crystal.phase_field_crystal import PhaseFieldCrystal

import numpy as np
from tqdm import tqdm
from scipy.optimize import fsolve
import scipy as sp
import matplotlib.pyplot as plt
from pprint import pprint
from comfit.tool.tool_print_in_color import tool_print_in_color


class PhaseFieldCrystal3DBodyCenteredCubic(PhaseFieldCrystal):
    def __init__(self, nx, ny, nz, **kwargs):
        """
        Initializes a phase field crystal system in 3D with a body centered cubic crystal structure.

        Parameters
        ----------
        nx : int
            The number of unit cells in the x direction.
        ny : int
            The number of unit cells in the y direction.
        nz : int
            The number of unit cells in the z direction.
        kwargs : dict
            Additional arguments to set as attributes.

        Returns
        -------
        None
        """

        # Type of the system
        self.type = 'PhaseFieldCrystal3DBodyCenteredCubic'
        self.dim = 3
        self.nx = nx
        self.ny = ny
        self.nz = nz

        # Default simulation parameters
        self.micro_resolution = [7, 7, 7]
        self.psi0 = -0.325
        self.r = -0.3
        self.t = 0
        self.v = 1
        self.dt = 0.1

        # If there are additional arguments provided, set them as attributes
        for key, value in kwargs.items():
            setattr(self, key, value)

        self.xRes = nx * self.micro_resolution[0]
        self.yRes = ny * self.micro_resolution[1]
        self.zRes = nz * self.micro_resolution[2]

        a0 = 2 * np.pi * np.sqrt(2)
        self.a = a0 / 2 * np.array([[-1, 1, 1],
                                    [1, -1, 1],
                                    [1, 1, -1],
                                    [1, 1, 1]])

        self.q = np.array([[0, 1, 1],
                           [1, 0, 1],
                           [1, 1, 0],
                           [0, -1, 1],
                           [-1, 0, 1],
                           [-1, 1, 0]]) / np.sqrt(2)

        # Set the number of reciprocal modes
        self.number_of_reciprocal_lattice_modes = 6
        self.number_of_primary_reciprocal_lattice_modes = 6

        # Set the grid
        self.dx = a0 / self.micro_resolution[0]
        self.dy = a0 / self.micro_resolution[1]
        self.dz = a0 / self.micro_resolution[2]

        self.type_of_evolution = kwargs.get('type_of_evolution', 'conserved')
        self.A_proto = self.calc_proto_amplitudes_conserved()

        # Set the elastic constants
        self.el_lambda_proto = 4 * self.A_proto ** 2
        self.el_mu_proto = 4 * self.A_proto ** 2
        self.el_gamma_proto = - 4*self.A_proto**2

        bool_is_for_properties_calculation = kwargs.get('for_properties_calculation', False)
        if not bool_is_for_properties_calculation:
            tool_print_in_color('Initiating a 3D bcc PFC model.', 'green')
            kwargs.pop('for_properties_calculation', None)
            pfc = PhaseFieldCrystal3DBodyCenteredCubic(1,1,1,for_properties_calculation=True, type_of_evolution=self.type_of_evolution, **kwargs)
            final_strain, self.psi0, self.A, self.el_lambda, self.el_mu, self.el_gamma = pfc.calc_strained_amplitudes()  
        else:
            self.A = self.A_proto
            self.el_lambda = self.el_lambda_proto
            self.el_mu = self.el_mu_proto
            self.el_gamma = self.el_gamma_proto


        self.eta0 = np.array([self.A, self.A, self.A, self.A, self.A, self.A])

        # Initialize the BaseSystem
        kwargs['xRes'] = self.xRes
        kwargs['yRes'] = self.yRes
        kwargs['zRes'] = self.zRes
        kwargs['dx'] = self.dx
        kwargs['dy'] = self.dy
        kwargs['dz'] = self.dz
        kwargs['dt'] = self.dt
        super().__init__(self.dim, **kwargs)

        # Set the a0
        self.a0 = a0
        self.bool_has_defined_length_scale = True

        if not bool_is_for_properties_calculation:
            self.conf_apply_distortion([[final_strain,0,0],[0,final_strain,0],[0,0,final_strain]], update_q_and_a_vectors=True)
            self.a0 = self.a0 * (1+final_strain)

    def calc_proto_amplitudes_conserved(self):
        """
        Calculates the proto-amplitudes for the system.

        Returns
        -------
        float
            The proto-amplitudes for the system.
        """
        psi0 = self.psi0
        r = self.r
        t = self.t
        v = self.v

        # Testing which of the three amplitudes give the lowest free energy
        A = 0
        A_tmp = 1 / (45 * v) * (-2 * t - 6 * v * psi0 + np.sqrt(4 * t**2 - 45 * r * v - 66 * t * v * psi0 - 99 * v**2 * psi0**2))
        if self.calc_free_energy_from_proto_amplitudes(psi0, A_tmp) < self.calc_free_energy_from_proto_amplitudes(psi0, A):
            A = A_tmp
        A_tmp = 1 / (45 * v) * (-2 * t - 6 * v * psi0 - np.sqrt(4 * t**2 - 45 * r * v - 66 * t * v * psi0 - 99 * v**2 * psi0**2))
        if self.calc_free_energy_from_proto_amplitudes(psi0, A_tmp) < self.calc_free_energy_from_proto_amplitudes(psi0, A):
            A = A_tmp
        return A

    def calc_free_energy_from_proto_amplitudes(self, psi0, A):
        """
        Calculates the free energy of the phase-field crystal from the proto amplitudes.

        Parameters
        ----------
        psi0 : float
            The average value of psi.
        A : float
            The proto-amplitude.

        Returns
        -------
        float
            The free energy of the phase-field crystal.
        """
        r = self.r
        t = self.t
        v = self.v

        return 4 * np.sqrt(2) * np.pi**3 / 3 * (1620 * A**4 * v + 192 * A**3 * (t + 3 * v * psi0) + psi0**2 * (6 + 6 * r + 4 * t * psi0 + 3 * v * psi0**2) + 72 * A**2 * (r + psi0 * (2 * t + 3 * v * psi0)))

    def calc_L_f(self):
        """Calculate the L operator in Fourier space.

        Returns
        -------
        numpy.ndarray
            The L operator in Fourier space.
        """
        k2 = self.calc_k2()
        return 1 - k2

    def calc_L_sum_f(self):
        """Calculate the sum of the L operators in Fourier space. Needed for stress calculation functions.

        Returns
        -------
        int
            The L operator in Fourier space.
        """
        return 1
--- End of file: comfit\phase_field_crystal\phase_field_crystal_3d_body_centered_cubic.py ---

--- Start of file: comfit\phase_field_crystal\phase_field_crystal_3d_face_centered_cubic.py ---
from comfit.phase_field_crystal.phase_field_crystal import PhaseFieldCrystal

import numpy as np
from tqdm import tqdm
from scipy.optimize import fsolve
import scipy as sp
import matplotlib.pyplot as plt
from pprint import pprint

from comfit.tool.tool_print_in_color import tool_print_in_color

class PhaseFieldCrystal3DFaceCenteredCubic(PhaseFieldCrystal):
    def __init__(self, nx, ny, nz, **kwargs):
        """
        Initializes a phase field crystal system in 3D with a face centered cubic crystal structure.

        Parameters
        ----------
        nx : int
            The number of unit cells in the x direction.
        ny : int
            The number of unit cells in the y direction.
        nz : int
            The number of unit cells in the z direction.
        kwargs : dict
            Additional arguments to set as attributes.

        Returns
        -------
        None
        """

        # Type of the system
        self.type = 'PhaseFieldCrystal3DFaceCenteredCubic'
        self.dim = 3
        self.nx = nx
        self.ny = ny
        self.nz = nz

        # Default simulation parameters
        self.micro_resolution = [11, 11, 11]
        self.psi0 = -0.325
        self.r = -0.3
        self.t = 0
        self.v = 1
        self.dt = 0.1

        # If there are additional arguments provided, set them as attributes
        for key, value in kwargs.items():
            setattr(self, key, value)

        self.xRes = nx * self.micro_resolution[0]
        self.yRes = ny * self.micro_resolution[1]
        self.zRes = nz * self.micro_resolution[2]

        a0 = 2 * np.pi * np.sqrt(3)
        self.a = a0 / 2 * np.array([[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0],
                                    [0, -1, 1],
                                    [-1, 0, 1],
                                    [-1, 1, 0]], dtype=float)

        self.q = np.array([[-1, 1, 1],
                           [1, -1, 1],
                           [1, 1, -1],
                           [1, 1, 1],
                           [2, 0, 0],
                           [0, 2, 0],
                           [0, 0, 2]], dtype=float) / np.sqrt(3)

        # Set the number of reciprocal modes
        self.number_of_reciprocal_lattice_modes = 7
        self.number_of_primary_reciprocal_lattice_modes = 4

        # Set the grid
        self.dx = a0 / self.micro_resolution[0]
        self.dy = a0 / self.micro_resolution[1]
        self.dz = a0 / self.micro_resolution[2]

        self.type_of_evolution = kwargs.get('type_of_evolution', 'conserved')
        self.A_proto, self.B_proto = self.calc_proto_amplitudes_conserved()
    
        # Set the elastic constants
        self.el_lambda_proto = 32/81 * self.A_proto ** 2
        self.el_mu_proto = 32/81 * self.A_proto ** 2
        self.el_gamma_proto = 32/81 * (2*self.B_proto**2 - self.A_proto**2)

        bool_is_for_properties_calculation = kwargs.get('for_properties_calculation', False)
        if not bool_is_for_properties_calculation:
            tool_print_in_color('Initiating a 3D fcc PFC model.', 'green')
            kwargs.pop('for_properties_calculation', None)
            pfc = PhaseFieldCrystal3DFaceCenteredCubic(1,1,1,for_properties_calculation=True, type_of_evolution=self.type_of_evolution, **kwargs)
            final_strain, self.psi0, self.A, self.B, self.el_lambda, self.el_mu, self.el_gamma = pfc.calc_strained_amplitudes()  
        else:
            self.A = self.A_proto
            self.B = self.B_proto
            self.el_lambda = self.el_lambda_proto
            self.el_mu = self.el_mu_proto
            self.el_gamma = self.el_gamma_proto
            
        self.eta0 = np.array([self.A, self.A, self.A, self.A, self.B, self.B, self.B])

        # Initialize the BaseSystem
        kwargs['xRes'] = self.xRes
        kwargs['yRes'] = self.yRes
        kwargs['zRes'] = self.zRes
        kwargs['dx'] = self.dx
        kwargs['dy'] = self.dy
        kwargs['dz'] = self.dz
        kwargs['dt'] = self.dt
        super().__init__(self.dim, **kwargs)

        # Set the a0
        self.a0 = a0
        self.bool_has_defined_length_scale = True

        if not bool_is_for_properties_calculation:
            self.conf_apply_distortion([[final_strain,0,0],[0,final_strain,0],[0,0,final_strain]], update_q_and_a_vectors=True)
            self.a0 = self.a0 * (1+final_strain)

        
    def calc_proto_amplitudes_conserved(self):
        """
        Calculates the proto-amplitudes for the system.

        Returns
        -------
        tuple
            The proto-amplitudes for the system.
        """

        A = 0
        B = 0
        free_energy = self.calc_free_energy_from_proto_amplitudes(self.psi0, A, B)

        for A0 in np.linspace(0.01, 1, 10):
            for B0 in [A0/2]:
                [A_tmp, B_tmp] = fsolve(self.calc_proto_amplitude_equations_conserved, [A0, B0])
                free_energy_tmp = self.calc_free_energy_from_proto_amplitudes(self.psi0, A_tmp, B_tmp)

                if free_energy_tmp <= free_energy:
                    A = A_tmp
                    B = B_tmp
                    free_energy = free_energy_tmp

        return A, B

    def calc_proto_amplitude_equations_conserved(self, vars):
        """
        Calculates the equations for the proto-amplitudes for the system in the case of conserved dynamics.

        Parameters
        ----------
        vars : list
            The proto-amplitudes for the system.
        
        Returns
        -------
        list
            The equations for the proto-amplitudes for the system in the case of conserved dynamics.
        """
        psi0 = self.psi0
        r = self.r
        t = self.t
        v = self.v

        A, B = vars
        eq1 = A*( r + 27*A**2*v + 36*B**2*v + 2*t*psi0 + 3*v*psi0**2 + 6*B*(t + 3*v*psi0))
        eq2 = 15*B**3*v + 4*A**2*(t + 3*v*psi0) + B*( r + 48*A**2*v + 2*t*psi0 + 3*v*psi0**2)

        return [eq1, eq2]

    def calc_free_energy_from_proto_amplitudes(self, psi0, A, B):
        """
        Calculates the free energy of the system from the proto-amplitudes.

        Parameters
        ----------
        psi0 : float
            The average value of psi.
        A : float
            The proto-amplitude.
        B : float
            The proto-amplitude.

        Returns
        -------
        float
            The free energy of the system.
        """

        r = self.r
        t = self.t
        v = self.v
        return 2*np.pi**3/np.sqrt(3)*(1944*A**4*v + 810*B**4*v + psi0**2*(32 + 18*r + 12*t*psi0 + 9*v*psi0**2) + 108*B**2*(r + psi0*(2*t + 3*v*psi0)) + 144*A**2*( r + 36*B**2*v + 6*B*(t + 3*v*psi0) + psi0*(2*t + 3*v*psi0)))

    def calc_L_f(self):
        """
        Calculates the L operator in Fourier space.

        Returns
        -------
        numpy.ndarray
            The L operator in Fourier space.
        """
        k2 = self.calc_k2()
        return (1 - k2)*(4/3-k2)

    def calc_L_sum_f(self):
        """
        Calculates the sum of the L operators in Fourier space. Needed for stress calculation functions.

        Returns
        -------
        numpy.ndarray
            The L operator in Fourier space.
        """
        k2 = self.calc_k2()
        return 7/3 - 2*k2
--- End of file: comfit\phase_field_crystal\phase_field_crystal_3d_face_centered_cubic.py ---

--- Start of file: comfit\phase_field_crystal\phase_field_crystal_3d_simple_cubic.py ---
from comfit.phase_field_crystal.phase_field_crystal import PhaseFieldCrystal

import numpy as np
from tqdm import tqdm
from scipy.optimize import fsolve
import scipy as sp
import matplotlib.pyplot as plt
from pprint import pprint

from comfit.tool.tool_print_in_color import tool_print_in_color

class PhaseFieldCrystal3DSimpleCubic(PhaseFieldCrystal):
    def __init__(self, nx, ny, nz, **kwargs):
        """
        Initializes a phase field crystal system in 3D with a simple cubic crystal structure.

        Parameters
        ----------
        nx : int
            The number of unit cells in the x direction.
        ny : int
            The number of unit cells in the y direction.
        nz : int
            The number of unit cells in the z direction.
        kwargs : dict
            Additional arguments to set as attributes.

        Returns
        -------
        None
        """
        # Type of the system
        self.type = 'PhaseFieldCrystal3DSimpleCubic'
        self.dim = 3
        self.nx = nx
        self.ny = ny
        self.nz = nz

        # Default simulation parameters
        self.micro_resolution = [5, 5, 5]
        self.psi0 = -0.325
        self.r = -0.3
        self.t = 0
        self.v = 1
        self.dt = 0.1
        # TODO: Some of this code seems to be reprinted. Maybe it should be moved to the BaseSystem class? (Vidar 18.12.23)

        # If there are additional arguments provided, set them as attributes
        for key, value in kwargs.items():
            setattr(self, key, value)

        self.xRes = nx * self.micro_resolution[0]
        self.yRes = ny * self.micro_resolution[1]
        self.zRes = nz * self.micro_resolution[2]

        a0 = 2 * np.pi
        self.a = a0 * np.array([[1, 0, 0],
                                [0, 1, 0],
                                [0, 0, 1]])

        self.q = np.array([[1, 0, 0],
                           [0, 1, 0],
                           [0, 0, 1],
                           [0, 1, 1],
                           [1, 0, 1],
                           [1, 1, 0],
                           [0, -1, 1],
                           [-1, 0, 1],
                           [-1, 1, 0],
                           [-1, 1, 1],
                           [1, -1, 1],
                           [1, 1, -1],
                           [1, 1, 1]], dtype=float)

        # Set the number of reciprocal modes
        self.number_of_reciprocal_lattice_modes = 13
        self.number_of_primary_reciprocal_lattice_modes = 3

        # Set the grid
        self.dx = a0 / self.micro_resolution[0]
        self.dy = a0 / self.micro_resolution[1]
        self.dz = a0 / self.micro_resolution[2]

        self.type_of_evolution = kwargs.get('type_of_evolution', 'conserved')
        self.A_proto, self.B_proto, self.C_proto = self.calc_proto_amplitudes_conserved()

        # Set the elastic constants
        self.el_lambda_proto = 16 * self.B_proto ** 2 + 128 * self.C_proto ** 2
        self.el_mu_proto = 16 * self.B_proto ** 2 + 128 * self.C_proto ** 2
        self.el_gamma_proto = 32*self.A_proto**2 - 16*self.B_proto**2 - 256*self.C_proto**2

        bool_is_for_properties_calculation = kwargs.get('for_properties_calculation', False)

        if not bool_is_for_properties_calculation:
            tool_print_in_color('Initiating a 3D simple cubic PFC model.', 'green')
            kwargs.pop('for_properties_calculation', None)
            pfc = PhaseFieldCrystal3DSimpleCubic(1,1,1,for_properties_calculation=True, type_of_evolution=self.type_of_evolution, **kwargs)
            final_strain, self.psi0, self.A, self.B, self.C, self.el_lambda, self.el_mu, self.el_gamma = pfc.calc_strained_amplitudes()     
        else:
            self.A = self.A_proto
            self.B = self.B_proto
            self.C = self.C_proto
            self.el_lambda = self.el_lambda_proto
            self.el_mu = self.el_mu_proto
            self.el_gamma = self.el_gamma_proto


        self.eta0 = np.array([self.A, self.A, self.A,
                     self.B, self.B, self.B, self.B, self.B, self.B,
                     self.C, self.C, self.C, self.C])

        # Initialize the BaseSystem
        kwargs['xRes'] = self.xRes
        kwargs['yRes'] = self.yRes
        kwargs['zRes'] = self.zRes
        kwargs['dx'] = self.dx
        kwargs['dy'] = self.dy
        kwargs['dz'] = self.dz
        kwargs['dt'] = self.dt
        super().__init__(self.dim,  **kwargs)

        # Set the a0
        self.a0 = a0
        self.bool_has_defined_length_scale = True

        if not bool_is_for_properties_calculation:
            self.conf_apply_distortion([[final_strain,0,0],[0,final_strain,0],[0,0,final_strain]], update_q_and_a_vectors=True)
            self.a0 = self.a0 * (1+final_strain)

    def calc_free_energy_from_proto_amplitudes(self, psi0, A, B, C):
        """
        Calculates the free energy of the system from the proto-amplitudes.

        Parameters
        ----------
        psi0 : float
            The value of psi0.
        A : float
            The value of A.
        B : float
            The value of B.
        C : float
            The value of C.

        Returns
        -------
        float
            The free energy of the system.
        """
        r = self.r
        t = self.t
        v = self.v
        return 2*np.pi**3/3*(48*C**2*r + 270*A**4*v + 1620*B**4*v + 576*A**3*C*v + 648*C**4*v + 96*C**2*t*psi0 + 6*(36 + r + 24*C**2*v)*psi0**2 + 4*t*psi0**3 + 3*v*psi0**4 + 192*B**3*(t + 3*v*psi0) + 576*A*B*C*(t + 3*v*(3*B + psi0)) + 36*A**2*( r + 96*B**2*v + 36*C**2*v + 2*t*psi0 + 3*v*psi0**2 + 8*B*( t + 3*v*psi0)) + 72*B**2*(r + 54*C**2*v + psi0*(2*t + 3*v*psi0)) )

    def calc_proto_amplitudes_conserved(self):
        """
        Calculates the proto-amplitudes for the system.

        Parameters
        ----------
        None

        Returns
        -------
        tuple
            The proto-amplitudes for the system.
        """
        psi0 = self.psi0
        r = self.r
        t = self.t
        v = self.v

        A = 0
        B = 0
        C = 0
        free_energy = self.calc_free_energy_from_proto_amplitudes(psi0, A, B, C)

        for A0 in np.linspace(0.01, 1, 10):
            for B0 in [A0/2]:
                for C0 in [A0/4]:
                    [A_tmp, B_tmp, C_tmp] = fsolve(self.calc_proto_amplitude_equations_conserved, [A0, B0, C0])
                    free_energy_tmp = self.calc_free_energy_from_proto_amplitudes(psi0, A_tmp, B_tmp, C_tmp)

                    if free_energy_tmp <= free_energy:
                        A = A_tmp
                        B = B_tmp
                        C = C_tmp
                        free_energy = free_energy_tmp

        return A, B, C

    def calc_proto_amplitude_equations_conserved(self, vars):
        """
        Calculates the equations for the proto-amplitudes for the system in the case of conserved dynamics.

        Parameters
        ----------
        vars : list
            The proto-amplitudes for the system.

        Returns
        -------
        list
            The equations for the proto-amplitudes for the system in the case of conserved dynamics.
        """
        psi0 = self.psi0
        r = self.r
        t = self.t
        v = self.v

        A, B, C = vars

        eq1 = 15*A**3*v + 24*A**2*C*v + 8*B*C*(t + 3*v*(3*B + psi0)) + A*( r + 96*B**2*v + 36*C**2*v + 2*t*psi0 + 3*v*psi0**2 + 8*B*(t + 3*v*psi0))
        eq2 = 45*B**3*v + 4*B**2*(t + 3*v*psi0) + 2*A*(A + 2*C)*(t + 3*v*psi0) + B*( r + 48*A**2*v + 72*A*C*v + 54*C**2*v + 2*t*psi0 + 3*v*psi0**2)
        eq3 = 27*C**3*v + C*( r + 27*A**2*v + 81*B**2*v + 2*t*psi0 + 3*v*psi0**2) + 6*A*(A**2*v + 9*B**2*v + B*(t + 3*v*psi0))

        return [eq1, eq2, eq3]

    def calc_L_f(self):
        """
        Calculates the L operator in Fourier space.

        Parameters
        ----------
        None

        Returns
        -------
        numpy.ndarray
            The L operator in Fourier space.
        """
        k2 = self.calc_k2()
        return (1 - k2)*(2 - k2)*(3 - k2)

    def calc_L_sum_f(self):
        """
        Calculates the sum of the L operators in Fourier space. Needed for stress calculation functions.

        Parameters
        ----------
        None

        Returns
        -------
        numpy.ndarray
            The L operator in Fourier space.
        """
        k2 = self.calc_k2()
        return 11 - 12*k2 + 3*k2**2
--- End of file: comfit\phase_field_crystal\phase_field_crystal_3d_simple_cubic.py ---

--- Start of file: comfit\phase_field_crystal\__init__.py ---
from .phase_field_crystal_1d_periodic import PhaseFieldCrystal1DPeriodic
from .phase_field_crystal_2d_triangular import PhaseFieldCrystal2DTriangular
from .phase_field_crystal_2d_square import PhaseFieldCrystal2DSquare
from .phase_field_crystal_3d_body_centered_cubic import PhaseFieldCrystal3DBodyCenteredCubic
from .phase_field_crystal_3d_face_centered_cubic import PhaseFieldCrystal3DFaceCenteredCubic
from .phase_field_crystal_3d_simple_cubic import PhaseFieldCrystal3DSimpleCubic
--- End of file: comfit\phase_field_crystal\__init__.py ---

