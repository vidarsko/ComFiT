--- Start of file: tests\tests_bose_einstein_condensate\test_bose_einstein_condensate.py ---
import unittest
import sys
import os

# Run 
# Adjust the path to import the comfit package 
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../../')))
import comfit as cf
import numpy as np
import matplotlib.pyplot as plt

class TestBoseEinsteinCondensate(unittest.TestCase):
    def test_init_with_dimension(self):
        """Test BoseEinsteinCondensate initialization with a dimension parameter."""
        for dim in [1, 2, 3]:
            try:
                bec = cf.BoseEinsteinCondensate(dim)
                self.assertIsInstance(bec, cf.BoseEinsteinCondensate)
            except Exception as e:
                self.fail(f"Initialization failed with dimension {dim}: {e}")

    def test_dGPE_relaxer(self):
        """Test the dGPE relaxer."""
        bec = cf.BoseEinsteinCondensate(2,xRes=23,yRes=14)
        np.random.seed(29160566)
        bec.conf_initial_condition_disordered()
        bec.evolve_relax(1000)

        # Set the tolerance for approximation
        tolerance = 0.01

        # Check if all elements in bec.psi are approximately 1
        condition = np.allclose(abs(bec.psi), 1, atol=tolerance)
        self.assertTrue(condition, "Elements in bec.psi are not approximately 1")

    def test_vortex_tracker_2D(self):
        bec = cf.BoseEinsteinCondensate(2,xRes=31,yRes=31)
        bec.conf_insert_vortex_dipole(
            dipole_vector=[bec.xmax/3,0],
            dipole_position=bec.rmid)
        bec.evolve_relax(100)
        Dnodes = bec.calc_vortex_nodes()

        # Testing the number of nodes
        self.assertEqual(len(Dnodes),2,"Dipole nodes not found")

        # Create lists of the x and y positions of the nodes
        xpos = [node['position'][0] for node in Dnodes]
        ypos = [node['position'][1] for node in Dnodes]

        # Sort the lists according to xpos
        sorted_lists = sorted(zip(xpos, ypos))

        # Unzip the sorted lists
        xpos, ypos = zip(*sorted_lists)
        
        # Testing the position of the first node
        self.assertAlmostEqual(xpos[0],bec.xmax/3,delta=1)
        self.assertAlmostEqual(ypos[0],bec.ymax/2,delta=1)

        # Testing the position of the second node
        self.assertAlmostEqual(xpos[1],2*bec.xmax/3,delta=1)
        self.assertAlmostEqual(ypos[1],bec.ymax/2,delta=1)

    def test_vortex_tracker_3D(self):
        bec = cf.BoseEinsteinCondensate(3,xRes=31, yRes=31, zRes=31)
        # Set the plane equation
        a = 0.2
        b = 0.3
        c = 0.5
        
        # Insert a vortex ring
        bec.conf_insert_vortex_ring(
            normal_vector=[a,b,c],
            position=bec.rmid, 
            radius=bec.xmax/3)
        
        # Relax the system
        bec.evolve_relax(100)
        Dnodes = bec.calc_vortex_nodes()
        
        #Check that there are nodes
        self.assertGreater(len(Dnodes),0,"Vortex nodes not found")

        #Check that all the nodes belong to the correct plane
        for node in Dnodes:
            # Calculate the plane equation
            plane_equation = a*(node['position'][0]-bec.rmid[0]) \
                            + b*(node['position'][1]-bec.rmid[1]) \
                            + c*(node['position'][2]-bec.rmid[2])

            # Check if the plane equation is zero
            self.assertAlmostEqual(plane_equation,0,delta=0.5)
            







if __name__ == '__main__':
    unittest.main()

--- End of file: tests\tests_bose_einstein_condensate\test_bose_einstein_condensate.py ---

--- Start of file: tests\tests_bose_einstein_condensate\__init__.py ---

--- End of file: tests\tests_bose_einstein_condensate\__init__.py ---

--- Start of file: tests\tests_core\test_base_system.py ---
import unittest
import sys
import os

# Run 
# Adjust the path to import the comfit package
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../../')))
import comfit as cf
import numpy as np
import scipy as sp

class TestBaseSystem(unittest.TestCase):

    def test_init_empty(self):
        """ Test BaseSystem initialization with  parameters """
        for dim in [1,2,3]:
            try:
                bs = cf.BaseSystem(dim)
                self.assertIsInstance(bs, cf.BaseSystem)
            except Exception as e:
                self.fail(f"Initialization failed with no parameters: {e}")

    def test_init_with_dim_1_and_params(self):
        """ Test 1D BaseSystem initialization with different parameters """
        params = [
            {'xRes': 11, 'dx': 0.1},
            {'xRes': 32, 'dx': 0.3}
            # Add more parameter combinations as needed
        ]
        for p in params:
            with self.subTest(p=p):
                try:
                    bs = cf.BaseSystem(1,**p)
                    self.assertIsInstance(bs, cf.BaseSystem)
                except Exception as e:
                    self.fail(f"Initialization failed with parameters {p}: {e}")

    def test_init_with_dim_2_and_params(self):
        """ Test 2D BaseSystem initialization with different parameters """
        params = [
            {'xRes': 11, 'dx': 0.1, 'yRes': 16, 'dy': 0.1},
            {'xRes': 28, 'dx': 0.2, 'yRes': 32, 'dy': 1.3},
            # Add more parameter combinations as needed
        ]
        for p in params:
            with self.subTest(p=p):
                try:
                    bs = cf.BaseSystem(2,**p)
                    self.assertIsInstance(bs, cf.BaseSystem)
                except Exception as e:
                    self.fail(f"Initialization failed with parameters {p}: {e}")

    def test_init_with_dim_3_and_params(self):
        """ Test 3D BaseSystem initialization with different parameters """
        params = [
            {'xRes': 11, 'dx': 0.1, 'yRes': 16, 'dy': 0.1, 'zRes': 16, 'dz': 0.1},
            {'xRes': 28, 'dx': 0.2, 'yRes': 32, 'dy': 1.3, 'zRes': 32, 'dz': 0.2},
            # Add more parameter combinations as needed
        ]
        for p in params:
            with self.subTest(p=p):
                try:
                    bs = cf.BaseSystem(3,**p)
                    self.assertIsInstance(bs, cf.BaseSystem)
                except Exception as e:
                    self.fail(f"Initialization failed with parameters {p}: {e}")

    def test_str(self):
        """ Test BaseSystem string representation """
        
        # Initialize BaseSystem object
        bs = cf.BaseSystem(1)

        # Get string representation
        result = bs.__str__()

        # Check if result is a string
        assert isinstance(result, str), "Expected string representation of BaseSystem object"

    def test_calc_angle_field_single_vortex(self):
        """ Test calculation of angle field for single vortex """
        
        # Initialize BaseSystem object
        bs = cf.BaseSystem(2, xRes=32, dx=0.1, yRes=32, dy=0.1)

        # Calculate angle field
        angle_field = bs.calc_angle_field_single_vortex(position=bs.rmid,charge=-1)

        # Check if angle field is a numpy array
        assert isinstance(angle_field, np.ndarray), "Expected numpy array for angle field"

        # Check if angle field has the correct shape
        assert angle_field.shape == (bs.yRes, bs.xRes), "Expected angle field with shape (yRes, xRes)"

        # Check if angle is between -pi and pi
        assert np.all(angle_field >= -np.pi) and np.all(angle_field <= np.pi), "Expected angle field between -pi and pi"
        

    def test_calc_angle_field_vortex_dipole(self):
        """ Test calculation of angle field for vortex dipole """
        
        # Initialize BaseSystem object
        bs = cf.BaseSystem(2, xRes=32, dx=0.1, yRes=32, dy=0.1)

        # Calculate angle field
        angle_field = bs.calc_angle_field_vortex_dipole(dipole_vector=[0.24*bs.xmax,0.3*bs.ymax], dipole_position=bs.rmid)

        # Check if angle field is a numpy array
        assert isinstance(angle_field, np.ndarray), "Expected numpy array for angle field"

        # Check if angle field has the correct shape
        assert angle_field.shape == (bs.yRes, bs.xRes), "Expected angle field with shape (yRes, xRes)"

        # Check if angle is between -pi and pi
        assert np.all(angle_field >= -np.pi) and np.all(angle_field <= np.pi), "Expected angle field between -pi and pi"

    def test_calc_angle_field_vortex_ring(self):
        """ Test calculation of angle field for vortex ring """
        
        # Initialize BaseSystem object
        bs = cf.BaseSystem(3, xRes=32, dx=0.1, yRes=32, dy=0.1, zRes=32, dz=0.1)

        # Calculate angle field
        angle_field = bs.calc_angle_field_vortex_ring(normal_vector=[0.1,0.4,0.2], position=bs.rmid)

        # Check if angle field is a numpy array
        assert isinstance(angle_field, np.ndarray), "Expected numpy array for angle field"

        # Check if angle field has the correct shape
        assert angle_field.shape == (bs.zRes, bs.yRes, bs.xRes), "Expected angle field with shape (zRes, yRes, xRes)"

        # Check if angle is between -pi and pi
        assert np.all(angle_field >= -np.pi) and np.all(angle_field <= np.pi), "Expected angle field between -pi and pi"


    def test_calc_wavenums(self):
        """ Test calculation of wavenumbers """
        
        # Initialize BaseSystem object
        bs = cf.BaseSystem(1)

        x = np.array([-10, -5, 0, 5, 10])
        k = bs.calc_wavenums(x)

        #Check values of k
        np.testing.assert_allclose(k, np.array([ 0., 0.25132741,0.50265482,-0.50265482,-0.25132741]))


    def test_calc_determinant_field(self):
        """ Test calculation of determinant field """
        
        # Initialize BaseSystem object
        bs = cf.BaseSystem(2, xRes=101, dx=1, yRes=101, dy=1)

        # 2 dimensions
        # Testing a zero-field
        psi = np.zeros((2,bs.xRes,bs.yRes))
        D = bs.calc_determinant_field(psi)
        np.testing.assert_allclose(D, np.zeros((bs.xRes,bs.yRes)))

        # Testing a +1 charge field
        # Making the field respecting the periodicity
        psi[0] = bs.xmax/(2*np.pi)*np.sin((bs.x - bs.xmid)/bs.xmax*2*np.pi)
        psi[1] = bs.ymax/(2*np.pi)*np.sin((bs.y - bs.ymid)/bs.ymax*2*np.pi)
        D = bs.calc_determinant_field(psi)
        self.assertAlmostEqual(D[bs.xmidi,bs.ymidi], 1.0)

        # Testing a -1 charge field
        # Making the field respecting the periodicity
        psi[0] = bs.xmax/(2*np.pi)*np.sin((bs.x - bs.xmid)/bs.xmax*2*np.pi)
        psi[1] = -bs.ymax/(2*np.pi)*np.sin((bs.y - bs.ymid)/bs.ymax*2*np.pi)
        D = bs.calc_determinant_field(psi)
        self.assertAlmostEqual(D[bs.xmidi,bs.ymidi], -1.0)

        # 3 dimensions
        # Testing a 0-field
        bs = cf.BaseSystem(3, xRes=31, dx=1, yRes=42, dy=1, zRes=13, dz=1)
        psi = np.zeros((2,bs.xRes,bs.yRes,bs.zRes))
        D = bs.calc_determinant_field(psi)
        np.testing.assert_allclose(D, np.zeros((3,bs.xRes,bs.yRes,bs.zRes)))
    
        # Testing a +1 charge field
        # Making the field respecting the periodicity
        psi[0] = bs.xmax/(2*np.pi)*np.sin((bs.x - bs.xmid)/bs.xmax*2*np.pi)
        psi[1] = bs.zmax/(2*np.pi)*np.sin((bs.z - bs.zmid)/bs.zmax*2*np.pi)
        D = bs.calc_determinant_field(psi)
        # At the center, the defect density should point in the negative y-direction
        np.testing.assert_allclose(np.array([
                                 D[0,bs.xmidi,bs.ymidi,bs.zmidi],
                                 D[1,bs.xmidi,bs.ymidi,bs.zmidi],
                                 D[2,bs.xmidi,bs.ymidi,bs.zmidi]]), 
                                 np.array([0.0, -1.0, 0.0]),atol=1e-15)



    def test_evolution_scheme_1d(self):
        """ Test 1D evolution scheme """
        
        # Testing the wave equation in one dimensions
        # Initialize BaseSystem object
        bs = cf.BaseSystem(1, xRes=101, dx=1)

        # Set test parameters
        bs.A = 0.1
        bs.sigma = 5
        bs.T0 = 20

        # Set end time
        end_time = 200

        # Scipy benchmark

        # Initial condition
        T_initial = np.zeros((bs.xRes))

        # Forcing term function
        def forcing_term(T):
            return bs.A*(bs.T0-T)*np.exp(-(bs.x-bs.xmid)**2/(2*bs.sigma**2))
        
        # Function representing the discretized PDE
        def heat_equation(t, T):
            dTdx2 = np.roll(T, -1) - 2 * T + np.roll(T, 1)
            dTdx2 /= bs.dx**2
            return dTdx2 + forcing_term(T)

        # Time span for the integration
        t_span = (0, end_time)

        # Solve the equation
        T_benchmark = sp.integrate.solve_ivp(heat_equation, t_span, T_initial, method='RK45')

        # ComFiT simulation

        for method in ['ETD2RK','ETD4RK']:
            # ComFiT simulation

            # Add linear and non-linear functions
            def calc_omega_f(bs):
                return -bs.calc_k2()

            def calc_nonlinear_evolution_function_f(bs,T,t):
                f = bs.A*(bs.T0-T)*np.exp(-(bs.x-bs.xmid)**2/(2*bs.sigma**2))
                return sp.fft.fft(f)

            # Add functions to BaseSystem object
            bs.calc_omega_f = calc_omega_f.__get__(bs)
            bs.calc_nonlinear_evolution_function_f = calc_nonlinear_evolution_function_f.__get__(bs)

            # Define evolve function
            def evolve(bs,number_of_steps, method = method):
                omega_f = bs.calc_omega_f()

                integrating_factors_f, solver = bs.calc_integrating_factors_f_and_solver(omega_f,method)

                for n in range(number_of_steps):
                    bs.T, bs.T_f = solver(integrating_factors_f,
                                            bs.calc_nonlinear_evolution_function_f,
                                            bs.T, bs.T_f)
                    bs.T = np.real(bs.T)
            
            # Add evolve function to BaseSystem object
            bs.evolve = evolve.__get__(bs)

            # Initial condition
            bs.T = np.zeros((bs.xRes))
            bs.T_f = sp.fft.fft(bs.T)   

            # Evolve the system
            number_of_steps = int(end_time/bs.dt)
            bs.evolve(number_of_steps)

            # Check if the solution is close to the benchmark
            np.testing.assert_allclose(bs.T, T_benchmark.y[:,-1], atol=1e-2, rtol=1e-2)
            
        
    def test_evolution_scheme_2d(self):
        """ Test 2D evolution scheme"""

        # Testing the wave equation in two dimensions
        # Initialize BaseSystem object
        bs = cf.BaseSystem(2, xRes=51, dx=1, yRes=51, dy=1)

        # Set test parameters
        bs.A = 0.1
        bs.sigma = 2
        bs.T0 = 20

        # Set end time
        end_time = 100

        # Scipy benchmark

        # Initial condition
        T_initial = np.zeros((bs.xRes,bs.yRes)).flatten()

        # Forcing term function
        def forcing_term(T_flat):
            T = T_flat.reshape((bs.xRes, bs.yRes))
            forcing = bs.A * (bs.T0 - T) * np.exp(-((bs.x - bs.xmid) ** 2 + (bs.y - bs.ymid) ** 2) / (2 * bs.sigma ** 2))
            return forcing.flatten()

        # Function representing the discretized PDE
        def heat_equation(t,T_flat):
            T = T_flat.reshape((bs.xRes, bs.yRes))
            dTdx2 = np.roll(T, -1, axis=0) - 2 * T + np.roll(T, 1, axis=0)
            dTdx2 /= bs.dx ** 2
            dTdy2 = np.roll(T, -1, axis=1) - 2 * T + np.roll(T, 1, axis=1)
            dTdy2 /= bs.dy ** 2
            return dTdx2.flatten() + dTdy2.flatten() + forcing_term(T_flat)
        
        # Time span for the integration
        t_span = (0, end_time)

        # Solve the equation
        T_benchmark = sp.integrate.solve_ivp(heat_equation, t_span, T_initial, method='RK45')
        T_final_2D = T_benchmark.y[:, -1].reshape((bs.xRes, bs.yRes))

        # ComFiT simulation

        for method in ['ETD2RK','ETD4RK']:

            # Add linear and non-linear functions
            def calc_omega_f(bs):
                return -bs.calc_k2()

            def calc_nonlinear_evolution_function_f(bs,T,t):
                f = bs.A*(bs.T0-T)*np.exp(-((bs.x-bs.xmid)**2+(bs.y-bs.ymid)**2)/(2*bs.sigma**2))
                return sp.fft.fft2(f)
            
            # Add functions to BaseSystem object
            bs.calc_omega_f = calc_omega_f.__get__(bs)
            bs.calc_nonlinear_evolution_function_f = calc_nonlinear_evolution_function_f.__get__(bs)

            # Define evolve function
            def evolve(bs,number_of_steps, method = method):
                omega_f = bs.calc_omega_f()

                integrating_factors_f, solver = bs.calc_integrating_factors_f_and_solver(omega_f,method)

                for n in range(number_of_steps):
                    bs.T, bs.T_f = solver(integrating_factors_f,
                                            bs.calc_nonlinear_evolution_function_f,
                                            bs.T, bs.T_f)
                    bs.T = np.real(bs.T)
            
            # Add evolve function to BaseSystem object
            bs.evolve = evolve.__get__(bs)

            # Initial condition
            bs.T = np.zeros((bs.xRes,bs.yRes))
            bs.T_f = sp.fft.fft2(bs.T)

            # Evolve the system
            number_of_steps = int(end_time/bs.dt)
            bs.evolve(number_of_steps)

            # Check if the solution is close to the benchmark
            np.testing.assert_allclose(bs.T, T_final_2D, atol=1e-2, rtol=1e-2)

    def test_evolution_scheme_3d(self):
        """ Test 3D evolution scheme """

        # Testing the wave equation in three dimensions
        # Initialize BaseSystem object
        bs = cf.BaseSystem(3, xRes=21, dx=1, yRes=21, dy=1, zRes=21, dz=1)

        # Set test parameters
        bs.A = 0.1
        bs.sigma = 2
        bs.T0 = 20

        # Set end time
        end_time = 100

        # Scipy benchmark

        # Initial condition
        T_initial = np.zeros((bs.xRes,bs.yRes,bs.zRes)).flatten()

        # Forcing term function
        def forcing_term(T_flat):
            T = T_flat.reshape((bs.xRes, bs.yRes, bs.zRes))
            forcing = bs.A * (bs.T0 - T) * np.exp(-((bs.x - bs.xmid) ** 2 + (bs.y - bs.ymid) ** 2 + (bs.z - bs.zmid) ** 2) / (2 * bs.sigma ** 2))
            return forcing.flatten()
        
        # Function representing the discretized PDE
        def heat_equation(t,T_flat):
            T = T_flat.reshape((bs.xRes, bs.yRes, bs.zRes))
            dTdx2 = np.roll(T, -1, axis=0) - 2 * T + np.roll(T, 1, axis=0)
            dTdx2 /= bs.dx ** 2
            dTdy2 = np.roll(T, -1, axis=1) - 2 * T + np.roll(T, 1, axis=1)
            dTdy2 /= bs.dy ** 2
            dTdz2 = np.roll(T, -1, axis=2) - 2 * T + np.roll(T, 1, axis=2)
            dTdz2 /= bs.dz ** 2
            return dTdx2.flatten() + dTdy2.flatten() + dTdz2.flatten() + forcing_term(T_flat)
        
        # Time span for the integration
        t_span = (0, end_time)

        # Solve the equation
        T_benchmark = sp.integrate.solve_ivp(heat_equation, t_span, T_initial, method='RK45')
        T_final_3D = T_benchmark.y[:, -1].reshape((bs.xRes, bs.yRes, bs.zRes))

        # ComFiT simulation

        for method in ['ETD2RK','ETD4RK']:

            # Add linear and non-linear functions
            def calc_omega_f(bs):
                return -bs.calc_k2()

            def calc_nonlinear_evolution_function_f(bs,T,t):
                f = bs.A*(bs.T0-T)*np.exp(-((bs.x-bs.xmid)**2+(bs.y-bs.ymid)**2+(bs.z-bs.zmid)**2)/(2*bs.sigma**2))
                return sp.fft.fftn(f)
            
            # Add functions to BaseSystem object
            bs.calc_omega_f = calc_omega_f.__get__(bs)
            bs.calc_nonlinear_evolution_function_f = calc_nonlinear_evolution_function_f.__get__(bs)

            # Define evolve function
            def evolve(bs,number_of_steps, method = 'ETD2RK'):
                omega_f = bs.calc_omega_f()

                integrating_factors_f, solver = bs.calc_integrating_factors_f_and_solver(omega_f,method)

                for n in range(number_of_steps):
                    bs.T, bs.T_f = solver(integrating_factors_f,
                                            bs.calc_nonlinear_evolution_function_f,
                                            bs.T, bs.T_f)
                    bs.T = np.real(bs.T)

            # Add evolve function to BaseSystem object
            bs.evolve = evolve.__get__(bs)

            # Initial condition
            bs.T = np.zeros((bs.xRes,bs.yRes,bs.zRes))
            bs.T_f = sp.fft.fftn(bs.T)

            # Evolve the system
            number_of_steps = int(end_time/bs.dt)
            bs.evolve(number_of_steps)

            # Check if the solution is close to the benchmark
            np.testing.assert_allclose(bs.T, T_final_3D, atol=1e-2, rtol=1e-2)

if __name__ == '__main__':
    unittest.main()

    # unittest.main(defaultTest='TestBaseSystem.test_plot_field_with_different_parameters', verbosity=2)

--- End of file: tests\tests_core\test_base_system.py ---

--- Start of file: tests\tests_nematic_liquid_crystal\test_nematic_liquid_crystal.py ---
import unittest
import sys
import os

# Run 
# Adjust the path to import the comfit package
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../../')))
import comfit as cf
import numpy as np
import matplotlib.pyplot as plt

class TestNematicLiquidCrystal(unittest.TestCase):

    def test_init_with_dimension(self):
        """Test NematicLiquidCrystal initialization with a dimension parameter."""
        for dim in [1, 2, 3]:
            try:
                nlc = cf.NematicLiquidCrystal(dim)
                self.assertIsInstance(nlc, cf.NematicLiquidCrystal)
            except Exception as e:
                self.fail(f"Initialization failed with dimension {dim}: {e}")

    def test_no_flow_evolver(self):
        """Test the enm.evolve_nematic_no_flow"""
        nem = cf.NematicLiquidCrystal(2, xRes=13, yRes=4)
        np.random.seed(29618953)
        nem.conf_initial_condition_ordered(noise_strength=2)
        nem.evolve_nematic_no_flow(500)

        # Set the tolerance for approximation
        tolerance = 0.01

        # Check if nem.Q have approacjed the expected=
        S_0 = np.sqrt(nem.B)
        S,n = nem.calc_order_and_director()
        condition = np.allclose(S_0,S , atol=tolerance)
        self.assertTrue(condition, "Elements in nem.Q are not relaxed to the correct value")

    def test_no_flow_evolver_3D(self):
        for i in range(10):
            c = 2*np.random.rand()
            nem = cf.NematicLiquidCrystal(3, xRes=13, yRes=4,zRes=13,C = c)
            np.random.seed(29820894)
            nem.conf_initial_condition_ordered(noise_strength=2)

            nem.evolve_nematic_no_flow(300)


            # Set the tolerance for approximation
            tolerance = 0.01

            # Check if all elements in  are approximately 1
            S_0 =1/8* nem.C/nem.A + 1/2 * np.sqrt(nem.C**2 /(16*nem.A**2) + 3*nem.B)

            S, n = nem.calc_order_and_director()
            condition = np.allclose(S_0, S, atol=tolerance)
            self.assertTrue(condition, "Elements in nem.Q are not relaxed to the correct value")



    def test_nematic_evolver_with_defect_dipole(self):
        """Test the enm.evolve_nematic_no_flow"""
        nem = cf.NematicLiquidCrystal(2, xRes=31, yRes=31)
        nem.conf_insert_disclination_dipole(dipole_vector=[nem.xmax/3,0],
            dipole_position=nem.rmid)
        nem.evolve_nematic_no_flow(10)
        nem.evolve_nematic(1)
        Dnodes = nem.calc_disclination_nodes_nem()

        self.assertEqual(len(Dnodes), 2, "Dipole nodes not found")

        # Create lists of the x and y positions of the nodes
        xpos = [node['position'][0] for node in Dnodes]
        ypos = [node['position'][1] for node in Dnodes]

        # Sort the lists according to xpos
        sorted_lists = sorted(zip(xpos, ypos))

        # Unzip the sorted lists
        xpos, ypos = zip(*sorted_lists)

        # Testing the position of the first node
        self.assertAlmostEqual(xpos[0], nem.xmax / 3, delta=1)
        self.assertAlmostEqual(ypos[0], nem.ymax / 2, delta=1)

        # Testing the position of the second node
        self.assertAlmostEqual(xpos[1], 2 * nem.xmax / 3, delta=1)
        self.assertAlmostEqual(ypos[1], nem.ymax / 2, delta=1)




if __name__ == '__main__':
    unittest.main()

--- End of file: tests\tests_nematic_liquid_crystal\test_nematic_liquid_crystal.py ---

--- Start of file: tests\tests_nematic_liquid_crystal\__init__.py ---

--- End of file: tests\tests_nematic_liquid_crystal\__init__.py ---

--- Start of file: tests\tests_phase_field_crystal\test_phase_field_crystal.py ---
import unittest
import sys
import os

# Run 
# Adjust the path to import the comfit package
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../../')))
import comfit as cf
import matplotlib.pyplot as plt
import numpy as np


class TestPhaseFieldCrystal(unittest.TestCase):

    def test_phase_field_crystal_2d_triangular_init(self):
        """Test PhaseFieldCrystal2DTriangular initialization with nx=ny=1."""
        try:
            pfc1d = cf.PhaseFieldCrystal2DTriangular(1, 1)
            self.assertIsInstance(pfc1d, cf.PhaseFieldCrystal2DTriangular)
        except Exception as e:
            self.fail(f"Initialization of PhaseFieldCrystal1DPeriodic failed: {e}")

    def test_phase_field_crystal_2d_triangular_init_with_params(self):
        """Test PhaseFieldCrystal2DTriangular initialization with different parameters."""
        params = [
            {'nx': 11, 'ny': 14, 'dt': 0.1},
            {'nx': 32, 'ny': 32, 'dt': 0.3},
            # Add more parameter combinations as needed
        ]
        for p in params:
            with self.subTest(p=p):
                try:
                    pfc = cf.PhaseFieldCrystal2DTriangular(**p)
                    self.assertIsInstance(pfc, cf.PhaseFieldCrystal2DTriangular)
                except Exception as e:
                    self.fail(f"Initialization failed with parameters {p}: {e}")

    # Add similar test methods for other subclasses like PhaseFieldCrystal2DTriangular, etc.

    ## 2D triangular tests

    def test_phase_field_crystal_2d_triangular_evolve_PFC_with_dislocation_dipole(self):
        """Test PhaseFieldCrystal2DTriangular calc_amplitudes_with_dislocation_dipole."""
        pfc = cf.PhaseFieldCrystal2DTriangular(21, 14)
        eta = pfc.calc_amplitudes_with_dislocation_dipole()
        pfc.conf_PFC_from_amplitudes(eta)
        pfc.evolve_PFC(200)

        # Check if pfc.psi is real-valued
        self.assertTrue(np.isrealobj(pfc.psi), "pfc.psi contains complex values.")

        # Check if pfc.psi does not contain NaN values
        self.assertFalse(np.any(np.isnan(pfc.psi)), "pfc.psi contains NaN values.")

    def test_phase_field_crystal_2d_triangular_initial_amplitudes(self):

        params = [
            {'nx': 1, 'ny': 1, 'r': -0.1, 't': 0, 'v': 1, 'psi0': -0.1},
            {'nx': 1, 'ny': 1, 'r': -0.2, 't': 0, 'v': 1, 'psi0': -0.2},
            {'nx': 1, 'ny': 1, 'r': -0.3, 't': 0, 'v': 1, 'psi0': -0.3},
            # Add more parameter combinations as needed
        ]

        # The following values were calculated using the legacy PFC matlab code from Vidars PhD
        As = [0.091180521680209,
              0.123266639978645,
              0.134833147735479]

        for p, A in zip(params, As):
            with self.subTest(p=p):
                try:
                    pfc = cf.PhaseFieldCrystal2DTriangular(**p)
                    pfc.conf_PFC_from_amplitudes()
                    self.assertAlmostEqual(pfc.A_proto, A, places=5)
                except Exception as e:
                    self.fail(f"PFC Triangular amplitude calculation failed with {p}: {e}")

    def test_phase_field_crystal_2d_triangular_identify_dislocations(self):
        
        # Positions of the dislocations

        for dislocation_type in [1,2,3]:
            try:
                # Initialize PFC
                pfc = cf.PhaseFieldCrystal2DTriangular(21, 14)
                x1=pfc.xmax/3 
                y1=pfc.ymax/2
                x2=2*pfc.xmax/3
                y2=pfc.ymax/2

                eta = pfc.calc_amplitudes_with_dislocation_dipole(
                    dislocation_type=1,
                    x1=x1, y1=y1,
                    x2=x2, y2=y2)
                pfc.conf_PFC_from_amplitudes(eta)
                pfc.evolve_PFC(100)
                dislocation_nodes = pfc.calc_dislocation_nodes()

                # Check if there are two dislocations
                self.assertEqual(len(dislocation_nodes),2)
                
                # Check if the dislocations are correct
                for dislocation in dislocation_nodes:
                    self.assertEqual(np.linalg.norm(dislocation['Burgers_vector']), pfc.a0)
                    if (dislocation['Burgers_vector'] == -pfc.a[dislocation_type-1]).all():
                        self.assertAlmostEqual(dislocation['position'][0],x1,delta=pfc.a0)
                        self.assertAlmostEqual(dislocation['position'][1],y1,delta=pfc.a0)

                    elif (dislocation['Burgers_vector'] == pfc.a[dislocation_type-1]).all():
                        self.assertAlmostEqual(dislocation['position'][0],x2,delta=pfc.a0)
                        self.assertAlmostEqual(dislocation['position'][1],y2,delta=pfc.a0)

            except Exception as e:
                self.fail(f"PFC Triangular dislocation identification failed with dislocation type {dislocation_type}: {e}")

    def test_phase_field_crystal_2d_triangular_mech_eq_dislocation_annihilation(self):
        pfc = cf.PhaseFieldCrystal2DTriangular(31, 16)
        x1=pfc.xmax/3 
        y1=pfc.ymax/2
        x2=2*pfc.xmax/3
        y2=pfc.ymax/2

        eta = pfc.calc_amplitudes_with_dislocation_dipole(
            dislocation_type=1,
            x1=x1, y1=y1,
            x2=x2, y2=y2)
        pfc.conf_PFC_from_amplitudes(eta)
        pfc.evolve_PFC(100)

        # Check if there are two dislocations
        dislocation_nodes = pfc.calc_dislocation_nodes()
        self.assertEqual(len(dislocation_nodes),2)

        pfc.evolve_PFC_mechanical_equilibrium(350,Delta_t=1)

        # Check that the dislocations have annihilated
        dislocation_nodes = pfc.calc_dislocation_nodes()
        self.assertEqual(len(dislocation_nodes),0)

    ## 2D square tests

    def test_phase_field_crystal_2d_square_initial_amplitudes(self):

        params = [
            {'nx': 1, 'ny': 1, 'r': -0.1, 't': 0, 'v': 1, 'psi0': -0.1},
            {'nx': 1, 'ny': 1, 'r': -0.2, 't': 0, 'v': 1, 'psi0': -0.2},
            {'nx': 1, 'ny': 1, 'r': -0.3, 't': 0, 'v': 1, 'psi0': -0.3},
            # Add more parameter combinations as needed
        ]

        #The following values were calculated using the legacy PFC matlab code from Vidars PhD
        As = [0.098138558341561,
              0.132946527647919,
              0.152161548344077]

        Bs = [0.046917143364986,
              0.073844303366386,
              0.090505473985471]

        for p, A, B in zip(params, As, Bs):
            with self.subTest(p=p):
                try:
                    pfc = cf.PhaseFieldCrystal2DSquare(**p)
                    pfc.conf_PFC_from_amplitudes()
                    self.assertAlmostEqual(pfc.A_proto, A, places=5)
                    self.assertAlmostEqual(pfc.B_proto, B, places=5)
                except Exception as e:
                    self.fail(f"PFC Square amplitude calculation failed with {p}: {e}")

    def test_phase_field_crystal_2d_square_identify_dislocations(self):
        
        # Positions of the dislocations

        for dislocation_type in [1,2]:
            try:
                # Initialize PFC
                pfc = cf.PhaseFieldCrystal2DSquare(21, 21)
                x1=pfc.xmax/3 
                y1=pfc.ymax/2
                x2=2*pfc.xmax/3
                y2=pfc.ymax/2

                eta = pfc.calc_amplitudes_with_dislocation_dipole(
                    dislocation_type=1,
                    x1=x1, y1=y1,
                    x2=x2, y2=y2)
                pfc.conf_PFC_from_amplitudes(eta)
                pfc.evolve_PFC(100)
                dislocation_nodes = pfc.calc_dislocation_nodes()

                # Check if there are two dislocations
                self.assertEqual(len(dislocation_nodes),2)
                
                # Check if the dislocations are correct
                for dislocation in dislocation_nodes:
                    self.assertEqual(np.linalg.norm(dislocation['Burgers_vector']), pfc.a0)
                    if (dislocation['Burgers_vector'] == -pfc.a[dislocation_type-1]).all():
                        self.assertAlmostEqual(dislocation['position'][0],x1,delta=pfc.a0)
                        self.assertAlmostEqual(dislocation['position'][1],y1,delta=pfc.a0)

                    elif (dislocation['Burgers_vector'] == pfc.a[dislocation_type-1]).all():
                        self.assertAlmostEqual(dislocation['position'][0],x2,delta=pfc.a0)
                        self.assertAlmostEqual(dislocation['position'][1],y2,delta=pfc.a0)

            except Exception as e:
                self.fail(f"PFC Square dislocation identification failed with dislocation type {dislocation_type}: {e}")


    def test_phase_field_crystal_3d_body_centered_cubic_initial_amplitudes(self):

        params = [
            {'nx': 1, 'ny': 1, 'nz': 1, 'r': -0.1, 't': 0, 'v': 1, 'psi0': -0.125},
            {'nx': 1, 'ny': 1, 'nz': 1, 'r': -0.2, 't': 0, 'v': 1, 'psi0': -0.225},
            {'nx': 1, 'ny': 1, 'nz': 1, 'r': -0.3, 't': 0, 'v': 1, 'psi0': -0.325},
            # Add more parameter combinations as needed
        ]

        # The following values were calculated using the legacy PFC matlab code from Vidars PhD
        As = [0.054854797457965,
              0.074378423185648,
              0.082099011165377]

        for p, A in zip(params, As):
            with self.subTest(p=p):
                try:
                    pfc = cf.PhaseFieldCrystal3DBodyCenteredCubic(**p)
                    pfc.conf_PFC_from_amplitudes()
                    self.assertAlmostEqual(pfc.A_proto, A, places=5)
                except Exception as e:
                    self.fail(f"PFC BCC amplitude calculation failed with {p}: {e}")


    def test_phase_field_crystal_3d_face_centered_cubic_initial_amplitudes(self):

        params = [
            {'nx': 1, 'ny': 1, 'nz': 1, 'r': -0.1, 't': 0, 'v': 1, 'psi0': -0.125},
            {'nx': 1, 'ny': 1, 'nz': 1, 'r': -0.2, 't': 0, 'v': 1, 'psi0': -0.225},
            {'nx': 1, 'ny': 1, 'nz': 1, 'r': -0.3, 't': 0, 'v': 1, 'psi0': -0.325},
            # Add more parameter combinations as needed
        ]

        # The following values were calculated using the legacy PFC matlab code from Vidars PhD
        As = [0.056481938628754,
              0.077467125827116,
              0.088828545091084]

        Bs = [0.038972621699196,
              0.056347683829042,
              0.066589290566421]

        for p, A, B in zip(params, As, Bs):
            with self.subTest(p=p):
                try:
                    pfc = cf.PhaseFieldCrystal3DFaceCenteredCubic(**p)
                    pfc.conf_PFC_from_amplitudes()
                    self.assertAlmostEqual(pfc.A_proto, A, places=5)
                    self.assertAlmostEqual(pfc.B_proto, B, places=5)
                except Exception as e:
                    self.fail(f"PFC FCC amplitude calculation failed with {p}: {e}")

    def test_phase_field_crystal_3d_body_centered_cubic_identify_dislocations(self):
        # Set the plane equation
        a = 0.3
        b = 0.7
        c = 0.1
        
        for dislocation_type in range(1,5):
            try:
                pfc = cf.PhaseFieldCrystal3DBodyCenteredCubic(nx=13, ny=13, nz=13)
                # Insert a dislocation ring
                eta = pfc.calc_amplitudes_with_dislocation_ring(
                    normal_vector=[a,b,c],
                    position=pfc.rmid,
                    radius=pfc.xmax/3,
                    dislocation_type=dislocation_type
                )
                pfc.conf_PFC_from_amplitudes(eta)

                # Relax the system
                pfc.evolve_PFC(20)
                dislocation_nodes = pfc.calc_dislocation_nodes()
                
                #Check that there are nodes
                self.assertGreater(len(dislocation_nodes),0,"Dislocation nodes not found")

                #Check that all the nodes belong to the correct plane
                for dislocation_node in dislocation_nodes:
                    # Calculate the plane equation
                    plane_equation = a*(dislocation_node['position'][0]-pfc.rmid[0]) \
                                    + b*(dislocation_node['position'][1]-pfc.rmid[1]) \
                                    + c*(dislocation_node['position'][2]-pfc.rmid[2])

                    # Check if the plane equation is zero
                    self.assertAlmostEqual(plane_equation,0,delta=0.5*pfc.a0)
                    
                    # Check that the Burgers vector is correct
                    print(dislocation_node['Burgers_vector'])
                    print(pfc.a[dislocation_type-1])
                    self.assertTrue((dislocation_node['Burgers_vector'] == pfc.a[dislocation_type-1]).all())

            except Exception as e:
                self.fail(f"PFC BCC dislocation identification failed with dislocation type {dislocation_type}: {e}")
    
    def test_phase_field_crystal_3d_face_centered_cubic_identify_dislocations(self):
        # Set the plane equation
        a = 0.1
        b = 0.5
        c = 0.3
        
        for dislocation_type in range(1,7):
            try:
                pfc = cf.PhaseFieldCrystal3DFaceCenteredCubic(nx=13, ny=13, nz=13)
                # Insert a dislocation ring
                eta = pfc.calc_amplitudes_with_dislocation_ring(
                    normal_vector=[a,b,c],
                    position=pfc.rmid,
                    radius=pfc.xmax/3,
                    dislocation_type=dislocation_type
                )
                pfc.conf_PFC_from_amplitudes(eta)

                # Relax the system
                pfc.evolve_PFC(20)
                dislocation_nodes = pfc.calc_dislocation_nodes()
                
                #Check that there are nodes
                self.assertGreater(len(dislocation_nodes),0,"Dislocation nodes not found")

                #Check that all the nodes belong to the correct plane
                for dislocation_node in dislocation_nodes:
                    # Calculate the plane equation
                    plane_equation = a*(dislocation_node['position'][0]-pfc.rmid[0]) \
                                    + b*(dislocation_node['position'][1]-pfc.rmid[1]) \
                                    + c*(dislocation_node['position'][2]-pfc.rmid[2])

                    # Check if the plane equation is zero
                    self.assertAlmostEqual(plane_equation,0,delta=0.5*pfc.a0)
                    
                    # Check that the Burgers vector is correct
                    self.assertTrue((dislocation_node['Burgers_vector'] == pfc.a[dislocation_type-1]).all())

            except Exception as e:
                self.fail(f"PFC FCC dislocation identification failed with dislocation type {dislocation_type}: {e}")

    def test_phase_field_crystal_3d_simple_cubic_initial_amplitudes(self):

        params = [
            {'nx': 1, 'ny': 1, 'nz': 1, 'r': -0.1, 't': 0, 'v': 1, 'psi0': -0.125},
            {'nx': 1, 'ny': 1, 'nz': 1, 'r': -0.2, 't': 0, 'v': 1, 'psi0': -0.225},
            {'nx': 1, 'ny': 1, 'nz': 1, 'r': -0.3, 't': 0, 'v': 1, 'psi0': -0.325},
            # Add more parameter combinations as needed
        ]

        # The following values were calculated using the legacy PFC matlab code from Vidars PhD
        As = [0.072799451159192,
              0.082792401061476,
              0.090170308517259]

        Bs = [0.020831100850532,
              0.037148906733000,
              0.047858014941568]

        Cs = [-0.004840409953021,
              0.011422779247214,
              0.022268287314380]

        for p, A, B, C in zip(params, As, Bs, Cs):
            with self.subTest(p=p):
                try:
                    pfc = cf.PhaseFieldCrystal3DSimpleCubic(**p)
                    pfc.conf_PFC_from_amplitudes()
                    self.assertAlmostEqual(pfc.A_proto, A, places=5)
                    self.assertAlmostEqual(pfc.B_proto, B, places=5)
                    self.assertAlmostEqual(pfc.C_proto, C, places=5)
                except Exception as e:
                    self.fail(f"PFC Simple Cubic amplitude calculation failed with {p}: {e}")

    def test_phase_field_crystal_3d_simple_cubic_identify_dislocations(self):
        # Set the plane equation
        a = 0.8
        b = 0.3
        c = 0.1
        
        for dislocation_type in range(1,4):
            try:
                pfc = cf.PhaseFieldCrystal3DSimpleCubic(nx=17, ny=17, nz=17)
                # Insert a dislocation ring
                eta = pfc.calc_amplitudes_with_dislocation_ring(
                    normal_vector=[a,b,c],
                    position=pfc.rmid,
                    radius=pfc.xmax/3,
                    dislocation_type=dislocation_type
                )
                pfc.conf_PFC_from_amplitudes(eta)

                # Relax the system
                pfc.evolve_PFC(20)
                dislocation_nodes = pfc.calc_dislocation_nodes()
                
                #Check that there are nodes
                self.assertGreater(len(dislocation_nodes),0,"Dislocation nodes not found")

                #Check that all the nodes belong to the correct plane
                for dislocation_node in dislocation_nodes:
                    # Calculate the plane equation
                    plane_equation = a*(dislocation_node['position'][0]-pfc.rmid[0]) \
                                    + b*(dislocation_node['position'][1]-pfc.rmid[1]) \
                                    + c*(dislocation_node['position'][2]-pfc.rmid[2])

                    # Check if the plane equation is zero
                    self.assertAlmostEqual(plane_equation,0,delta=0.5*pfc.a0)
                    
                    # Check that the Burgers vector is correct
                    self.assertTrue((dislocation_node['Burgers_vector'] == pfc.a[dislocation_type-1]).all())

            except Exception as e:
                self.fail(f"PFC FCC dislocation identification failed with dislocation type {dislocation_type}: {e}")


if __name__ == '__main__':
    unittest.main()
    

--- End of file: tests\tests_phase_field_crystal\test_phase_field_crystal.py ---

--- Start of file: tests\tests_phase_field_crystal\__init__.py ---

--- End of file: tests\tests_phase_field_crystal\__init__.py ---

--- Start of file: tests\tests_plot\test_animation.py ---
import unittest
import sys
import os

# Run 
# Adjust the path to import the comfit package
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../../')))
import comfit as cf
import numpy as np
import scipy as sp

class TestAnimation(unittest.TestCase):

    def tearDown(self):
        import matplotlib.pyplot as plt
        plt.close('all')

    def test_save_plotly(self):
        bs = cf.BaseSystem(dim=1, xmin=0, xmax=10, xRes=100, plot_lib='plotly')

        fig, ax = bs.plot_field(np.sin(bs.x))
        
        try:
            bs.plot_save(fig)
        except:
            self.fail('plot_save_plotly raised an exception.')
        
    def test_save_matplotlib(self):
        bs = cf.BaseSystem(dim=1, xmin=0, xmax=10, xRes=100, plot_lib='matplotlib')

        fig, ax = bs.plot_field(np.sin(bs.x))
        
        try:
            bs.plot_save(fig)
        except:
            self.fail('plot_save_matplotlib raised an exception.')


    def test_animation_simple_plotly(self):
        
        bs = cf.BaseSystem(dim=1, xmin=0, xmax=10, xRes=100, plot_lib='plotly')
        
        for n in range(20):
            fig, ax = bs.plot_field(np.sin(bs.x-n/20))
            bs.plot_save(fig, n)
        
        try:
            cf.tool_make_animation_movie(n, delete_png=False)
        except:
            self.fail('tool_make_animation_movie_plotly raised an exception.')

        try:
            cf.tool_make_animation_gif(n, delete_png=True)
        except:
            self.fail('tool_make_animation_gif_plotly raised an exception.')

    
    def test_animation_simple_matplotlib(self):
        
        bs = cf.BaseSystem(dim=1, xmin=0, xmax=10, xRes=100, plot_lib='matplotlib')
        
        for n in range(20):
            fig, ax = bs.plot_field(np.sin(bs.x-n/20))
            bs.plot_save(fig, n)
        
        try:
            cf.tool_make_animation_movie(n, delete_png=False)
        except:
            self.fail('tool_make_animation_movie_matplotlib raised an exception.')

        try:
            cf.tool_make_animation_gif(n, delete_png=True)
        except:
            self.fail('tool_make_animation_gif_matplotlib raised an exception.')
    

    def test_animation_with_ID_plotly(self):

        bs = cf.BaseSystem(dim=1, xmin=0, xmax=10, xRes=100)

        for n in range(20):
            fig, ax = bs.plot_field(np.sin(bs.x-n/20))
            bs.plot_save(fig, n, ID='test')
        
        try:
            cf.tool_make_animation_movie(n, ID='test', delete_png=False)
        except:
            self.fail('test_animation_with_ID_plotly raised an exception.')

        try:
            cf.tool_make_animation_gif(n, ID='test', delete_png=True)
        except:
            self.fail('test_animation_with_ID_plotly raised an exception.')
        
    def test_animation_with_ID_matplotlib(self):

        bs = cf.BaseSystem(dim=1, xmin=0, xmax=10, xRes=100, plot_lib='matplotlib')

        for n in range(20):
            fig, ax = bs.plot_field(np.sin(bs.x-n/20))
            bs.plot_save(fig, n, ID='test')

        try:
            cf.tool_make_animation_movie(n, ID='test', delete_png=False)
        
        except:
            self.fail('test_animation_with_ID_matplotlib raised an exception.')




if __name__ == '__main__':
    unittest.main()
--- End of file: tests\tests_plot\test_animation.py ---

--- Start of file: tests\tests_plot\test_fourier_plots.py ---
import unittest
import sys
import os

# Run 
# Adjust the path to import the comfit package
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../../')))
import comfit as cf
import numpy as np
import scipy as sp

show_plots = False

class TestFourierPlots(unittest.TestCase):

    def tearDown(self):
        import matplotlib.pyplot as plt
        plt.close('all')
        
    def test_1D_real_field(self):
        for plot_lib in ['plotly', 'matplotlib']:
            # Initialize BaseSystem object
            bs = cf.BaseSystem(1, plot_lib=plot_lib, xlim=[-10,10])
            # Create field
            field = bs.x/200
            fig, ax = bs.plot_field(field, fourier=True)
            if show_plots:
                bs.show(fig)
            self.assertIsNotNone(fig, msg=f'plot_field with fourier in 1D failed for plot_lib={plot_lib}')
    
    def test_2D_real_field(self):
        for plot_lib in ['plotly', 'matplotlib']:
            # Initialize BaseSystem object
            bs = cf.BaseSystem(2, plot_lib=plot_lib, xlim=[-10,10], ylim=[-10,10])
            # Create field
            field = (bs.x+bs.y)
            fig, ax = bs.plot_field(field, fourier=True)
            if show_plots:
                bs.show(fig)
            self.assertIsNotNone(fig, msg=f'plot_field with fourier in 2D failed for plot_lib={plot_lib}')
    
    def test_3D_real_field(self):
        for plot_lib in ['plotly', 'matplotlib']:
            # Initialize BaseSystem object
            bs = cf.BaseSystem(3, plot_lib=plot_lib, xlim=[-10,10], ylim=[-10,10], zlim=[-10,10])
            # Create field
            field = (bs.x+bs.y+bs.z)
            fig, ax = bs.plot_field(field, fourier=True)
            if show_plots:
                bs.show(fig)
            self.assertIsNotNone(fig, msg=f'plot_field with fourier in 3D failed for plot_lib={plot_lib}')
    
    def test_1D_complex_field(self):
        for plot_lib in ['plotly', 'matplotlib']:
            # Initialize BaseSystem object
            bs = cf.BaseSystem(1, plot_lib=plot_lib, xlim=[-10,10])
            # Create complex field
            field = bs.x*np.exp(1j * bs.x / 5)
            fig, ax = bs.plot_complex_field(field, fourier=True)
            if show_plots:
                bs.show(fig)
            self.assertIsNotNone(fig, msg=f'plot_complex_field with fourier for complex field in 1D failed for plot_lib={plot_lib}')

    def test_2D_complex_field(self):
        for plot_lib in ['plotly', 'matplotlib']:
            # Initialize BaseSystem object
            bs = cf.BaseSystem(2, plot_lib=plot_lib, xlim=[-10,10], ylim=[-10,10])
            # Create complex field
            field = (1 + 0.5*np.sin(bs.x/5)) * np.exp(1j * (bs.x**2 + bs.y**2) / 50)
            fig, ax = bs.plot_complex_field(field, fourier=True)
            if show_plots:
                bs.show(fig)
            self.assertIsNotNone(fig, msg=f'plot_complex_field with fourier for complex field in 2D failed for plot_lib={plot_lib}')

    def test_3D_complex_field(self):
        for plot_lib in ['plotly', 'matplotlib']:
            # Initialize BaseSystem object
            bs = cf.BaseSystem(3, plot_lib=plot_lib, xlim=[-10,10], ylim=[-10,10], zlim=[-10,10])
            # Create complex field
            # Create complex field with amplitude modulation
            field = (bs.x+1j*bs.y+1j*bs.z)/200
            fig, ax = bs.plot_complex_field(field, fourier=True)
            if show_plots:
                bs.show(fig)
            self.assertIsNotNone(fig, msg=f'plot_complex_field with fourier for complex field in 3D failed for plot_lib={plot_lib}')


if __name__ == '__main__':
    unittest.main()
--- End of file: tests\tests_plot\test_fourier_plots.py ---

--- Start of file: tests\tests_plot\test_plot_angle_field.py ---
import unittest
import sys
import os

# Run 
# Adjust the path to import the comfit package
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../../')))
import comfit as cf
import numpy as np
import scipy as sp

show_plots = False

class TestPlotAngleField(unittest.TestCase):

  def tearDown(self):
      import matplotlib.pyplot as plt
      plt.close('all')
      
  def test_1D(self):
    for plot_lib in ['plotly', 'matplotlib']:
      # Initialize BaseSystem object
      bs = cf.BaseSystem(1, plot_lib=plot_lib, xlim=[-10,10])
      # Create field
      field = bs.x/200
      fig, ax = bs.plot_angle_field(field)
      if show_plots:
        bs.show(fig)
      self.assertIsNotNone(fig, msg=f'plot_angle_field in 1D failed for plot_lib={plot_lib}')

  def test_2D(self):
    for plot_lib in ['plotly', 'matplotlib']:
      # Initialize BaseSystem object
      bs = cf.BaseSystem(2, plot_lib=plot_lib, xlim=[-10,10], ylim=[-10,10])
      # Create field
      field = (bs.x+bs.y)
      fig, ax = bs.plot_angle_field(field)
      if show_plots:
        bs.show(fig)
      self.assertIsNotNone(fig, msg=f'plot_angle_field in 2D failed for plot_lib={plot_lib}')

  def test_3D(self):
    for plot_lib in ['plotly', 'matplotlib']:
      # Initialize BaseSystem object
      bs = cf.BaseSystem(3, plot_lib=plot_lib, xlim=[-10,10], ylim=[-10,10], zlim=[-10,10])
      # Create field
      field = (bs.x+bs.y+bs.z)
      fig, ax = bs.plot_angle_field(field)
      if show_plots:
        bs.show(fig)
      self.assertIsNotNone(fig, msg=f'plot_angle_field in 3D failed for plot_lib={plot_lib}')

  def test_colorbar_1D(self):
    for plot_lib in ['plotly', 'matplotlib']:
      # Initialize BaseSystem object
      bs = cf.BaseSystem(1, plot_lib=plot_lib, xlim=[-10,10])
      colormap = 'sunburst'
      # Create field
      field = bs.x
      fig, ax = bs.plot_angle_field(field, colorbar=True, colormap=colormap)
      if show_plots:
        bs.show(fig)
      self.assertIsNotNone(fig, msg=f'plot_angle_field in 1D with custom colorbar failed for plot_lib={plot_lib}')

  def test_colorbar_2D(self):
    for plot_lib in ['plotly', 'matplotlib']:
      # Initialize BaseSystem object
      bs = cf.BaseSystem(2, plot_lib=plot_lib, xlim=[-10,10], ylim=[-10,10])
      colormap = 'sunburst'
      # Create field
      field = (bs.x+bs.y)
      fig, ax = bs.plot_angle_field(field, colorbar=True, colormap=colormap)
      if show_plots:
        bs.show(fig)
      self.assertIsNotNone(fig, msg=f'plot_angle_field in 2D with custom colorbar failed for plot_lib={plot_lib}')

  def test_colorbar_3D(self):
    for plot_lib in ['plotly', 'matplotlib']:
      # Initialize BaseSystem object
      bs = cf.BaseSystem(3, plot_lib=plot_lib, xlim=[-10,10], ylim=[-10,10], zlim=[-10,10])
      colormap = 'sunburst'
      # Create field
      field = (bs.x+bs.y+bs.z)
      fig, ax = bs.plot_angle_field(field, colorbar=True, colormap=colormap)
      if show_plots:
        bs.show(fig)
      self.assertIsNotNone(fig, msg=f'plot_angle_field in 3D with custom colorbar failed for plot_lib={plot_lib}')

if __name__ == '__main__':
  unittest.main()
--- End of file: tests\tests_plot\test_plot_angle_field.py ---

--- Start of file: tests\tests_plot\test_plot_angle_field_in_plane.py ---
import unittest
import sys
import os

# Run 
# Adjust the path to import the comfit package
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../../')))
import comfit as cf
import numpy as np
import scipy as sp


class TestPlotAngleField(unittest.TestCase):

  def tearDown(self):
      import matplotlib.pyplot as plt
      plt.close('all')

  def test_3D(self):
    for plot_lib in ['plotly', 'matplotlib']:
      # Initialize BaseSystem object
      bs = cf.BaseSystem(3, plot_lib=plot_lib, xlim=[-10,10], ylim=[-10,10], zlim=[-10,10])
      # Create field
      field = (bs.x+bs.y+bs.z)
      fig, ax = bs.plot_angle_field_in_plane(field)
      # bs.show(fig)
      self.assertIsNotNone(fig, msg=f'plot_angle_field_in_plane in 3D failed for plot_lib={plot_lib}')

  def test_colorbar_3D(self):
    for plot_lib in ['plotly', 'matplotlib']:
      # Initialize BaseSystem object
      bs = cf.BaseSystem(3, plot_lib=plot_lib, xlim=[-10,10], ylim=[-10,10], zlim=[-10,10])
      colormap = 'sunburst'
      # Create field
      field = (bs.x+bs.y+bs.z)
      fig, ax = bs.plot_angle_field_in_plane(field, colorbar=True, colormap=colormap)
      # bs.show(fig)
      self.assertIsNotNone(fig, msg=f'plot_angle_field_in_plane in 3D with custom colorbar failed for plot_lib={plot_lib}')

if __name__ == '__main__':
  unittest.main()
--- End of file: tests\tests_plot\test_plot_angle_field_in_plane.py ---

--- Start of file: tests\tests_plot\test_plot_complex_field.py ---
import unittest
import sys
import os

# Run 
# Adjust the path to import the comfit package
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../../')))
import comfit as cf
import numpy as np
import scipy as sp

show_plots = False

class TestPlotComplexField(unittest.TestCase):

    def tearDown(self):
        import matplotlib.pyplot as plt
        plt.close('all')

    def test_1D(self):
        for plot_lib in ['plotly', 'matplotlib']:
            # Initialize BaseSystem object
            bs = cf.BaseSystem(1, plot_lib=plot_lib, xlim=[-10,10])
            # Create field
            field = (bs.x+1j*bs.x)/200
            fig, ax = bs.plot_complex_field(field, colorbar=True)
            if show_plots:
                bs.show(fig)
            self.assertIsNotNone(fig, msg=f'plot_complex_field in 1D failed for plot_lib={plot_lib}')

    def test_2D(self):
        for plot_lib in ['plotly', 'matplotlib']:
            # Initialize BaseSystem object
            bs = cf.BaseSystem(2, plot_lib=plot_lib, xlim=[-10,10], ylim=[-10,10])
            # Create field
            field = (bs.x+1j*bs.y)/200
            fig, ax = bs.plot_complex_field(field, colorbar=True)
            if show_plots:
                bs.show(fig)
            self.assertIsNotNone(fig, msg=f'plot_complex_field in 2D failed for plot_lib={plot_lib}')

    def test_3D(self):
        for plot_lib in ['plotly', 'matplotlib']:
            # Initialize BaseSystem object
            bs = cf.BaseSystem(3, plot_lib=plot_lib, xlim=[-10,10], ylim=[-10,10], zlim=[-10,10])
            # Create field
            field = (bs.x+1j*bs.y+1j*bs.z)/200
            fig, ax = bs.plot_complex_field(field, colorbar=True)
            if show_plots:
                bs.show(fig)
            self.assertIsNotNone(fig, msg=f'plot_complex_field in 3D failed for plot_lib={plot_lib}')

    def test_colorbar_1D(self):
        for plot_lib in ['plotly', 'matplotlib']:
            # Initialize BaseSystem object
            bs = cf.BaseSystem(1, plot_lib=plot_lib, xlim=[-10,10])
            colormap = 'angle'
            # Create field
            field = (bs.x+1j*bs.x)/200
            fig, ax = bs.plot_complex_field(field, colorbar=True, colormap=colormap)
            if show_plots:
                bs.show(fig)
            self.assertIsNotNone(fig, msg=f'plot_complex_field in 1D with custom colorbar failed for plot_lib={plot_lib}')

    def test_colorbar_2D(self):
        for plot_lib in ['plotly', 'matplotlib']:
            # Initialize BaseSystem object
            bs = cf.BaseSystem(2, plot_lib=plot_lib, xlim=[-10,10], ylim=[-10,10])
            colormap = 'angle'
            # Create field
            field = (bs.x+1j*bs.y)/200
            fig, ax = bs.plot_complex_field(field, colorbar=True, colormap=colormap)
            if show_plots:
                bs.show(fig)
            self.assertIsNotNone(fig, msg=f'plot_complex_field in 2D with custom colorbar failed for plot_lib={plot_lib}')

    def test_colorbar_3D(self):
        for plot_lib in ['plotly', 'matplotlib']:
            # Initialize BaseSystem object
            bs = cf.BaseSystem(3, plot_lib=plot_lib, xlim=[-10,10], ylim=[-10,10], zlim=[-10,10])
            colormap = 'angle'
            # Create field
            field = (bs.x+1j*bs.y+1j*bs.z)/200
            fig, ax = bs.plot_complex_field(field, colorbar=True, colormap=colormap)
            if show_plots:
                bs.show(fig)
            self.assertIsNotNone(fig, msg=f'plot_complex_field in 3D with custom colorbar failed for plot_lib={plot_lib}')

if __name__ == '__main__':
    unittest.main()
--- End of file: tests\tests_plot\test_plot_complex_field.py ---

--- Start of file: tests\tests_plot\test_plot_complex_field_in_plane.py ---
import unittest
import sys
import os

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../../')))
import comfit as cf
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../../')))
import comfit as cf
import numpy as np
import scipy as sp


show_plots = False

class TestPlotComplexFieldInPlane(unittest.TestCase):

    def tearDown(self):
        import matplotlib.pyplot as plt
        plt.close('all')

    def test(self):
        for plot_lib in ['matplotlib', 'plotly']:
            # Initialize BaseSystem object
            bs = cf.BaseSystem(3, plot_lib=plot_lib, xlim=[-10,10], ylim=[-10,10], zlim=[-10,10])
            # Create complex_field
            complex_field = (bs.x+bs.y+bs.z) + 1j*(bs.x-bs.y+bs.z)
            fig, ax = bs.plot_complex_field_in_plane(complex_field)
            if show_plots:
                bs.show(fig)
            self.assertIsNotNone(fig, msg=f'plot_complex_field_in_plane in 3D failed for plot_lib={plot_lib}')

    def test_colorbar(self):
        for plot_lib in ['matplotlib', 'plotly']:
            # Initialize BaseSystem object
            bs = cf.BaseSystem(3, plot_lib=plot_lib, xlim=[-10,10], ylim=[-10,10], zlim=[-10,10])
            colormap = 'winter'
            # Create complex_field
            complex_field = (bs.x+bs.y+bs.z) + 1j*(bs.x-bs.y+bs.z)
            fig, ax = bs.plot_complex_field_in_plane(complex_field, colorbar=True, colormap=colormap)
            if show_plots:
                bs.show(fig)
            self.assertIsNotNone(fig, msg=f'plot_complex_field_in_plane in 3D with custom colorbar failed for plot_lib={plot_lib}')

if __name__ == '__main__':
  unittest.main()
--- End of file: tests\tests_plot\test_plot_complex_field_in_plane.py ---

--- Start of file: tests\tests_plot\test_plot_field.py ---
import unittest
import sys
import os

# Run 
# Adjust the path to import the comfit package
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../../')))
import comfit as cf
import numpy as np
import scipy as sp

show_plots = False

class TestPlotField(unittest.TestCase):

  def tearDown(self):
      import matplotlib.pyplot as plt
      plt.close('all')

  def test_1D(self):
    for plot_lib in ['plotly', 'matplotlib']:
      # Initialize BaseSystem object
      bs = cf.BaseSystem(1, plot_lib=plot_lib, xlim=[-10,10])
      # Create field
      field = bs.x/200
      fig, ax = bs.plot_field(field)
      if show_plots:
        bs.show(fig)
      self.assertIsNotNone(fig, msg=f'plot_field in 1D failed for plot_lib={plot_lib}')

  def test_2D(self):
    for plot_lib in ['plotly', 'matplotlib']:
      # Initialize BaseSystem object
      bs = cf.BaseSystem(2, plot_lib=plot_lib, xlim=[-10,10], ylim=[-10,10])
      # Create field
      field = (bs.x+bs.y)/200
      fig, ax = bs.plot_field(field)
      if show_plots:
        bs.show(fig)
      self.assertIsNotNone(fig, msg=f'plot_field in 2D failed for plot_lib={plot_lib}')

  def test_3D(self):
    for plot_lib in ['plotly', 'matplotlib']:
      # Initialize BaseSystem object
      bs = cf.BaseSystem(3, plot_lib=plot_lib, xlim=[-10,10], ylim=[-10,10], zlim=[-10,10])
      # Create field
      field = (bs.x+bs.y+bs.z)/200
      fig, ax = bs.plot_field(field)
      if show_plots:
        bs.show(fig)
      self.assertIsNotNone(fig, msg=f'plot_field in 3D failed for plot_lib={plot_lib}')

  def test_colorbar_1D(self):
    for plot_lib in ['plotly', 'matplotlib']:
      # Initialize BaseSystem object
      bs = cf.BaseSystem(1, plot_lib=plot_lib, xlim=[-10,10])
      colormap = 'sunburst'
      # Create field
      field = bs.x/200
      fig, ax = bs.plot_field(field, colorbar=True, colormap=colormap)
      if show_plots:
        bs.show(fig)
      self.assertIsNotNone(fig, msg=f'plot_field in 1D with custom colorbar failed for plot_lib={plot_lib}')

  def test_colorbar_2D(self):
    for plot_lib in ['plotly', 'matplotlib']:
      # Initialize BaseSystem object
      bs = cf.BaseSystem(2, plot_lib=plot_lib, xlim=[-10,10], ylim=[-10,10])
      colormap = 'sunburst'
      # Create field
      field = (bs.x+bs.y)/200
      fig, ax = bs.plot_field(field, colorbar=True, colormap=colormap)
      if show_plots:
        bs.show(fig)
      self.assertIsNotNone(fig, msg=f'plot_field in 2D with custom colorbar failed for plot_lib={plot_lib}')

  def test_colorbar_3D(self):
    for plot_lib in ['plotly', 'matplotlib']:
      # Initialize BaseSystem object
      bs = cf.BaseSystem(3, plot_lib=plot_lib, xlim=[-10,10], ylim=[-10,10], zlim=[-10,10])
      colormap = 'sunburst'
      # Create field
      field = (bs.x+bs.y+bs.z)/200
      fig, ax = bs.plot_field(field, colorbar=True, colormap=colormap)
      if show_plots:
        bs.show(fig)
      self.assertIsNotNone(fig, msg=f'plot_field in 3D with custom colorbar failed for plot_lib={plot_lib}')

if __name__ == '__main__':
  unittest.main()
--- End of file: tests\tests_plot\test_plot_field.py ---

--- Start of file: tests\tests_plot\test_plot_field_in_plane.py ---
import unittest
import sys
import os

# Run 
# Adjust the path to import the comfit package
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../../')))
import comfit as cf
import numpy as np
import scipy as sp

show_plots = False

class TestPlotFieldInPlane(unittest.TestCase):

    def tearDown(self):
        import matplotlib.pyplot as plt
        plt.close('all')

    def test(self):
        for plot_lib in ['plotly', 'matplotlib']:
            # Initialize BaseSystem object
            bs = cf.BaseSystem(3, plot_lib=plot_lib, xlim=[-10,10], ylim=[-10,10], zlim=[-10,10])
            # Create field
            field = (bs.x+bs.y+bs.z)/200
            fig, ax = bs.plot_field_in_plane(field)
            if show_plots:
                bs.show
            self.assertIsNotNone(fig, msg=f'plot_field_in_plane in 3D failed for plot_lib={plot_lib}')

    def test_colorbar(self):
        for plot_lib in ['plotly', 'matplotlib']:
            # Initialize BaseSystem object
            bs = cf.BaseSystem(3, plot_lib=plot_lib, xlim=[-10,10], ylim=[-10,10], zlim=[-10,10])
            colormap = 'sunburst'
            # Create field
            field = (bs.x+bs.y+bs.z)/200
            fig, ax = bs.plot_field_in_plane(field, colorbar=True, colormap=colormap)
            if show_plots:
                bs.show(fig)
            self.assertIsNotNone(fig, msg=f'plot_field_in_plane in 3D with custom colorbar failed for plot_lib={plot_lib}')

if __name__ == '__main__':
  unittest.main()
--- End of file: tests\tests_plot\test_plot_field_in_plane.py ---

--- Start of file: tests\tests_plot\test_plot_function_parameters.py ---
import unittest
import sys
import os

# Run 
# Adjust the path to import the comfit package
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../../')))
import comfit as cf
import numpy as np
import scipy as sp

class TestBaseSystem(unittest.TestCase):

    def tearDown(self):
        import matplotlib.pyplot as plt
        plt.close('all')

    def test_plot_field_no_parameters(self):
        """ Test plotting of field """

        # 1 dimension
        # Initialize BaseSystem object
        bs = cf.BaseSystem(1, xRes=32, dx=0.1)

        # Create field
        np.random.seed(20423536)
        field = np.random.rand(bs.xRes)

        # Plot field
        try:
            bs.plot_field(field)
            
        except Exception as e:
            self.fail(f"Plotting failed: {e}")

        # 2 dimensions
        # Initialize BaseSystem object
        bs = cf.BaseSystem(2, xRes=32, dx=0.1, yRes=32, dy=0.1)

        # Create field
        np.random.seed(76427622)
        field = np.random.rand(bs.yRes, bs.xRes)

        # Plot field
        try:
            bs.plot_field(field)
            
        except Exception as e:
            self.fail(f"Plotting failed: {e}")

        # 3 dimensions
        # Initialize BaseSystem object

        bs = cf.BaseSystem(3, xRes=32, dx=0.1, yRes=32, dy=0.1, zRes=32, dz=0.1)

        # Create field
        np.random.seed(42000637)
        field = np.random.rand(bs.zRes, bs.yRes, bs.xRes)

        # Plot field
        try:
            bs.plot_field(field)
            
        except Exception as e:
            self.fail(f"Plotting failed: {e}")

    def test_plot_complex_field_no_parameters(self):
        """ Test plotting of complex field """

        # 1 dimension
        # Initialize BaseSystem object
        bs = cf.BaseSystem(1, xRes=32, dx=0.1)

        # Create field
        np.random.seed(83618706)
        field = np.random.rand(bs.xRes) + 1j*np.random.rand(bs.xRes)

        # Plot field
        try:
            bs.plot_complex_field(field)
            
        except Exception as e:
            self.fail(f"Plotting failed: {e}")

        # 2 dimensions
        # Initialize BaseSystem object
        bs = cf.BaseSystem(2, xRes=32, dx=0.1, yRes=32, dy=0.1)

        # Create field
        np.random.seed(86050252)
        field = np.random.rand(bs.yRes, bs.xRes) + 1j*np.random.rand(bs.yRes, bs.xRes)

        # Plot field
        try:
            bs.plot_complex_field(field)
            
        except Exception as e:
            self.fail(f"Plotting failed: {e}")

        # 3 dimensions
        # Initialize BaseSystem object
        bs = cf.BaseSystem(3, xRes=32, dx=0.1, yRes=32, dy=0.1, zRes=32, dz=0.1)

        # Create field
        np.random.seed(63363579)
        field = np.random.rand(bs.zRes, bs.yRes, bs.xRes) + 1j*np.random.rand(bs.zRes, bs.yRes, bs.xRes)

        # Plot field
        try:
            bs.plot_complex_field(field)
            
        except Exception as e:
            self.fail(f"Plotting failed: {e}")
    
    def test_plot_angle_field_no_parameters(self):
        """ Test plotting of angle field """

        # 1 dimension
        # Initialize BaseSystem object
        bs = cf.BaseSystem(1, xRes=32, dx=0.1)

        # Calculate angle field
        angle_field = 2*np.pi*np.random.rand(bs.xRes)-np.pi

        # Plot field
        try:
            bs.plot_angle_field(angle_field)
            
        except Exception as e:
            self.fail(f"Plotting failed: {e}")


        # 2 dimensions
        # Initialize BaseSystem object
        bs = cf.BaseSystem(2, xRes=32, dx=0.1, yRes=32, dy=0.1)

        # Calculate angle field
        np.random.seed(58271391)
        angle_field = 2*np.pi*np.random.rand(bs.yRes, bs.xRes)-np.pi

        # Plot field
        try:
            bs.plot_angle_field(angle_field)
            
        except Exception as e:
            self.fail(f"Plotting failed: {e}")

        # 3 dimensions
        # Initialize BaseSystem object
        bs = cf.BaseSystem(3, xRes=32, dx=0.1, yRes=32, dy=0.1, zRes=32, dz=0.1)

        # Calculate angle field
        np.random.seed(77579665)
        angle_field = 2*np.pi*np.random.rand(bs.zRes, bs.yRes, bs.xRes)-np.pi

        # Plot field
        try:
            bs.plot_angle_field(angle_field)
            
        except Exception as e:
            self.fail(f"Plotting failed: {e}")

    def test_plot_vector_field_no_parameters(self):
        """ Test plotting of vector field """

        # 1 dimension
        # Initialize BaseSystem object
        bs = cf.BaseSystem(1, xRes=32, dx=0.1)

        for vector_dim in range(1,4):
        # Create field
            np.random.seed(52137189)
            field = np.random.rand(vector_dim, bs.xRes)

            # Plot field
            try:
                bs.plot_vector_field(field)
                
            except Exception as e:
                self.fail(f"Plotting failed: {e}")

        # 2 dimensions
        # Initialize BaseSystem object
        bs = cf.BaseSystem(2, xRes=32, dx=0.1, yRes=32, dy=0.1)

        for vector_dim in range(1,4):
            # Create field
            np.random.seed(12138881)
            field = np.random.rand(vector_dim, bs.yRes, bs.xRes)

            # Plot field
            try:
                bs.plot_vector_field(field)
                
            except Exception as e:
                self.fail(f"Plotting failed: {e}")

        # 3 dimensions
        # Initialize BaseSystem object
        bs = cf.BaseSystem(3, xRes=32, dx=0.1, yRes=32, dy=0.1, zRes=32, dz=0.1)


        for vector_dim in range(1,4):
            # Create field
            np.random.seed(19623034)
            field = np.random.rand(vector_dim, bs.zRes, bs.yRes, bs.xRes)

            # Plot field
            try:
                bs.plot_vector_field(field)
                
            except Exception as e:
                self.fail(f"Plotting failed: {e}")

    def test_plot_field_in_plane(self):

        # 3 dimensions
        # Initialize BaseSystem object
        bs = cf.BaseSystem(3, xRes=32, dx=0.1, yRes=32, dy=0.1, zRes=32, dz=0.1)

        # Create field
        np.random.seed(14803969)
        field = np.random.rand(bs.zRes, bs.yRes, bs.xRes)

        # Plot field
        try:
            bs.plot_field_in_plane(field)
        except Exception as e:
            self.fail(f"Plotting failed: {e}")

    def test_plot_complex_field_in_plane(self):
        """ Test plotting of complex field in plane """

        # 3 dimensions
        # Initialize BaseSystem object
        bs = cf.BaseSystem(3, xRes=32, dx=0.1, yRes=32, dy=0.1, zRes=32, dz=0.1)

        # Create field
        np.random.seed(73158863)
        field = np.random.rand(bs.zRes, bs.yRes, bs.xRes) + 1j*np.random.rand(bs.zRes, bs.yRes, bs.xRes)

        # Plot field
        try:
            bs.plot_complex_field_in_plane(field)
        except Exception as e:
            self.fail(f"Plotting failed: {e}")

    def plot_angle_field_in_plane(self):
        """ Test plotting of angle field in plane """

        # 3 dimensions
        # Initialize BaseSystem object
        bs = cf.BaseSystem(3, xRes=32, dx=0.1, yRes=32, dy=0.1, zRes=32, dz=0.1)

        # Calculate angle field
        np.random.seed(15735094)
        angle_field = 2*np.pi*np.random.rand(bs.zRes, bs.yRes, bs.xRes)-np.pi

        # Plot field
        try:
            bs.plot_angle_field_in_plane(angle_field)
            
        except Exception as e:
            self.fail(f"Plotting failed: {e}")

    def plot_vector_field_in_plane(self):
        """ Test plotting of vector field in plane """

        # 3 dimensions
        # Initialize BaseSystem object
        bs = cf.BaseSystem(3, xRes=32, dx=0.1, yRes=32, dy=0.1, zRes=32, dz=0.1)

        for vector_dim in range(1,4):
            # Create field
            np.random.seed(56688066)
            field = np.random.rand(vector_dim, bs.zRes, bs.yRes, bs.xRes)

            # Plot field
            try:
                bs.plot_vector_field_in_plane(field)
                
            except Exception as e:
                self.fail(f"Plotting failed: {e}")

    def test_plot_field_with_different_parameters(self):
        bs = cf.BaseSystem(3, xRes=32, dx=0.1, yRes=32, dy=0.1, zRes=32, dz=0.1)
        bs.a0 = 2

        # Create field
        np.random.seed(97623584)
        field = np.random.rand(bs.zRes, bs.yRes, bs.xRes)

        # Test axis labels
        fig, ax = bs.plot_field(field, xlabel='x', ylabel='y', zlabel='z')
        self.assertEqual(fig['layout']['scene']['xaxis']['title']['text'], 'x')
        self.assertEqual(fig['layout']['scene']['yaxis']['title']['text'], 'y')
        self.assertEqual(fig['layout']['scene']['zaxis']['title']['text'], 'z')

        # Test xmin, xmax, ymin, ymax, zmin, zmax
        fig, ax = bs.plot_field(field, xmin=-3, xmax=4, ymin=-5, ymax=6, zmin=-7, zmax=8)
        self.assertEqual(fig['layout']['scene']['xaxis']['range'], (-3/bs.a0, 4/bs.a0))
        self.assertEqual(fig['layout']['scene']['yaxis']['range'], (-5/bs.a0, 6/bs.a0))
        self.assertEqual(fig['layout']['scene']['zaxis']['range'], (-7/bs.a0, 8/bs.a0))

        # Test xlim, ylim, zlim
        fig, ax = bs.plot_field(field, xlim=(-3, 4), ylim=(-5, 6), zlim=(-7, 8))
        self.assertEqual(fig['layout']['scene']['xaxis']['range'], (-3/bs.a0, 4/bs.a0))
        self.assertEqual(fig['layout']['scene']['yaxis']['range'], (-5/bs.a0, 6/bs.a0))
        self.assertEqual(fig['layout']['scene']['zaxis']['range'], (-7/bs.a0, 8/bs.a0))

        # Test xticks, yticks, zticks
        fig, ax = bs.plot_field(field, xticks=[-3, 0, 4], yticks=[-5, 0, 6], zticks=[-7, 0, 8])
        self.assertEqual(fig['layout']['scene']['xaxis']['tickvals'], (-3, 0, 4))
        self.assertEqual(fig['layout']['scene']['yaxis']['tickvals'], (-5, 0, 6))
        self.assertEqual(fig['layout']['scene']['zaxis']['tickvals'], (-7, 0, 8))


if __name__ == '__main__':
    unittest.main()

--- End of file: tests\tests_plot\test_plot_function_parameters.py ---

--- Start of file: tests\tests_plot\test_plot_vector_field.py ---
import unittest
import sys
import os

# Run 
# Adjust the path to import the comfit package
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../../')))
import comfit as cf
import numpy as np
import scipy as sp


show_plots = False

class TestPlotVectorField(unittest.TestCase):

    def tearDown(self):
        import matplotlib.pyplot as plt
        plt.close('all')

    def test_all_matplotlib(self):
        plot_lib = 'matplotlib'

        bs = cf.BaseSystem(1, plot_lib=plot_lib)
        fig, axs = bs.plot_subplots(3,3)

        for dim in [1,2,3]:
            bs = cf.BaseSystem(dim, plot_lib=plot_lib)

            for n in [1,2,3]:

                if dim == 1 and n == 1:
                    vector_field = [bs.x]
                elif dim == 1 and n == 2:
                    vector_field = [bs.x, 2*bs.x]
                elif dim == 1 and n == 3:
                    vector_field = [bs.x, 2*bs.x, 3*bs.x]
                elif dim == 2 and n == 1:
                    vector_field = [bs.x]
                elif dim == 2 and n == 2:
                    vector_field = [bs.x, bs.y]
                elif dim == 2 and n == 3:
                    vector_field = [bs.x, bs.y, 2*bs.x]
                elif dim == 3 and n == 1:
                    vector_field = [bs.x+bs.y]
                elif dim == 3 and n == 2:
                    vector_field = [bs.x+bs.y, 2*bs.x+2*bs.y]
                elif dim == 3 and n == 3:
                    vector_field = [bs.x+bs.y, 2*bs.x+2*bs.y, 3*bs.x+3*bs.y]

                try:
                    bs.plot_vector_field(vector_field, fig=fig, ax=axs[dim-1][n-1])
                except Exception as e:
                    self.fail(f'plot_vector_field failed for dim={dim}, n={n} with error: {e}')

        if show_plots:
            bs.show(fig)

    def test_all_plotly(self):
        plot_lib = 'plotly'

        bs = cf.BaseSystem(1, plot_lib=plot_lib)
        fig, axs = bs.plot_subplots(3,3)

        for dim in [1,2,3]:
            bs = cf.BaseSystem(dim, plot_lib=plot_lib)

            for n in [1,2,3]:

                if dim == 1 and n == 1:
                    vector_field = [bs.x]
                elif dim == 1 and n == 2:
                    vector_field = [bs.x, 2*bs.x]
                elif dim == 1 and n == 3:
                    vector_field = [bs.x, 2*bs.x, 3*bs.x]
                elif dim == 2 and n == 1:
                    vector_field = [bs.x]
                elif dim == 2 and n == 2:
                    vector_field = [bs.x, bs.y]
                elif dim == 2 and n == 3:
                    vector_field = [bs.x, bs.y, 2*bs.x]
                elif dim == 3 and n == 1:
                    vector_field = [bs.x+bs.y]
                elif dim == 3 and n == 2:
                    vector_field = [bs.x+bs.y, 2*bs.x+2*bs.y]
                elif dim == 3 and n == 3:
                    vector_field = [bs.x+bs.y, 2*bs.x+2*bs.y, 3*bs.x+3*bs.y]

                try:
                    bs.plot_vector_field(vector_field, fig=fig, ax=axs[dim-1][n-1])
                except Exception as e:
                    self.fail(f'plot_vector_field failed for dim={dim}, n={n} with error: {e}')

        if show_plots:
            bs.show(fig)

    def test_all_plotly_with_colorbar(self):
        plot_lib = 'plotly'

        bs = cf.BaseSystem(1, plot_lib=plot_lib)
        fig, axs = bs.plot_subplots(3,3)

        for dim in [1,2,3]:
            bs = cf.BaseSystem(dim, plot_lib=plot_lib)

            for n in [1,2,3]:

                if dim == 1 and n == 1:
                    vector_field = [bs.x]
                elif dim == 1 and n == 2:
                    vector_field = [bs.x, 2*bs.x]
                elif dim == 1 and n == 3:
                    vector_field = [bs.x, 2*bs.x, 3*bs.x]
                elif dim == 2 and n == 1:
                    vector_field = [bs.x]
                elif dim == 2 and n == 2:
                    vector_field = [bs.x, bs.y]
                elif dim == 2 and n == 3:
                    vector_field = [bs.x, bs.y, 2*bs.x]
                elif dim == 3 and n == 1:
                    vector_field = [bs.x+bs.y]
                elif dim == 3 and n == 2:
                    vector_field = [bs.x+bs.y, 2*bs.x+2*bs.y]
                elif dim == 3 and n == 3:
                    vector_field = [bs.x+bs.y, 2*bs.x+2*bs.y, 3*bs.x+3*bs.y]

                try:
                    bs.plot_vector_field(vector_field, fig=fig, ax=axs[dim-1][n-1], colorbar=True, colormap='sunburst')
                except Exception as e:
                    self.fail(f'plot_vector_field failed for dim={dim}, n={n} with error: {e}')

        if show_plots:
            bs.show(fig)

if __name__ == '__main__':
    unittest.main()
--- End of file: tests\tests_plot\test_plot_vector_field.py ---

--- Start of file: tests\tests_plot\test_plot_vector_field_in_plane.py ---
import unittest
import sys
import os

# Run 
# Adjust the path to import the comfit package
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../../')))
import comfit as cf
import numpy as np
import scipy as sp

show_plots = False

class TestPlotVectorField(unittest.TestCase):

    def tearDown(self):
        import matplotlib.pyplot as plt
        plt.close('all')

    def test_all_matplotlib(self):
        plot_lib = 'matplotlib'

        bs = cf.BaseSystem(1, plot_lib=plot_lib)
        fig, axs = bs.plot_subplots(1,3)

        bs = cf.BaseSystem(3, plot_lib=plot_lib)

        for n in [1,2,3]:

            if n == 1:
                vector_field = [bs.x+bs.y]
            elif n == 2:
                vector_field = [bs.x+bs.y, 2*bs.x+2*bs.y]
            elif n == 3:
                vector_field = [bs.x+bs.y, 2*bs.x+2*bs.y, 3*bs.x+3*bs.y]

            try:
                bs.plot_vector_field_in_plane(vector_field, fig=fig, ax=axs[n-1],spacing=1000)
            except Exception as e:
                self.fail(f'plot_vector_field failed for n={n} with error: {e}')

        if show_plots:
            bs.show(fig)

    def test_all_plotly(self):
        plot_lib = 'plotly'

        bs = cf.BaseSystem(1, plot_lib=plot_lib)
        fig, axs = bs.plot_subplots(1,3)

        bs = cf.BaseSystem(3, plot_lib=plot_lib)

        for n in [1,2,3]:

            if n == 1:
                vector_field = [bs.x+bs.y]
            elif n == 2:
                vector_field = [bs.x+bs.y, 2*bs.x+2*bs.y]
            elif n == 3:
                vector_field = [bs.x+bs.y, 2*bs.x+2*bs.y, 3*bs.x+3*bs.y]

            try:
                bs.plot_vector_field_in_plane(vector_field, fig=fig, ax=axs[n-1])
            except Exception as e:
                self.fail(f'plot_vector_field_in_plane with plotly failed for n={n} with error: {e}')

        if show_plots:
            bs.show(fig)
        # bs.show(fig)

    # def test_all_plotly_with_colorbar(self):
    #     plot_lib = 'plotly'

    #     bs = cf.BaseSystem(1, plot_lib=plot_lib)
    #     fig, axs = bs.plot_subplots(1,3)


    #     bs = cf.BaseSystem(3, plot_lib=plot_lib)

    #     for n in [1,2,3]:

    #         if n == 1:
    #             vector_field = [bs.x+bs.y]
    #         elif n == 2:
    #             vector_field = [bs.x+bs.y, 2*bs.x+2*bs.y]
    #         elif n == 3:
    #             vector_field = [bs.x+bs.y, 2*bs.x+2*bs.y, 3*bs.x+3*bs.y]

    #         try:
    #             bs.plot_vector_field_in_plane(vector_field, fig=fig, ax=axs[n-1], colorbar=True, colormap='sunburst')
    #         except Exception as e:
    #             self.fail(f'plot_vector_field_in_plane with plotly and custom colorbar failed for n={n} with error: {e}')

        # bs.show(fig)

if __name__ == '__main__':
    unittest.main()
--- End of file: tests\tests_plot\test_plot_vector_field_in_plane.py ---

--- Start of file: tests\tests_plot\test_plot_vector_field_matplotlib.py ---
import unittest
import sys
import os
import numpy as np
import matplotlib

# Run
# Adjust the path to import the comfit package 
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../../')))
import comfit as cf

class TestPlotVectorFieldMatplotlib(unittest.TestCase):

    def setUp(self):
        """Initialize the BaseSystem object for testing."""
        self.system1D = cf.BaseSystem(1, xRes=20)
        self.system2D = cf.BaseSystem(2, xRes=20, yRes=20)
        self.system3D = cf.BaseSystem(3, xRes=10, yRes=10, zRes=10)

        self.system1D.plot_lib = 'matplotlib'
        self.system2D.plot_lib = 'matplotlib'
        self.system3D.plot_lib = 'matplotlib'

    def tearDown(self):
        """Close all figures after each test."""
        import matplotlib.pyplot as plt
        plt.close('all')

    def test_plot_1D_vector_dim1(self):
        """Test 1D vector field with vector dimension 1."""
        vector_field = (np.random.rand(self.system1D.xRes),)
        fig, ax = self.system1D.plot_vector_field(vector_field)
        self.assertIsInstance(fig, matplotlib.figure.Figure)
        self.assertIsInstance(ax, matplotlib.axes.Axes)

    def test_plot_1D_vector_dim2(self):
        """Test 1D vector field with vector dimension 2."""
        vector_field = (np.random.rand(self.system1D.xRes), np.random.rand(self.system1D.xRes))
        fig, ax = self.system1D.plot_vector_field(vector_field)
        self.assertIsInstance(fig, matplotlib.figure.Figure)
        self.assertIsInstance(ax, matplotlib.axes.Axes)

    def test_plot_1D_vector_dim3(self):
        """Test 1D vector field with vector dimension 3."""
        vector_field = (
            np.random.rand(self.system1D.xRes),
            np.random.rand(self.system1D.xRes),
            np.random.rand(self.system1D.xRes)
        )
        fig, ax = self.system1D.plot_vector_field(vector_field)
        self.assertIsInstance(fig, matplotlib.figure.Figure)
        self.assertIsInstance(ax, matplotlib.axes.Axes)

    def test_plot_2D_vector_dim1(self):
        """Test 2D vector field with vector dimension 1."""
        vector_field = (np.random.rand(self.system2D.xRes, self.system2D.yRes),)
        fig, ax = self.system2D.plot_vector_field(vector_field)
        self.assertIsInstance(fig, matplotlib.figure.Figure)
        self.assertIsInstance(ax, matplotlib.axes.Axes)

    def test_plot_2D_vector_dim2(self):
        """Test 2D vector field with vector dimension 2."""
        vector_field = (
            np.random.rand(self.system2D.xRes, self.system2D.yRes),
            np.random.rand(self.system2D.xRes, self.system2D.yRes)
        )
        fig, ax = self.system2D.plot_vector_field(vector_field)
        self.assertIsInstance(fig, matplotlib.figure.Figure)
        self.assertIsInstance(ax, matplotlib.axes.Axes)

    def test_plot_2D_vector_dim3(self):
        """Test 2D vector field with vector dimension 3."""
        vector_field = (
            np.random.rand(self.system2D.xRes, self.system2D.yRes),
            np.random.rand(self.system2D.xRes, self.system2D.yRes),
            np.random.rand(self.system2D.xRes, self.system2D.yRes)
        )
        fig, ax = self.system2D.plot_vector_field(vector_field)
        self.assertIsInstance(fig, matplotlib.figure.Figure)
        self.assertIsInstance(ax, matplotlib.axes.Axes)

    def test_plot_3D_vector_dim1(self):
        """Test 3D vector field with vector dimension 1."""
        vector_field = (np.random.rand(self.system3D.xRes, self.system3D.yRes, self.system3D.zRes),)
        fig, ax = self.system3D.plot_vector_field(vector_field)
        self.assertIsInstance(fig, matplotlib.figure.Figure)
        self.assertIsInstance(ax, matplotlib.axes.Axes)

    def test_plot_3D_vector_dim2(self):
        """Test 3D vector field with vector dimension 2."""
        vector_field = (
            np.random.rand(self.system3D.xRes, self.system3D.yRes, self.system3D.zRes),
            np.random.rand(self.system3D.xRes, self.system3D.yRes, self.system3D.zRes)
        )
        fig, ax = self.system3D.plot_vector_field(vector_field)
        self.assertIsInstance(fig, matplotlib.figure.Figure)
        self.assertIsInstance(ax, matplotlib.axes.Axes)

    def test_plot_3D_vector_dim3(self):
        """Test 3D vector field with vector dimension 3."""
        vector_field = (
            np.random.rand(self.system3D.xRes, self.system3D.yRes, self.system3D.zRes),
            np.random.rand(self.system3D.xRes, self.system3D.yRes, self.system3D.zRes),
            np.random.rand(self.system3D.xRes, self.system3D.yRes, self.system3D.zRes)
        )
        fig, ax = self.system3D.plot_vector_field(vector_field)
        self.assertIsInstance(fig, matplotlib.figure.Figure)
        self.assertIsInstance(ax, matplotlib.axes.Axes)

if __name__ == '__main__':
    unittest.main()

--- End of file: tests\tests_plot\test_plot_vector_field_matplotlib.py ---

--- Start of file: tests\tests_plot\test_switching_between_plot_lib.py ---
import unittest
import sys
import os
import numpy as np

import matplotlib
import plotly.graph_objects as go

# Run
# Adjust the path to import the comfit package 
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../../')))
import comfit as cf

class TestSwitchingBetweenPlotLib(unittest.TestCase):
    def setUp(self):
        """Initialize the BaseSystem object for testing."""
        self.system1D = cf.BaseSystem(1, xRes=20)
        self.system2D = cf.BaseSystem(2, xRes=20, yRes=20)
        self.system3D = cf.BaseSystem(3, xRes=10, yRes=10, zRes=10)

    def tearDown(self):
        import matplotlib.pyplot as plt
        plt.close('all')

    def test_plot_field_1d(self):
        # Test 1D field
        field = (np.random.rand(self.system1D.xRes))

        # Single plots
        self.system1D.plot_lib = 'matplotlib'
        fig, ax = self.system1D.plot_field(field)
        self.assertIsInstance(fig, matplotlib.figure.Figure)
        self.assertIsInstance(ax, matplotlib.axes.Axes)

        self.system1D.plot_lib = 'plotly'
        fig, ax = self.system1D.plot_field(field)
        self.assertIsInstance(fig, go.Figure)

        # Subplots
        nrows = 2
        ncols = 3

        self.system1D.plot_lib = 'matplotlib'
        fig, axs = self.system1D.plot_subplots(nrows, ncols)
        for i in range(nrows):
            for j in range(ncols):
                fig, ax = self.system1D.plot_field(field, fig=fig, ax=axs[i][j])
        self.assertIsInstance(fig, matplotlib.figure.Figure)
        self.assertIsInstance(axs, np.ndarray)

        self.system1D.plot_lib = 'plotly'
        fig, axs = self.system1D.plot_subplots(nrows, ncols)
        for i in range(nrows):
            for j in range(ncols):
                fig, ax = self.system1D.plot_field(field, fig=fig, ax=axs[i][j])
        self.assertIsInstance(fig, go.Figure)

    def test_plot_field_2d(self):
        # Test 2D field
        field = (np.random.rand(self.system2D.xRes, self.system2D.yRes))

        # Single plots
        self.system2D.plot_lib = 'matplotlib'
        fig, ax = self.system2D.plot_field(field)
        self.assertIsInstance(fig, matplotlib.figure.Figure)
        self.assertIsInstance(ax, matplotlib.axes.Axes)

        self.system2D.plot_lib = 'plotly'
        fig, ax = self.system2D.plot_field(field)
        self.assertIsInstance(fig, go.Figure)

        # Subplots
        nrows = 2
        ncols = 3

        self.system2D.plot_lib = 'matplotlib'
        fig, axs = self.system2D.plot_subplots(nrows, ncols)
        for i in range(nrows):
            for j in range(ncols):
                fig, ax = self.system2D.plot_field(field, fig=fig, ax=axs[i][j])
        self.assertIsInstance(fig, matplotlib.figure.Figure)
        self.assertIsInstance(axs, np.ndarray)

        self.system2D.plot_lib = 'plotly'
        fig, axs = self.system2D.plot_subplots(nrows, ncols)
        for i in range(nrows):
            for j in range(ncols):
                fig, ax = self.system2D.plot_field(field, fig=fig, ax=axs[i][j])
        self.assertIsInstance(fig, go.Figure)


    def test_plot_field_3d(self):
        # Test 3D field
        field = (np.random.rand(self.system3D.xRes, self.system3D.yRes, self.system3D.zRes))

        # Single plots
        self.system3D.plot_lib = 'matplotlib'
        fig, ax = self.system3D.plot_field(field)
        self.assertIsInstance(fig, matplotlib.figure.Figure)
        self.assertIsInstance(ax, matplotlib.axes.Axes)

        self.system3D.plot_lib = 'plotly'
        fig, ax = self.system3D.plot_field(field)
        self.assertIsInstance(fig, go.Figure)

        # Subplots
        nrows = 2
        ncols = 3

        self.system3D.plot_lib = 'matplotlib'
        fig, axs = self.system3D.plot_subplots(nrows, ncols)
        for i in range(nrows):
            for j in range(ncols):
                fig, ax = self.system3D.plot_field(field, fig=fig, ax=axs[i][j])
        self.assertIsInstance(fig, matplotlib.figure.Figure)
        self.assertIsInstance(axs, np.ndarray)

        self.system3D.plot_lib = 'plotly'
        fig, axs = self.system3D.plot_subplots(nrows, ncols)
        for i in range(nrows):
            for j in range(ncols):
                fig, ax = self.system3D.plot_field(field, fig=fig, ax=axs[i][j])
        self.assertIsInstance(fig, go.Figure)


    
if __name__ == '__main__':
    unittest.main()
--- End of file: tests\tests_plot\test_switching_between_plot_lib.py ---

--- Start of file: tests\tests_plot\__init__.py ---

--- End of file: tests\tests_plot\__init__.py ---

--- Start of file: tests\tests_quantum_mechanics\test_quantum_mechanics.py ---
import unittest
import sys
import os

# Run 
# Adjust the path to import the comfit package
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../../')))
import comfit as cf
import matplotlib.pyplot as plt
import numpy as np


class TestQuantumMechanics(unittest.TestCase):

    def test_init_with_dimension(self):
        """Test QuantumMechanics initialization with a dimension parameter."""
        for dim in [1, 2, 3]:
            try:
                qm = cf.QuantumMechanics(dim)
                self.assertIsInstance(qm, cf.QuantumMechanics)
            except Exception as e:
                self.fail(f"Initialization failed with dimension {dim}: {e}")

    
    def test_evolution_conserved(self):
        """ Test that the evolution of a quantum state conserves the norm."""

        params = [{},{},{'xRes': 30, 'yRes': 30, 'zRes': 30}]

        for dim, p in zip([1, 2, 3],params):
            
            # Initialize a quantum mechanics system
            qm = cf.QuantumMechanics(dim,**p)
            qm.conf_initial_condition_Gaussian()

            # qm.plot_complex_field(qm.psi)
            # plt.show()

            # Check that the norm is approximately 1 at beginning
            norm_at_time0 = qm.calc_integrate_field(abs(qm.psi)**2)
            self.assertAlmostEqual(norm_at_time0, 1.0, places=3)
            
            # Evolve the state and check that the norm is still approximately 1
            qm.evolve_schrodinger(1000)
            norm_at_time1 = qm.calc_integrate_field(abs(qm.psi)**2)
            self.assertAlmostEqual(norm_at_time1, 1.0, places=3)
        


if __name__ == '__main__':
    unittest.main()

--- End of file: tests\tests_quantum_mechanics\test_quantum_mechanics.py ---

--- Start of file: tests\tests_quantum_mechanics\__init__.py ---

--- End of file: tests\tests_quantum_mechanics\__init__.py ---

--- Start of file: tests\tests_tool\test_tool_print_in_color.py ---
import unittest
import sys
import os

# Adjust the path to import the comfit package
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../../')))
import comfit as cf

class TestToolPrintInColor(unittest.TestCase):
    
    def test_default_color(self):
        """ Test if default color is red """
        try:
            cf.tool_print_in_color("Test string")
        except Exception as e:
            self.fail(f"tool_print_in_color raised an exception with default color: {e}")
    
    def test_valid_color(self):
        """ Test tool_print_in_color with various valid colors """
        valid_colors = ['red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white', 'black']
        for color in valid_colors:
            with self.subTest(color=color):
                try:
                    cf.tool_print_in_color(f"Test string in {color}", color=color)
                except Exception as e:
                    self.fail(f"tool_print_in_color raised an exception with color '{color}': {e}")
    
    def test_invalid_color(self):
        """ Test tool_print_in_color with an invalid color """
        with self.assertRaises(KeyError):
            cf.tool_print_in_color("Test string", color="purple")

    def test_empty_string(self):
        """ Test tool_print_in_color with an empty string """
        try:
            cf.tool_print_in_color("", color="red")
        except Exception as e:
            self.fail(f"tool_print_in_color raised an exception with an empty string: {e}")

if __name__ == '__main__':
    unittest.main()

--- End of file: tests\tests_tool\test_tool_print_in_color.py ---

--- Start of file: tests\tests_tool\__init__.py ---

--- End of file: tests\tests_tool\__init__.py ---

